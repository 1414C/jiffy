package controllers

//=============================================================================================
// base {{.Header.Name}} entity controller_relations code generated on {{ .GetDateTimeStamp }}
//=============================================================================================

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"strconv"

	"{{.AppPath}}/models"
	"github.com/gorilla/mux"
)

{{/*  $pref is populated by a call to .GetLowerCasePrefixLetter which is a  */ -}}
{{/*  method on the Entity struct in the main.go program file.              */ -}}
{{ $pref := .GetLowerCasePrefixLetter -}}

{{/*  Entity struct fields for use inside pipelines                         */}}
{{$headerName := .Header.Name -}}
{{$headerValue := .Header.Value -}}

{{/*  Fields slice for use inside pipelines                                 */}}
{{$fields := .Fields}}

{{/*  template needs:                                                       */ -}}
{{/*  1. loop over Relations                                                */ -}}
{{/*  2. function to determine which type of relation to create             */ -}}
{{/*  3. support for GET 1 and GET Many                                     */ -}}
{{/*  4. examine differences between hasOne, hasMany, belongsTo             */ -}}
{{/*  4. examine differences between hasOne, hasMany, belongsTo             */ -}}
{{/*  5. consider that the key fields (from and to) may have been defined   */ -}}
{{/*     as optional.  This means that indirection must be accounted for    */ -}}
{{/*     in the assignments.                                                */ -}}

{{ range .Relations -}}

{{/*  $toEntityFields contains the gen.[]Info field definitions for the     */ -}}
{{/*  ToEntity.  This is required for the validation of user-based key      */ -}}
{{/*  key selection (non-ID).                                               */ -}}
{{$toEntityFields := .ToEntInfo -}}
{{$toEntKeyFieldIsOptional := .ForeignPKOptional -}}
{{$fromEntKeyFieldIsOptional := .RefKeyOptional -}}

{{/*  Begin of the hasOne relations support               */ -}}
	{{if .GetHasOne -}}
// Get{{$headerName}}{{.RelName}} facilitates the retrieval of the {{.ToEntity}} related to {{$headerName}}
// by way of modeled 'hasOne' relationship {{.RelName}}.   
// This method is bound to the gorilla.mux router in appobj.go.
// 1:1
//
// GET /{{$headerName}}/:id/{{.RelName}}
// GET /{{$headerName}}/:id/{{.RelName}}/:id
func ({{$pref}}c *{{$headerName}}Controller) Get{{$headerName}}{{.RelName}} (w http.ResponseWriter, r *http.Request) {

	vars := mux.Vars(r)
	{{$headerValue}}ID, err := strconv.ParseUint(vars["{{$headerValue}}_id"], 10, 64)
	if err != nil {
		log.Println("{{$headerName}} Get:", err)
		respondWithError(w, http.StatusBadRequest, "Invalid {{$headerValue}} number")
		return
	}

	{{.ToEntityLC}}ID, err := strconv.ParseUint(vars["{{.ToEntityLC}}_id"], 10, 64)

	// build a base urlString for the JSON Body self-referencing Href tag
	// urlString := buildHrefStringFromCRUDReq(r, false)

	// in all cases the {{$headerValue}} must be retrieved, as the validity of the
	// the access-path must be verified.  Also consider that the {{.ToEntityLC}}
	// :id may not have been provided.
	{{$headerValue}} := models.{{$headerName}}{
		ID: {{$headerValue}}ID,
	}

	err = {{$pref}}c.{{$pref}}s.Get(&{{$headerValue}})
	if err != nil {
		log.Println(err)
		respondWithError(w, http.StatusBadRequest, err.Error())
		return
	}

	// populate params for ToEntity in the generic map
	map{{.ToEntity}}Params := make(map[string]interface{})
	{{.ToEntityLC}} := models.{{.ToEntity}}{}
	if {{.ToEntityLC}}ID != 0 {
		map{{.ToEntity}}Params["ID"] = {{.ToEntityLC}}ID
	}
	
	map{{.ToEntity}}Params["{{.ForeignPK}}"] = {{.FromEntityLC}}ID

	// call GetRel{{$headerName}}{{.RelName}} in the model
	err = {{$pref}}c.{{$pref}}s.GetRel{{$headerName}}{{.RelName}}(&{{.ToEntityLC}}, map{{.ToEntity}}Params)
	if err != nil {
		log.Println(err)
		respondWithError(w, http.StatusBadRequest, err.Error())
		return
	}

	// build the target url for the navigation, and then redirect thereby reusing
	// all the existing ConnectionState (TLS/transport/client etc.)
	{{.ToEntityLC}}.Href = ""
	if {{.ToEntityLC}}.ID != 0 {
		if r.TLS != nil {
			{{.ToEntityLC}}.Href = "https://"
		} else {
			{{.ToEntityLC}}.Href = "http://"
		}

		{{.ToEntityLC}}.Href = fmt.Sprintf("%s%s/{{.ToEntityLC}}/%d", {{.ToEntityLC}}.Href, r.Host, {{.ToEntityLC}}.ID)
		respondWithJSON(w, http.StatusCreated, {{.ToEntityLC}})
		return
	}
	respondWithJSON(w, http.StatusOK, "[]")
}
	
	{{end -}}


{{/*  Begin of the hasMany relations support                                 */ -}}
	{{if .GetHasMany -}}
// Get{{$headerName}}{{.RelName}} facilitates the retrieval of {{.ToEntity}}s related to {{$headerName}}
// by way of modeled 'hasMany' relationship {{.RelName}}.   
// This method is bound to the gorilla.mux router in appobj.go.
// 1:N
//
// GET /{{$headerName}}/:id/{{.RelName}}
// GET /{{$headerName}}/:id/{{.RelName}}/:id
func ({{$pref}}c *{{$headerName}}Controller) Get{{$headerName}}{{.RelName}} (w http.ResponseWriter, r *http.Request) {

	bSingle := false
	{{.ToEntityLC}} := models.{{.ToEntity}}{}
	{{.ToEntityLC}}s := []models.{{.ToEntity}}{}

	vars := mux.Vars(r)
	{{$headerValue}}ID, err := strconv.ParseUint(vars["{{$headerValue}}_id"], 10, 64)
	if err != nil {
		log.Println("{{$headerName}} Get:", err)
		respondWithError(w, http.StatusBadRequest, "Invalid {{$headerValue}} number")
		return
	}

	{{.ToEntityLC}}ID, err := strconv.ParseUint(vars["{{.ToEntityLC}}_id"], 10, 64)

	// build a base urlString for the JSON Body self-referencing Href tag
	// urlString := buildHrefStringFromCRUDReq(r, false)
	// fmt.Println("urlString:",urlString)

	// in all cases the {{$headerValue}} must be retrieved, as the validity of the
	// the access-path must be verified.  Also consider that the {{.ToEntityLC}}
	// :id may not have been provided.
	{{$headerValue}} := models.{{$headerName}}{
		ID: {{$headerValue}}ID,
	}

	err = {{$pref}}c.{{$pref}}s.Get(&{{$headerValue}})
	if err != nil {
		log.Println(err)
		respondWithError(w, http.StatusBadRequest, err.Error())
		return
	}

	// populate params for ToEntity in the generic map
	map{{.ToEntity}}Params := make(map[string]interface{})
	if {{.ToEntityLC}}ID != 0 {
		map{{.ToEntity}}Params["ID"] = {{.ToEntityLC}}ID
		bSingle = true
	}
	
	map{{.ToEntity}}Params["{{.ForeignPK}}"] = {{.FromEntityLC}}ID

	// call GetRel{{$headerName}}{{.RelName}} in the model
	err = {{$pref}}c.{{$pref}}s.GetRel{{$headerName}}{{.RelName}}(&{{.ToEntityLC}}s, map{{.ToEntity}}Params)
	if err != nil {
		log.Println(err)
		respondWithError(w, http.StatusBadRequest, err.Error())
		return
	}

	// populate Href for each {{.ToEntity}}
	baseHref := ""
	if r.TLS != nil {
		baseHref = "https://"
	} else {
		baseHref = "http://"
	}

	for i := range {{.ToEntityLC}}s {
		{{.ToEntityLC}}s[i].Href = fmt.Sprintf("%s%s/{{.ToEntityLC}}/%d", baseHref, r.Host, {{.ToEntityLC}}s[i].ID)
	}

	if bSingle {
		if len({{.ToEntityLC}}s) > 0 {
			{{.ToEntityLC}} = {{.ToEntityLC}}s[0]
			respondWithJSON(w, http.StatusCreated, {{.ToEntityLC}})
			return
		}
	} else {
		respondWithJSON(w, http.StatusCreated, {{.ToEntityLC}}s)
		return
	}
	respondWithJSON(w, http.StatusOK, "[]")
}

	{{end -}}

	{{/*  Begin of the belongsTo relations support                              */ -}}
	{{if .GetBelongsTo -}}
// GetRel{{$headerName}}{{.RelName}} facilitates the retrieval of {{.ToEntity}}s related to {{$headerName}}
// by way of modeled 'belongsTo' relationship {{.RelName}}.   
// This method is bound to the gorilla.mux router in appobj.go.
// 1:N
//
// GET /{{$headerName}}/:id/{{.RelName}}
// GET /{{$headerName}}/:id/{{.RelName}}/:id
func ({{$pref}}c *{{$headerName}}Controller) Get{{$headerName}}{{.RelName}} (w http.ResponseWriter, r *http.Request) {

	bSingle := false
	mapParams := make(map[string]interface{})
	{{.ToEntityLC}} := models.{{.ToEntity}}{}
	{{.ToEntityLC}}s := []models.{{.ToEntity}}{}
	vars := mux.Vars(r)

	{{.FromEntityLC}}ID, err := strconv.ParseUint(vars["{{.FromEntityLC}}_id"], 10, 64)
	if err != nil {
		log.Println("{{.FromEntity}} Get:", err)
		respondWithError(w, http.StatusBadRequest, "Invalid {{.FromEntityLC}} id")
		return
	}

	{{.ToEntityLC}}ID, err := strconv.ParseUint(vars["{{.ToEntityLC}}_id"], 10, 64)

	// build a base urlString for the JSON Body self-referencing Href tag
	// urlString := buildHrefStringFromCRUDReq(r, false)
	// fmt.Println("urlString:", urlString)

	// in all cases the {{.FromEntityLC}} must be retrieved, as the validity of the
	// the access-path must be verified.  Also consider that the {{.ToEntityLC}}_id
	// may not have been provided.
	{{.FromEntityLC}} := models.{{.FromEntity}}{
		ID: {{.FromEntityLC}}ID,
	}

	err = dc.ds.Get(&{{.FromEntityLC}})
	if err != nil {
		log.Println(err)
		respondWithError(w, http.StatusBadRequest, err.Error())
		return
	}

	// was the {{.ToEntityLC}}_id provided?
	if {{.ToEntityLC}}ID != 0 {
		if {{.FromEntityLC}}.{{.RefKey}} == {{.ToEntityLC}}ID {
			mapParams["{{.ForeignPK}}"] = {{.ToEntityLC}}ID
		} else {
			err := fmt.Errorf("bad request - keys in URL do not align")
			log.Println(err.Error())
			respondWithJSON(w, http.StatusBadRequest, "[]")
			return
		}
	} else {
		mapParams["{{.ForeignPK}}"] = {{.FromEntityLC}}.{{.RefKey}}
	}

	// call GetRel{{$headerName}}{{.RelName}} in the model
	err = dc.ds.GetRel{{$headerName}}{{.RelName}}(&{{.ToEntityLC}}s, mapParams)
	if err != nil {
		log.Println(err)
		respondWithError(w, http.StatusBadRequest, err.Error())
		return
	}
	// populate Href for each {{.ToEntity}}
	baseHref := ""
	if r.TLS != nil {
		baseHref = "https://"
	} else {
		baseHref = "http://"
	}

	for i := range {{.ToEntityLC}}s {
		petowners[i].Href = fmt.Sprintf("%s%s/{{.ToEntityLC}}/%d", baseHref, r.Host, {{.ToEntityLC}}s[i].ID)
	}

	if bSingle {
		if len({{.ToEntityLC}}s) > 0 {
			{{.ToEntityLC}} = {{.ToEntityLC}}s[0]
			respondWithJSON(w, http.StatusCreated, {{.ToEntityLC}})
			return
		}
	} else {
		respondWithJSON(w, http.StatusCreated, {{.ToEntityLC}}s)
		return
	}
	respondWithJSON(w, http.StatusOK, "[]")
}

	{{end -}}
{{end -}}
