package controllers

//=============================================================================================
// base {{.Header.Name}} entity controller_relations code generated on {{ .GetDateTimeStamp }}
//=============================================================================================

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"strconv"

	"{{.AppPath}}/models"
	"github.com/gorilla/mux"
)

{{/*  $pref is populated by a call to .GetLowerCasePrefixLetter which is a  */ -}}
{{/*  method on the Entity struct in the main.go program file.              */ -}}
{{ $pref := .GetLowerCasePrefixLetter -}}

{{/*  Entity struct fields for use inside pipelines                         */}}
{{$headerName := .Header.Name -}}
{{$headerValue := .Header.Value -}}

{{/*  Fields slice for use inside pipelines                                 */}}
{{$fields := .Fields}}

{{/*  template needs:                                                       */ -}}
{{/*  1. loop over Relations                                                */ -}}
{{/*  2. function to determine which type of relation to create             */ -}}
{{/*  3. support for GET 1 and GET Many                                     */ -}}
{{/*  4. examine differences between hasOne, hasMany, belongsTo             */ -}}

{{ range .Relations -}}

{{/* {{ $new_json := .BuildTestPostJSON $upd }}  */}}
{{ $toEntKeyField := .GetToEntKeyField $fields -}}
{{ $fromEntKeyField := .GetFromEntKeyField $fields -}}
{{ $fromEntKeyFieldIsOptional := .GetFromEntKeyFieldIsOptional $fromEntKeyField $fields -}}

	{{if .GetHasOne -}}
// Get{{$headerName}}{{.ToEntity}} facilitates the retrieval of the {{.ToEntity}} related to {{$headerName}}.  
// This method is bound to the gorilla.mux router in appobj.go.
//
// GET /{{$headerName}}/:id/{{.RelName}}
// GET /{{$headerName}}/:id/{{.RelName}}/:id
func ({{$pref}}c *{{$headerName}}Controller) Get{{$headerName}}{{.ToEntity}} (w http.ResponseWriter, r *http.Request) {

	vars := mux.Vars(r)
	{{$headerValue}}ID, err := strconv.ParseUint(vars["{{$headerValue}}_id"], 10, 64)
	if err != nil {
		log.Println("{{$headerName}} Get:", err)
		respondWithError(w, http.StatusBadRequest, "Invalid {{$headerValue}} number")
		return
	}

	{{.ToEntityLC}}ID, err := strconv.ParseUint(vars["{{.ToEntityLC}}_id"], 10, 64)

	// build a base urlString for the JSON Body self-referencing Href tag
	urlString := buildHrefStringFromCRUDReq(r, false)

	// in all cases the {{$headerValue}} must be retrieved, as the validity of the
	// the access-path must be verified.  Also consider that the {{.ToEntityLC}}
	// :id may not have been provided.
	{{$headerValue}} := models.{{$headerName}}{
		ID: {{$headerValue}}ID,
	}

	err = {{$pref}}c.{{$pref}}s.Get(&{{$headerValue}})
	if err != nil {
		log.Println(err)
		respondWithError(w, http.StatusBadRequest, err.Error())
		return
	}

	var {{.ToEntityLC}} models.{{.ToEntity}}

	// :{{.ToEntityLC}}_id was provided?
	if {{.ToEntityLC}}ID == 0 {

		relURI := strings.TrimPrefix(r.RequestURI, "/")
		uriSlice := strings.Split(relURI, "/")
		var pathSlice []string

		for i := 0; i < len(uriSlice); i++ {
			fmt.Printf("i:%d, uriSlice[i]: %s\n", i, uriSlice[i])
			if i == 0 || i == 1 {
				continue
			}
			pathSlice = append(pathSlice, uriSlice[i])
		}
		fmt.Println("pathSlice:", pathSlice)

		// should only have {{.ToEntityLC}}<value>
		for _, v := range pathSlice {
			switch v {
			case "{{.ToEntityLC}}":
				{{.ToEntityLC}}.{{$toEntKeyField}} = {{$fromEntKeyFieldIsOptional}}{{$headerValue}}.{{$fromEntKeyField}}
			}
		}
	} else {
		if {{.ToEntityLC}}ID == {{$fromEntKeyFieldIsOptional}}{{$headerValue}}.{{$fromEntKeyField}} {

			{{.ToEntityLC}}.{{$toEntKeyField}} = {{.ToEntityLC}}ID
		} else {

			err := fmt.Errorf("bad request - keys in URL do not align")
			log.Println(err.Error())
			respondWithError(w, http.StatusBadRequest, err.Error())
			return
		}
	}

	// build the target url for the navigation, and then redirect thereby reusing
	// all the existing ConnectionState (TLS/transport/client etc.)
	urlString = ""
	if r.TLS != nil {
		urlString = "https://"
	} else {
		urlString = "http://"
	}

	urlString = fmt.Sprintf("%s%s/{{.ToEntityLC}}/%d", urlString, r.Host, {{$fromEntKeyFieldIsOptional}}{{$headerValue}}.{{$fromEntKeyField}})
	http.Redirect(w, r, urlString, http.StatusSeeOther)
}
	{{end -}}


	{{if .GetHasMany -}}
// Get{{$headerName}}{{.ToEntity}}s facilitates the retrieval of the {{.ToEntity}} related to {{$headerName}}.  
// This method is bound to the gorilla.mux router in appobj.go.
//
// GET /{{$headerName}}/:id/{{.RelName}}s
// GET /{{$headerName}}/:id/{{.RelName}}/:id
func ({{$pref}}c *{{$headerName}}Controller) Get{{$headerName}}{{.ToEntity}}s (w http.ResponseWriter, r *http.Request) {

	vars := mux.Vars(r)
	{{$headerValue}}ID, err := strconv.ParseUint(vars["{{$headerValue}}_id"], 10, 64)
	if err != nil {
		log.Println("{{$headerName}} Get:", err)
		respondWithError(w, http.StatusBadRequest, "Invalid {{$headerValue}} number")
		return
	}

	{{.ToEntityLC}}ID, err := strconv.ParseUint(vars["{{.ToEntityLC}}_id"], 10, 64)

	// build a base urlString for the JSON Body self-referencing Href tag
	urlString := buildHrefStringFromCRUDReq(r, false)

	// in all cases the {{$headerValue}} must be retrieved, as the validity of the
	// the access-path must be verified.  Also consider that the {{.ToEntityLC}}
	// :id may not have been provided.
	{{$headerValue}} := models.{{$headerName}}{
		ID: {{$headerValue}}ID,
	}

	err = {{$pref}}c.{{$pref}}s.Get(&{{$headerValue}})
	if err != nil {
		log.Println(err)
		respondWithError(w, http.StatusBadRequest, err.Error())
		return
	}

	var {{.ToEntityLC}} models.{{.ToEntity}}	

	// :{{.ToEntityLC}}_id was provided?
	if {{.ToEntityLC}}ID == 0 {

		relURI := strings.TrimPrefix(r.RequestURI, "/")
		uriSlice := strings.Split(relURI, "/")
		var pathSlice []string

		for i := 0; i < len(uriSlice); i++ {
			fmt.Printf("i:%d, uriSlice[i]: %s\n", i, uriSlice[i])
			if i == 0 || i == 1 {
				continue
			}
			pathSlice = append(pathSlice, uriSlice[i])
		}
		fmt.Println("pathSlice:", pathSlice)

		// should only have {{.ToEntityLC}}<value>
		for _, v := range pathSlice {
			switch v {
			case "{{.ToEntityLC}}":
				{{.ToEntityLC}}.{{$toEntKeyField}} = {{$fromEntKeyFieldIsOptional}}{{$headerValue}}.{{$fromEntKeyField}}
			}
		}
	} else {
		if {{.ToEntityLC}}ID == {{$fromEntKeyFieldIsOptional}}{{$headerValue}}.{{$fromEntKeyField}} {

			{{.ToEntityLC}}.{{$toEntKeyField}} = {{.ToEntityLC}}ID
		} else {

			err := fmt.Errorf("bad request - keys in URL do not align")
			log.Println(err.Error())
			respondWithError(w, http.StatusBadRequest, err.Error())
			return
		}
	}

	// build the target url for the navigation, and then redirect thereby reusing
	// all the existing ConnectionState (TLS/transport/client etc.)
	urlString = ""
	if r.TLS != nil {
		urlString = "https://"
	} else {
		urlString = "http://"
	}

	urlString = fmt.Sprintf("%s%s/{{.ToEntityLC}}/%d", urlString, r.Host, {{$fromEntKeyFieldIsOptional}}{{$headerValue}}.{{$fromEntKeyField}})
	http.Redirect(w, r, urlString, http.StatusSeeOther)

}

	{{end -}}

	{{if .GetBelongsTo -}}


	{{end -}}
{{end -}}
