package controllers

//=============================================================================================
// base {{.Header.Name}} entity controller code generated on {{ .GetDateTimeStamp }}
//=============================================================================================

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"strconv"

	{{if .Header.GenControllerExt -}}
	"{{.AppPath}}/controllers/ext"
	{{end -}}
	"{{.AppPath}}/models"
	"github.com/gorilla/mux"
)

{{/*  $pref is populated by a call to .GetLowerCasePrefixLetter which is a  */ -}}
{{/*  method on the Entity struct in the main.go program file.              */ -}}
{{ $pref := .GetLowerCasePrefixLetter -}}

// {{.Header.Name}}Controller is the {{.Header.Value}} controller type for route binding
type {{.Header.Name}}Controller struct {
	{{$pref}}s models.{{.Header.Name}}Service
	{{if .Header.GenControllerExt -}}
	ep ext.{{.Header.Name}}CtrlExt
	{{end -}}
}

// New{{.Header.Name}}Controller creates a new {{.Header.Name}}Controller
func New{{.Header.Name}}Controller({{$pref}}s models.{{.Header.Name}}Service) *{{.Header.Name}}Controller {
	return &{{.Header.Name}}Controller{
		{{$pref}}s: {{$pref}}s,
		{{if .Header.GenControllerExt -}}
		ep: *ext.Init{{.Header.Name}}CtrlExt(),
		{{end -}}
	}
}

// Create facilitates the creation of a new {{.Header.Name}}.  This method is bound
// to the gorilla.mux router in main.go.
//
// POST /{{.Header.Value}}
func ({{$pref}}c *{{.Header.Name}}Controller) Create(w http.ResponseWriter, r *http.Request) {

    var err error

	{{if .Header.GenControllerExt -}}
	// TODO: implement extension-point if required
	// TODO: safe to comment this block out if the extension-point is not needed
	err = {{$pref}}c.ep.CrtEp.BeforeFirst(w, r)
	if err != nil {
		log.Println("{{.Header.Name}}Controller CreateBeforeFirst() error:", err)
		respondWithError(w, http.StatusBadRequest, "{{.Header.Value}}c: Invalid request")
		return
	}
	{{end -}}

	var {{$pref}} models.{{.Header.Name}}
	decoder := json.NewDecoder(r.Body)
	if err := decoder.Decode(&{{$pref}}); err != nil {
		log.Println("{{.Header.Name}} Create:",err)
		respondWithError(w, http.StatusBadRequest, "{{.Header.Value}}c: Invalid request payload")
		return
	}
	defer r.Body.Close()

	{{if .Header.GenControllerExt -}}
	// TODO: implement extension-point if required
	// TODO: safe to comment this block out if the extension-point is not needed
	err = {{$pref}}c.ep.CrtEp.AfterBodyDecode(&{{$pref}})
	if err != nil {
		log.Println("{{.Header.Name}}Controller CreateAfterBodyDecode() error:", err)
		respondWithError(w, http.StatusBadRequest, "{{.Header.Value}}c: Invalid request payload")
		return
	}
	{{end -}}

	// fill the model
	{{.Header.Value}} := models.{{.Header.Name}} {
		{{range .Fields -}} 
    	{{.Name}}:  {{$pref}}.{{.Name -}},
		{{end}}
	}

	// build a base urlString for the JSON Body self-referencing Href tag
	urlString := buildHrefStringFromCRUDReq(r, true)

	// call the Create method on the {{.Header.Value}} model
	err = {{$pref}}c.{{$pref}}s.Create(&{{.Header.Value}})
	if err != nil {
		log.Println("{{.Header.Name}} Create:",err)
		respondWithError(w, http.StatusBadRequest, err.Error())
		return
	}
	{{.Header.Value}}.Href = urlString + strconv.FormatUint(uint64({{.Header.Value}}.ID), 10)

	{{if .Header.GenControllerExt -}}
	// TODO: implement extension-point if required
	// TODO: safe to comment this block out if the extension-point is not needed
	err = {{$pref}}c.ep.CrtEp.BeforeResponse(&{{.Header.Value}})
	if err != nil {
		log.Println("{{.Header.Name}}Controller CreateBeforeResponse() error:", err)
		respondWithError(w, http.StatusBadRequest, "{{.Header.Value}}c: Invalid request")
		return
	}
	{{end -}}

	respondWithJSON(w, http.StatusCreated, {{.Header.Value}})
}

// Update facilitates the update of an existing {{.Header.Name}}.  This method is bound
// to the gorilla.mux router in main.go.
//
// PUT /{{.Header.Value}}:id
func ({{$pref}}c *{{.Header.Name}}Controller) Update(w http.ResponseWriter, r *http.Request) {

	var err error

	{{if .Header.GenControllerExt -}}
	// TODO: implement extension-point if required
	// TODO: safe to comment this block out if the extension-point is not needed
	err = {{$pref}}c.ep.UpdEp.BeforeFirst(w, r)
	if err != nil {
		log.Println("{{.Header.Name}}Controller UpdateBeforeFirst() error:", err)
		respondWithError(w, http.StatusBadRequest, "{{.Header.Value}}c: Invalid request")
		return
	}
	{{end -}}

	// get the parameter(s)
	vars := mux.Vars(r)
	id, err := strconv.ParseUint(vars["id"], 10, 64)
	if err != nil {
		log.Println("{{.Header.Name}} Update:",err)
		respondWithError(w, http.StatusBadRequest, "Invalid {{.Header.Value}} id")
		return
	}

	var {{$pref}} models.{{.Header.Name}}
	decoder := json.NewDecoder(r.Body)
	if err := decoder.Decode(&{{$pref}}); err != nil {
		log.Println("{{.Header.Name}} Update:",err)				
		respondWithError(w, http.StatusBadRequest, "Invalid request payload")
		return
	}
	defer r.Body.Close()

	{{if .Header.GenControllerExt -}}
	// TODO: implement extension-point if required
	// TODO: safe to comment this block out if the extension-point is not needed
	err = {{$pref}}c.ep.UpdEp.AfterBodyDecode(&{{$pref}})
	if err != nil {
		log.Println("{{.Header.Name}}Controller UpdateAfterBodyDecode() error:", err)
		respondWithError(w, http.StatusBadRequest, "{{.Header.Value}}c: Invalid request payload")
		return
	}
	{{end -}}

	// fill the model
	{{.Header.Value}} := models.{{.Header.Name}} {
		{{range .Fields -}} 
    	{{.Name}}:  {{$pref}}.{{.Name -}},
		{{end}}
	}

	// build a base urlString for the JSON Body self-referencing Href tag
	urlString := buildHrefStringFromCRUDReq(r, false)

	{{/*  sqac-specific DB table header field id is used.  this would need to  */ -}}
	{{/*  change if the ORM was replaced with a native db interface            */ -}}
	{{.Header.Value}}.ID = id

	// call the update method on the model
	err = {{$pref}}c.{{$pref}}s.Update(&{{.Header.Value}})
	if err != nil {
		log.Println("{{.Header.Name}} Update:",err)
		respondWithError(w, http.StatusBadRequest, err.Error())
		return
	}
	{{.Header.Value}}.Href = urlString

	{{if .Header.GenControllerExt -}}
	// TODO: implement extension-point if required
	// TODO: safe to comment this block out if the extension-point is not needed
	err = {{$pref}}c.ep.UpdEp.BeforeResponse(&{{.Header.Value}})
	if err != nil {
		log.Println("{{.Header.Name}}Controller UpdateBeforeResponse() error:", err)
		respondWithError(w, http.StatusBadRequest, "{{.Header.Value}}c: Invalid request")
		return
	}
	{{end -}}

	respondWithJSON(w, http.StatusCreated, {{.Header.Value}})
}

// Get facilitates the retrieval of an existing {{.Header.Name}}.  This method is bound
// to the gorilla.mux router in main.go.
//
// GET /{{.Header.Value}}/:id
func ({{$pref}}c *{{.Header.Name}}Controller) Get(w http.ResponseWriter, r *http.Request) {

	var err error

	{{if .Header.GenControllerExt -}}
	// TODO: implement extension-point if required
	// TODO: safe to comment this block out if the extension-point is not needed
	err = {{$pref}}c.ep.GetEp.BeforeFirst(w, r)
	if err != nil {
		log.Println("{{.Header.Name}}Controller GetBeforeFirst() error:", err)
		respondWithError(w, http.StatusBadRequest, "{{.Header.Value}}c: Invalid request")
		return
	}
	{{end -}}

	vars := mux.Vars(r)
	id, err := strconv.ParseUint(vars["id"], 10, 64)
	if err != nil {
		log.Println("{{.Header.Name}} Get:",err)
		respondWithError(w, http.StatusBadRequest, "Invalid {{.Header.Value}} ID")
		return
	}

	// build a base urlString for the JSON Body self-referencing Href tag
	urlString := buildHrefStringFromCRUDReq(r, false)

	{{.Header.Value}} := models.{{.Header.Name}}{
		ID: id,
	}

	{{if .Header.GenControllerExt -}}
	// TODO: implement extension-point if required
	// TODO: safe to comment this block out if the extension-point is not needed
	err = {{$pref}}c.ep.GetEp.BeforeModelCall(&{{.Header.Value}})
	if err != nil {
		log.Println("{{.Header.Name}}Controller GetBeforeModelCall() error:", err)
		respondWithError(w, http.StatusBadRequest, "{{.Header.Value}}c: Invalid request")
		return
	}
	{{end -}}

	err = {{$pref}}c.{{$pref}}s.Get(&{{.Header.Value}})
	if err != nil {
		log.Println(err)
		respondWithError(w, http.StatusBadRequest, err.Error())
		return
	}
	{{.Header.Value}}.Href = urlString

	{{if .Header.GenControllerExt -}}
	// TODO: implement extension-point if required
	// TODO: safe to comment this block out if the extension-point is not needed
	err = {{$pref}}c.ep.GetEp.BeforeResponse(&{{.Header.Value}})
	if err != nil {
		log.Println("{{.Header.Name}}Controller GetBeforeResponse() error:", err)
		respondWithError(w, http.StatusBadRequest, "{{.Header.Value}}c: Invalid request")
		return
	}
	{{end -}}

	respondWithJSON(w, http.StatusCreated, {{.Header.Value}})
}

// Delete facilitates the deletion of an existing {{.Header.Name}}.  This method is bound
// to the gorilla.mux router in main.go.
//
// DELETE /{{.Header.Value}}/:id
func ({{$pref}}c *{{.Header.Name}}Controller) Delete(w http.ResponseWriter, r *http.Request) {
	
	vars := mux.Vars(r)
	id, err := strconv.ParseUint(vars["id"], 10, 64)
	if err != nil {
		log.Println("{{.Header.Name}} Delete:",err)
		respondWithError(w, http.StatusBadRequest, "Invalid {{.Header.Name}} ID")
		return
	}

	{{.Header.Value}} := models.{{.Header.Name}}{
		ID: id,
	}

	err = {{$pref}}c.{{$pref}}s.Delete(&{{.Header.Value}})
	if err != nil {
		log.Println("{{.Header.Name}} Delete:",err)
		respondWithError(w, http.StatusBadRequest, err.Error())
		return
	}
	respondWithHeader(w, http.StatusAccepted)
}

// Get{{.Header.Name}}s facilitates the retrieval of all existing {{.Header.Name}}s.  This method is bound
// to the gorilla.mux router in main.go.
//
// GET /{{.Header.Value}}s
func ({{$pref}}c *{{.Header.Name}}Controller) Get{{.Header.Name}}s(w http.ResponseWriter, r *http.Request) {

	// build base Href; common for each selected row
	urlString := buildHrefStringFromCRUDReq(r, true)
	urlString = strings.TrimSuffix(urlString,"s/")
	urlString = urlString + "/"

	{{.Header.Value}}s := {{$pref}}c.{{$pref}}s.Get{{.Header.Name}}s()
	if {{.Header.Value}}s != nil {
		for i, {{$pref}} := range {{.Header.Value}}s {
			{{.Header.Value}}s[i].Href = urlString + strconv.FormatUint(uint64({{$pref}}.ID), 10)
		}
		respondWithJSON(w, http.StatusOK, {{.Header.Value}}s)
		return
	}
	respondWithJSON(w, http.StatusOK, "[]")
}


{{/*  generate optional simple query support based on the Info.Selectable,  */ -}}
{{/*  info.Value (type).                                                    */ -}}
{{ $headerName := .Header.Name -}}
{{ $headerValue := .Header.Value -}}
{{range .Fields -}}
{{if .Selectable -}}
// Get{{$headerName}}sBy{{.Name}} facilitates the retrieval of existing 
// {{$headerName}}s based on {{.Name}}.
{{if .IsStringFieldType -}}
// GET /{{$headerValue}}s/{{.SnakeCaseName}}(OP 'searchString')
{{else}}
// GET /{{$headerValue}}s/{{.SnakeCaseName}}(OP searchValue)
{{end -}}
func ({{$pref}}c *{{$headerName}}Controller) Get{{$headerName}}sBy{{.Name}} (w http.ResponseWriter, r *http.Request) {

	vars := mux.Vars(r)
	searchValue := vars["{{.SnakeCaseName}}"]
	if searchValue == "" {
		respondWithError(w, http.StatusBadRequest, "missing search criteria")
		return
	}

	op, predicate, err := {{.GetQueryComponentFuncCall}} 
	if err != nil {
		respondWithError(w, http.StatusBadRequest, fmt.Sprintf(`{"Get{{$headerName}}sBy{{.Name}}": "%s"}`, err))
		return
	}

	// build base Href; common for each selected row
	urlString, err := buildHrefStringFromSimpleQueryReq(r, true)
	if err != nil {
		respondWithError(w, http.StatusBadRequest, fmt.Sprintf(`{"Get{{$headerName}}sBy{{.Name}}": "%s"}`, err))
		return
	}

	{{$headerValue}}s := {{$pref}}c.{{$pref}}s.Get{{$headerName}}sBy{{.Name}}(op, predicate)
	if {{$headerValue}}s != nil {

		// add the base Href/{id}
		for i, {{$pref}} := range {{$headerValue}}s {
			{{$headerValue}}s[i].Href = urlString + strconv.FormatUint(uint64({{$pref}}.ID), 10)
		}
		respondWithJSON(w, http.StatusOK, {{$headerValue}}s)
		return
	}
	respondWithJSON(w, http.StatusOK, "[]")
}
{{end -}}
{{end -}}





