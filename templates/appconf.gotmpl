package appobj

import (
	"encoding/json"
	"fmt"
	"log"
	"os"
)

// DBConfig type hold pg config info
type DBConfig struct {
	DBDialect string `json:"db_dialect"`
	Host      string `json:"host"`
	Port      int    `json:"port"`
	Usr      string  `json:"Usr"`
	Password  string `json:"Password"`
	Name      string `json:"name"`
}

// ServiceActivation struct
type ServiceActivation struct {
	ServiceName   string `json:"service_name"`
	ServiceActive bool   `json:"service_active"`
}

// ConnectionInfo returns a DBConfig string
func (c DBConfig) ConnectionInfo() string {

	switch c.Dialect() {
	case "postgres":
		if c.Password == "" {
			return fmt.Sprintf("host=%s port=%d user=%s dbname=%s sslmode=disable", c.Host, c.Port, c.Usr, c.Name)
		}
		return fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=disable", c.Host, c.Port, c.Usr, c.Password, c.Name)

	case "mssql":
		// "sqlserver://SA:Bunny123!!@localhost:1401?database=sqlx")
		return fmt.Sprintf("sqlserver://%s:%s@%s:%d?database=%s", c.Usr, c.Password, c.Host, c.Port, c.Name)

	case "hdb":
		// "hdb://SMACLEOD:Blockhead1@clkhana01.lab.clockwork.ca:30047")
		return fmt.Sprintf("hdb://%s:%s@%s:%d", c.Usr, c.Password, c.Host, c.Port)

	case "sqlite":
		// "sqlite3", "testdb.sqlite"
		return fmt.Sprintf("%s", c.Name)

	case "mysql":
		// "stevem:gogogo123@tcp(192.168.1.50:3306)/sqlx?charset=utf8&parseTime=True&loc=Local")
		return fmt.Sprintf("%s:%s@tcp(%s:%d)/%s?charset=utf8&parseTime=True&loc=Local", c.Usr, c.Password, c.Host, c.Port, c.Name)

	default:
		panic(fmt.Errorf("dialect %s is not recognized", c.DBDialect))

	}
}

// Dialect returns the db type
func (c DBConfig) Dialect() string {
	return c.DBDialect
}

// DefaultDBConfig provides a default db config
// for use in development testing
func DefaultDBConfig() DBConfig {
	return DBConfig{
		DBDialect:  "{{.Database.DBDialect}}",
		Host:     	"{{.Database.Host}}",
		Port:     	{{.Database.Port}},
		Usr:     	"{{.Database.Usr}}",
		Password: 	"{{.Database.Password}}",
		Name:     	"{{.Database.Name}}",
	}
}

// Config isProd := false
// likely don't need the private-keys beyond what is used in Login()
type Config struct {
	Port           		int            		`json:"port"`
	Env            		string         		`json:"env"`
	Pepper         		string         		`json:"pepper"`
	Database       		DBConfig       		`json:"database"`
	CertFile       		string         		`json:"cert_file"`
	KeyFile        		string         		`json:"key_file"`
	RSA256PrivKeyFile   string              `json:"rsa256_priv_key_file"`
	RSA256PubKeyFile    string              `json:"rsa256_pub_key_file"`
	RSA384PrivKeyFile   string              `json:"rsa384_priv_key_file"`
	RSA384PubKeyFile    string              `json:"rsa384_pub_key_file"`
	RSA512PrivKeyFile   string              `json:"rsa512_priv_key_file"`
	RSA512PubKeyFile    string              `json:"rsa512_pub_key_file"`
	ECDSA256PrivKeyFile string              `json:"ecdsa256_priv_key_file"`
	ECDSA256PubKeyFile  string              `json:"ecdsa256_pub_key_file"`
	ECDSA384PrivKeyFile string              `json:"ecdsa384_priv_key_file"`
	ECDSA384PubKeyFile  string              `json:"ecdsa384_pub_key_file"`
	ECDSA521PrivKeyFile string              `json:"ecdsa521_priv_key_file"`
	ECDSA521PubKeyFile  string              `json:"ecdsa521_pub_key_file"`
	ServiceActivations []ServiceActivation 	`json:"service_activations"`
}

// IsProd informs the app which environment it is running in
func (c Config) IsProd() bool {
	if c.Env == "prod" {
		return true
	}
	return false
}

// IsDev informs the app which environment it is running in
func (c Config) IsDev() bool {
	if c.Env == "dev" {
		return true
	}
	return false
}

// DefaultServiceActivations returns the app's default service activations
func DefaultServiceActivations() []ServiceActivation {
	s := ServiceActivation{}
	sa := []ServiceActivation{}
	{{range .ServiceActivations -}}
	s.ServiceName = "{{.ServiceName}}"
	s.ServiceActive = true
	sa = append(sa, s)

	{{end -}}
	return sa
}

// DefaultConfig returns the app's default config in a Config structure
func DefaultConfig() Config {
	return Config{
		Port:           		{{.Port}},
		Env:            		"{{.Env}}",
		Pepper:         		"{{.Pepper}}",
		Database:       		DefaultDBConfig(),
		CertFile:       		"{{.CertFile}}",    // https
		KeyFile:        		"{{.KeyFile}}",     // https
		RSA256PrivKeyFile:   	"",
		RSA256PubKeyFile:    	"",
		RSA384PrivKeyFile:   	"",
		RSA384PubKeyFile:    	"",
		RSA512PrivKeyFile:   	"",
		RSA512PubKeyFile:    	"",
		ECDSA256PrivKeyFile: 	"",
		ECDSA256PubKeyFile:  	"",
		ECDSA384PrivKeyFile: 	"{{.JWTPrivKeyFile}}",
		ECDSA384PubKeyFile:  	"{{.JWTPubKeyFile}}",
		ECDSA521PrivKeyFile: 	"",
		ECDSA521PubKeyFile:  	"",
		ServiceActivations: DefaultServiceActivations(),
	}
}

// LoadConfig loads the config file, or falls back to the default
func LoadConfig(configReq RunMode) Config {
	
	var fName string
	switch configReq {
	case cDev:
		fName = ".dev.config.json"
	case cPrd:
		fName = ".prd.config.json"
	default:
		fName = "default_config" // not a file ;)
	}

	f, err := os.Open(fName) // cDef will always fail here - ok
	if err != nil {
		if configReq != cDef {
			panic(err)
		}
		fmt.Println("using the default config...")
		return DefaultConfig()
	}
	var c Config
	dec := json.NewDecoder(f)
	err = dec.Decode(&c)
	if err != nil {
		panic(err)
	}
	log.Println("successfully loaded the config file...")
	log.Println("config:", c)
	return c
}
