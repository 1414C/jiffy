[
{
	"uri": "https://1414c.github.io/jiffy/getting-started/gs-content-a/",
	"title": "Go Environment",
	"tags": [],
	"description": "",
	"content": "If you already have Go installed and know that your installation is working, you should skip to the next section. If you need to get Go installed on your machine, keep reading.\nGo is easy to setup and can be installed from source or binary package, both which are available at golang.org.\n Go binary installation instructions Go build-from-source installation instructions  "
},
{
	"uri": "https://1414c.github.io/jiffy/overview/",
	"title": "Jiffy Overview",
	"tags": [],
	"description": "",
	"content": " Overview and Features Jiffy "
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/",
	"title": "Getting Started",
	"tags": [],
	"description": "",
	"content": " Getting Started Initial Setup Before we get start generating services, there are few things to get out of the way. First we need to make sure that the Go environment is setup, then we need to get jiffy installed.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/installation/",
	"title": "Jiffy Installation",
	"tags": [],
	"description": "",
	"content": " Installation and Dependencies Jiffy "
},
{
	"uri": "https://1414c.github.io/jiffy/execution/",
	"title": "Jiffy Execution",
	"tags": [],
	"description": "",
	"content": " Execution Options Jiffy "
},
{
	"uri": "https://1414c.github.io/jiffy/models/",
	"title": "Model Maintenance",
	"tags": [],
	"description": "",
	"content": " Model Maintenance Jiffy "
},
{
	"uri": "https://1414c.github.io/jiffy/generation/",
	"title": "Generation Reference",
	"tags": [],
	"description": "",
	"content": " Application Generation Jiffy "
},
{
	"uri": "https://1414c.github.io/jiffy/extensionpoints/",
	"title": "Extension Points",
	"tags": [],
	"description": "",
	"content": " Extension Points Jiffy "
},
{
	"uri": "https://1414c.github.io/jiffy/accesscontrol/",
	"title": "Access Control",
	"tags": [],
	"description": "",
	"content": " Access Control Jiffy "
},
{
	"uri": "https://1414c.github.io/jiffy/interprocess/",
	"title": "Interprocess Communication",
	"tags": [],
	"description": "",
	"content": " Interprocess Communication Jiffy "
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/gs-content-b/",
	"title": "Installing Jiffy",
	"tags": [],
	"description": "",
	"content": "The easiest way to install Jiffy is to use go get on the command-line to pull the latest version from github, as shown below:\n$ go get -u github.com/1414C/jiffy  This will pull the jiffy github repository into your $GOPATH/src/github.com folder, as well as any dependencies referenced by the jiffy source code. The -u flag is included to instruct go get to check for and pull updates to jiffy packages and their dependencies. This is the least sophisticated way of managing dependencies in go.\nOnce the jiffy source code and dependencies have been installed into your $GOPATH, you can use go build to compile a binary from the jiffy sources. The easiest way to do this is to open a terminal window, switch to $GOPATH/src/github.com/1414C/jiffy and run go build as shown below.\n$ go build -v  This will result in the creation of a binary file called \u0026lsquo;jiffy\u0026rsquo;. You may move the \u0026lsquo;jiffy\u0026rsquo; binary anywhere in your $PATH, but convention would have you install it in /usr/local/bin. Once you have moved the \u0026lsquo;jiffy\u0026rsquo; binary to its new home, open a new terminal window and use the which command to ensure that you can access the binary.\n$ which jiffy -a  If which cannot find the jiffy binary (or finds the wrong one!), you need to make sure that your $PATH is set correctly.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/extensionpoints/ep-content-a/",
	"title": "Extension Point Overview",
	"tags": [],
	"description": "",
	"content": " Extension-Points (ext folders) The Jiffy application generates a working web services application based on the provided model files. While the generated application should be runnable immediately following generation, there is often a need to perform validation and normalization of the incoming data. This is best coded in the model-layer within the generated validation methods, but sometimes this is not sufficient.\nThere may be a need to inspect the request details immediately once the request has been passed to the controller. There may be a need to perform crucial validations of the request-body in the controller layer prior to calling the model-layer (i.e. in advance of the validator). There may be a need to influence the value of an entity\u0026rsquo;s fields prior to returning the read or created entity back to the caller. For reasons such as these, so-called \u0026lsquo;extension-points\u0026rsquo; have been embedded in the model and controller layers of the code.\nEach extension-point offers the developer the ability to code their own method in a regeneration protected code-body in order to perform checks or data manipulations Consider that regeneration of an application will overwrite the current controller and model files if the same target destination is used. If an application developer were to extend the controller or model directly in the generated code, their additions would be lost if the application were to be regenerated. By introducing the extension-point concept and separating the related code from the generated code the application developers enhancements are protected from being over-written by an inadvertent application regeneration.\nFirstApp ├── appobj │ ├── appconf.go │ └── appobj.go ├── controllers │ ├── authc.go │ ├── controllerfuncs.go │ ├── groupauthc.go │ ├── person_relationsc.go │ ├── personc.go │ ├── usrc.go │ ├── usr_groupc.go │ └── ext │ ├── extc_interfaces.go │ └── personc_ext.go . . . ├── models │ ├── authm.go │ ├── errors.go │ ├── group_authm.go │ ├── modelfuncs.go │ ├── personm_ext.go │ ├── personm.go │ ├── servicesm.go │ ├── usr_groupm.go │ ├── usrm.go │ └── ext │ └── model_ext_interfaces.go ├── util │ └── strings.go ├── .dev.config.json ├── .prd.config.json ├── main_test.go └── main.go  Extension-points are declared in the generated codebase as a specific set of controller and model interfaces. The interface declarations are contained in the ext sub-folders of the model and controller folders. The ext sub-folders also contain sample (empty) implementations of the interfaces are provided for each modeled entity.\nThe extension-point interfaces rely on the use of the empty interface{} in order to facilitate the passing of a pointer to the data structure being inspected/updated. Use of interface{} allows us to embrace the concept of a general extension-point API at the cost of strict typing. Additionally, the implementer must make use of reflection in order to assign a type to the value of the interface{} underlying data structure. As of this writing, the use of interface{} and reflection is the best way to implement a general extension-point API with golang.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/generation/gn-content-a/",
	"title": "Generation Overview",
	"tags": [],
	"description": "",
	"content": " Jiffy Application File Structure Running the Jiffy generator creates a set of files that comprise a basic working backend services application. Jiffy generates the following source code when provided with a model-file describing a simple \u0026lsquo;Person\u0026rsquo; entity. The structure and files look more or less standard if you are used to looking at such things. Explanations of each folder and its content are discussed throughout the documentation.\nFirstApp ├── appobj │ ├── appconf.go │ └── appobj.go ├── controllers │ ├── authc.go │ ├── controllerfuncs.go │ ├── groupauthc.go │ ├── person_relationsc.go │ ├── personc.go │ ├── usrc.go │ ├── usr_groupc.go │ └── ext │ ├── extc_interfaces.go │ └── personc_ext.go ├── group │ ├── gmcl │ │ ├── gmclient.go │ ├── gmcom │ │ ├── gmcache.go │ │ ├── gmclsrv.go │ │ ├── gmerrors.go │ │ └── gmomap.go │ └── gmsrv │ ├── gmprocessors.go │ ├── gmprotocol_senders.go │ ├── gmserver.go │ └── gmtxrx.go ├── jwtkeys │ ├── ecdsa256 │ │ ├── ecdsa.priv.pem │ │ └── ecdsa.pub.pem │ ├── ecdsa384 │ │ ├── ecdsa384.prive.pem │ │ └── ecdsa384.pub.pem │ ├── ecdsa521 │ │ ├── ecdsa521.priv.pem │ │ └── ecdsa521.pub.pem │ ├── rsa256 │ │ ├── rsa.priv.pem │ │ └── rsa.pub.pem │ ├── rsa384 │ │ ├── rsa384.prive.pem │ │ └── rsa384.pub.pem │ └── rsa512 │ ├── rsa512.priv.pem │ └── rsa512.pub.pem ├── middleware │ └── requireuser.go ├── models │ ├── authm.go │ ├── errors.go │ ├── group_authm.go │ ├── modelfuncs.go │ ├── personm_ext.go │ ├── personm.go │ ├── servicesm.go │ ├── usr_groupm.go │ ├── usrm.go │ └── ext │ └── model_ext_interfaces.go ├── util │ └── strings.go ├── .dev.config.json ├── .prd.config.json ├── main_test.go └── main.go  Basic Application Flow Incoming requests are handled by a mux, which validates / authenticates the request, and then matches it to a route. The selected route passes the request to a controller specific to the entity-type, where the incoming information is mapped into a go struct matching the entity declaration. The controller then calls the appropriate model function for the http operation and entity-type combination, passing it the entity structure. The model handler passes the entity struct through a member-field validation layer, and then to the model\u0026rsquo;s interface to the underlying sqac ORM. The database request is handled by the ORM, and then the response is passed from the model back to the controller where it is packaged as a JSON payload and sent back to the caller in the response-writer\u0026rsquo;s body.\nJiffy applications contain an embedded leader-based group-membership sub-system that is used for interprocess communication when the generated jiffy application is deployed as multiple processes.\n When a jiffy application is deployed as more than one process, there is a need for changes to users, auths, groups and group/auth associations to be communicated to all running instances. These common application entities are cached locally on each running instance in order to avoid accessing the database unnecessarily An internal subsystem was chosen in order to avoid dependencies on external solutions like redis/memcached etc. Given that there is interprocess communication for the cache updates, the status of the group members must be tracked. The subsystem uses a SWIM (Scalable Weakly-Consistent Infection-Style Process-Membership) protocol to check and disseminate the statues of the group\u0026rsquo;s processes. A ping is sent from each process to every other known process in the group in random order once per ping-cycle. The ping message contains a piggybacked process-map containing the pinging process\u0026rsquo;s view of the world in terms of process status. Processes may have one of the following three statuses (ALIVE, SUSPECT, FAILED), as well as a status count indicating how many times the pinging process has noted that a process is in a particular state.  See the Group Membership section of this document for a detailed overview of the group-membership subsystem.\nThere are more elegant ways to express certain aspects of the generated application. The coding style has been deliberately kept as simple and straight-forward as possible in order to facilitate easier understanding and adjustment of the generated code.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/models/mo-content-a/",
	"title": "Model Overview",
	"tags": [],
	"description": "",
	"content": " Model Files Model files contain the Entity, Index and Relation definitions that you wish to generate services for. Entity model definition consists of an array of JSON objects, with each object being limited to a flat hierarchy and basic go-data-types, (although this is easily extended). By default, the Jiffy generator expects a models.json file in the execution directory, but a correctly formatted JSON file can be loaded from any location by executing with the -m flag.\nIt is possible to use more than one model-file, as long as there is no duplication of entity definitions across files. Model files may be loaded in any order, but the complete set of files must be loaded at the same time. As an example, it would be fine to create three model files; Library.json, Book.json, LibraryCard.json, but all three files should be complete and processed at the same time via the -mf flag in order to allow the correct generation of relationships etc.\nSample models.json files are installed with the application and can be found in the support/testing_models folder of the Jiffy source tree. The sample models are used as the basis for the following sections.\nSimple Single Entity Model The following JSON illustrates the definition of a simple single-entity model file. In this case, a model entity called \u0026lsquo;Person\u0026rsquo; will be created in the generated application, along with corresponding database table \u0026lsquo;person\u0026rsquo;. Table \u0026lsquo;person\u0026rsquo; will be created (if it does not already exist) when the application is started for the first time. See the application startup sequence section of this document for details regarding database artifact creation and updates.\n{ \u0026quot;entities\u0026quot;: [ { \u0026quot;typeName\u0026quot;: \u0026quot;Person\u0026quot;, \u0026quot;id_properties\u0026quot;: { \u0026quot;start\u0026quot;: 10000000 }, \u0026quot;properties\u0026quot;: { \u0026quot;name\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;db_type\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;no_db\u0026quot;: false, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: false, \u0026quot;unique\u0026quot;: false, \u0026quot;index\u0026quot;: \u0026quot;nonUnique\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,like\u0026quot; }, \u0026quot;age\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;uint\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: false, \u0026quot;unique\u0026quot;: false, \u0026quot;index\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,lt,gt\u0026quot; }, \u0026quot;weight\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;float64\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: false, \u0026quot;unique\u0026quot;: false, \u0026quot;index\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,lt,le,gt,ge\u0026quot; }, \u0026quot;validLicense\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;bool\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: false, \u0026quot;unique\u0026quot;: false, \u0026quot;index\u0026quot;: \u0026quot;nonUnique\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,ne\u0026quot; } } } ] }  The simpleSingleEntityModel.json file structure and content is explained below:\n{ \u0026quot;entities\u0026quot;: [ The 'entities' block contains an array of entities belonging to the application model. Each entity relates directly to a database table (or view). Entities contain information that the application generator uses to create and update database artifacts such as tables, indexes, sequences and foreign-keys, as well as information informing the application runtime of the member field properties. This is a mandatory model element. { \u0026quot;typeName\u0026quot;: \u0026quot;Person\u0026quot; Field 'typeName' refers to the name of an entity. It should be capitalized and written in CamelCase. An Entity given a typeName of \u0026quot;Person\u0026quot; will result in an internal model object of type Person and a database table called 'person'. This is a mandatory model element. \u0026quot;id_properties\u0026quot;: { The 'id_properties' block contains a single entry for now, and is used to provide guidance to the application generator regarding the setup of the entity's ID field. This is an optional model element. \u0026quot;start\u0026quot;: 10000000, Field 'start' can be used to provide a starting point for an entity's ID field. This is a mandatory model element if the 'id_properties' block has been included in the model. }, \u0026quot;properties\u0026quot;: { The 'properties' block contains 1:n entity member field definitions. Member fields should be defined in camelCase and can start with a lower or upper-case character. In the context of the \u0026quot;entity\u0026quot; with a 'typeName' of 'Person', 'properties' refer to the data fields of the generated \u0026quot;Person\u0026quot; model structure. 'properties' are a collection of free-form name-tags, each with a child-block containing the 'property' attributes. This is a mandatory model element. The \u0026quot;name\u0026quot; property block is described below: \u0026quot;name\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, Field 'type' in a 'properties'-\u0026gt;'name' JSON-block refers to the go data-type associated with the current 'property'. 'type' is a mandatory field in an \u0026quot;entity\u0026quot; 'property' block. \u0026quot;dbtype\u0026quot;: \u0026quot;varchar(100)\u0026quot;, Field 'dbtype' can be used to specify a native db-field-type for the property. This feature can be useful if for example, the developer is confident that a string will never exceed 100 characters in length. Care should be taken to ensure that the specified DB-Type is consistent with the go-type that will be generated in the model.\u0026lt;Entity\u0026gt; defintion in the application. Consider also that making use of this field to some extent limits the backend portability of the generated code. For example, not all database systems have a TINYINT data-type, so specifying a 'db_type' of TINYINT could be problematic if multiple database systems are being used for testing. This is an optional field. \u0026quot;no_db\u0026quot;: Field 'no_db' can be used to instruct the generator to create the field as a member in the enitity struture, but to prevent the field from being persisted to the backend database. Data like passwords for example should never be persisted to the database, but it handy to have in the user entitiy definition to help with the login process. Non-persisted fields are not created in the database table schemas, and values passed into the application are wiped from their respective internal structures following use. \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, Field 'format' is not currently used, but is intended to deal with field conversion from strings / floats to timestamp formats etc. This is an optional field. \u0026quot;required\u0026quot;: false, Field 'required' is used to instruct the generator to set a 'NOT NULL' database constraint on the column related to the property. Allowed values include {true, false}. This is a mandatory field. \u0026quot;unique\u0026quot;: false, Field 'unique' is used to instruct the database not to accept duplicate values in the database column related to the property. Setting this field to true will cause a 'UNIQUE' constraint to be applied to the related database column. Allowed values include {true, false}. This is a mandatory field. \u0026quot;index\u0026quot;: \u0026quot;nonUnique\u0026quot;, Field 'index' is used to instruct the database to create an index on the db table-column related to the property. See the 'indexes' element in the type definition for the creation of compound indices. Allowed values include {\u0026quot;unique\u0026quot;, \u0026quot;nonUnique\u0026quot;, \u0026quot;\u0026quot;}. This is an optional field. \u0026quot;selectable\u0026quot;: \u0026quot;eq,like\u0026quot; Field 'selectable' can be used to instruct the code-generator to create simple REST query accessor routes for the current 'property'. The generator creates routes to permit GET operations that can be called based on the entity 'typeName' and 'property' values. Allowed values include {\u0026quot;EQ\u0026quot;, \u0026quot;eq\u0026quot;, \u0026quot;LT\u0026quot;, \u0026quot;lt\u0026quot;, \u0026quot;GT\u0026quot;, \u0026quot;gt\u0026quot;, \u0026quot;GE\u0026quot;, \u0026quot;ge\u0026quot;, \u0026quot;LIKE\u0026quot;, \u0026quot;like\u0026quot;, \u0026quot;NE\u0026quot;, \u0026quot;ne\u0026quot;, \u0026quot;\u0026quot;} Additional restrictions are imposed based on the 'type' field value. For example, a bool type need not support LT or GT operators. Sample routes for Person-\u0026gt;Name selection with \u0026quot;eq,like\u0026quot; are shown: https://localhost:\u0026lt;port\u0026gt;/persons/name(EQ '\u0026lt;sel_string\u0026gt;') https://localhost:\u0026lt;port\u0026gt;/persons/name(LIKE '\u0026lt;sel_string\u0026gt;') Note that this is not the same thing as filtering insofar as setting the selectable options results in the creation of parameterized static routes in the application mux. }, \u0026quot;age\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;uint\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: false, \u0026quot;unique\u0026quot;: false, \u0026quot;index\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,lt,le,gt,ge,ne\u0026quot; }, ... ... }, } }, { ... next entity definition } ] }  Entity ID The ID field is visibly absent from the preceding entity declarations. The original intent was to support any name for the primary key / resource identifier of an entity. While it is possible to do this, it seems that ID is the universal \u0026lsquo;non-standard\u0026rsquo; way of representing object identifiers in RESTful-type services, so we went with it. As a result, ID is injected into the model definition of every entity as a uint64 field and is marked as the primary-key in the database backend. By default, the ID is created as an auto-incrementing column in the DBMS, but this functionality can be suppressed (future). The ability to allow a specific starting point for the ID key range is supported via the entity header-level \u0026ldquo;start\u0026rdquo; value.\nIf the ID field really needs to be known as CustomerNumber for example, the generated code can be edited in a few locations to support the change. It is worth mentioning that the number of edits required to rename \u0026lsquo;ID\u0026rsquo; increases in direct relation to the number and complexity of entity relations (both to and from).\nAs an alternative to renaming ID, it is also conceivable that it can be ignored. Ignoring the ID means that the generated CRUD controller/model/routes are not as useful as they could be, but they offer a great starting point for your own coding. Entities can be defined with column constraints that mimic those of DBMS primary / complex keys, then the generated CRUD artifacts based on ID can be ignored, copied then ignored, or modified to accommodate the modeled entities.\nIt is also possible to go completely custom and write your own models and controllers from scratch using a generated model as a reference template. In addition to exposing a generic internal CRUD interface to the backend, the more interesting go/sql calls are exposed internally along with some lightly wrapped and super useful calls from jmoirons widely used sqlx package.\nhttps://github.com/jmoiron/sqlx\nhttp://jmoiron.github.io/sqlx/\nAlthough Jiffy eschews non-standard lib packages wherever possible, sqlx is really great.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/execution/ex-content-a/",
	"title": "Running Jiffy",
	"tags": [],
	"description": "",
	"content": " Execution In order to run the application generator, ensure the following:\n Make sure go has been installed in the test environment. See http://www.golang.org for installation files and instructions.\n Make sure that the Jiffy source code and dependencies have been installed: Jiffy Installation\n You will need access to a Postgres, MySQL, MSSQL or SAP Hana database, either locally or over the network. It is also possible to run tests with SQLite3.\n Jiffy can be started in two ways:\n From $GOPATH/src/github.com/1414C/jiffy you may execute the application directly from the Jiffy source code as follows.   $ go run main.go   A binary can also be built from $GOPATH/src/github.com/1414C/jiffy by typing the following.  $ cd $GOPATH/src/github.com/1414C/jiffy $ go build . $ ./jiffy   "
},
{
	"uri": "https://1414c.github.io/jiffy/installation/in-content-a/",
	"title": "Jiffy Dependencies",
	"tags": [],
	"description": "",
	"content": " What does Jiffy need to run? Wherever possible and reasonable, Jiffy relies on packages found in the Go standard library. As of this writing, Go version 1.10 is required in order to build the Jiffy binary.\nDatabase Drivers The following golang database drivers are required, even if you are only planning to make use of one of the DBMS\u0026rsquo;s in the supported list. This is due to the fact that Jiffy attempts to connect to your test database during the code generation process and there is no guarantee what that database may be. It is possible that a developer tests with SQLite locally when generating the code and performing initial tests, but intends to ultimately connect to Postgres.\n github.com/SAP/go-hdb/driver github.com/denisenkom/go-mssqldb github.com/go-sql-driver/mysql github.com/lib/pq github.com/mattn/go-sqlite3  The database drivers need to be pulled down from their respective repositories via the go get command. The latest version of each should be fine.\ngo get -u github.com/lib/pq  Sqac ORM Jiffy also requires the sqac ORM. This should be pulled down automatically during the Jiffy installation process, but can also be manually installed using go get as shown below.\ngo get -u github.com/1414C/sqac  See the sqac ORM README.md file for verification and testing instructions.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/overview/ov-content-a/",
	"title": "What is Jiffy?",
	"tags": [],
	"description": "",
	"content": " What does Jiffy do? Jiffy is a model-based RESTful application services generator written in go. Think of Jiffy as an accelerator. Jiffy generates a complete backend services application for you, and that generated application is what you will run in production.\nJiffy allows a developer to generate a robust go-based application that treats the data persistence layer in a generic manner. This allows the generated application to connect to number of different database systems (outlined below), without any code changes. Generated applications can be targeted at SAP Hana; Postgres, MySQL, MSSQL or SQLite simply by updating one configuration file.\nWhy write in Go?  Go has a good standard library, thereby keeping dependencies on public packages to a minimum Go offers concurrency via lightweight threads known as go-routines  no blocking in the i/o layer during compute intensive tasks no lost callbacks or broken promises go-routines will use all available cores to handle incoming requests  Go offers type-safety Go is a small language Go projects compile to a static single binary which simplifies deployments Go cross-compiles to virtually any platform and architecture; write and test on a Chromebook - deploy to amd64/ppc64/arm64/s390  What does a Jiffy application provide? Jiffy consumes simple JSON model-files and uses them to generate a working, secure and extensible application server codebase. Generated applications need no additional coding to run, although it would probably be a good idea to implement some validations and do a bit of testing before you roll things out.\nHere are some of the features that are automatically included in a generated Jiffy application:\n generated applications can be connected to Postgres, MSSQL, SAP Hana, SQLite or MariaDB no database specific code is compiled into the binary; an app can be pointed from SQLite to SAP Hana with no code changes login / authorization management via JWT built-in support for the creation of signing-keys for JWT (RS256, RS384, RS512, ES256, ES384, ES521) supports JWT\u0026rsquo;s created by other IDP\u0026rsquo;s (RS256, RS384, RS512, ES256, ES384, ES521) bcrypt salt/pepper based authentication scheme where passwords are never stored in the db JSON configuration (model) file(s) for Entity, Index, Foreign-Key and Relationship definitions models support persistent and non-persistent fields generated apps create and alter database artifacts based on the model file (tables, indices, sequences etc.) supports single and composite index declarations via the model file built-in support for https built-in normalization and validation in the model-layer each entity\u0026rsquo;s corresponding service can be enabled and disabled on a per-app-server basis based on config generates a working set of CRUD-type RESTful services for each entity in the model file get-set type end-points support /$count, $limit=n, $offset=n, $orderby=field_name ($asc|$desc) supports and generates working end-points for hasOne, hasMany and belongsTo entity relationships generates static query end-points end-points are secured by way of scope inspection (JWT claims) in the route handler middleware end-point security is generated by default via a auths -\u0026gt; auth-groups -\u0026gt; user arrangement generates a comprehensive set of working tests (go test) generated code is easily extended either via direct editing, or through an extension-point concept in the model and controller-layers a leader-election-based group-membership service exists between running instances of the application to facilitate internal caching of user information  How does Jiffy interface to the underlying database? Jiffy sits on top of a thin ORM that was written to talk to the SAP Hana in-memory db and then extended to the other supported DBMS systems. The ORM code is very simple and can easily be extended to accommodate databases that have not been mentioned here. Bear in mind that the generated queries are designed to accommodate the lowest-common-denominator-type CRUD access. It is expected that a serious deployment will involve extending the generated codebase to optimize access in certain scenarios.\nORM\u0026rsquo;s sound like a bad idea to a lot of people. In practice however, as soon as you want to support more than one type of backend DBMS, a level of abstraction (like a thin ORM) starts to look a bit more appealing. However\u0026hellip;\nIf you look at the generated code and don\u0026rsquo;t like what you see, the ORM handle exposes the standard go/sql and the awesome jmoiron/sqlx libraries to you directly. This will effectively allow you to make use of the generated application, but code the SQL against the database yourself.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/accesscontrol/ac-content-a/",
	"title": "Access Control Overview",
	"tags": [],
	"description": "",
	"content": " Overview Access to application resources (entities) is controlled in four ways:\n Configuration based service activation Secure user authentication Authorization checks via JWT token claim inspection embedded as middleware in the protected route declarations (end-points) Usr/Auth/Group/GroupAuth caches are maintained on each group-member and updated via an internal API and dissemination protocol in the group-membership service  Configuration Based Service Activation An internal service is created for each of the modeled entities in the application. Services can be marked as active or inactive in the service configuration, thereby allowing a single application to be generated, but also allowing selective service deployment. For example, there may be cases where it is desirable to route certain services to a particular application instance and another set of services to the rest of the pool. In such a case, a reverse-proxy could be configured to route the end-points appropriately, and the deployed service configurations would be adjusted accordingly.\nSecure User Authentication User authentication is conducted using bcrypt in such a manner that passwords are never stored in the application database. When a user is created, their user-id is stored in the backend database along with the salt/peppered bcrypt hash of their password. This ensures that in the event of a breach no plain-text passwords can be obtained.\nBcrypt was chosen for the following reasons:\n bcrypt hashes are salt/peppered to mitigate rainbow table attacks bcrypt is slow by design, making brute force reversal a time-consuming and expensive proposition as increased computing power becomes available, the bcrypt cost parameter can be increased (current = 14) the password hash itself is not used for authentication; it is the by-product of successful authentication  When a user logs into the application the following steps occur:\n a lookup of the user-name and stored bcrypt hash is executed against the back-end db the user provided password is hashed in memory using the Go standard lib bcrypt functions and the protected salt/pepper values the computed bcrypt hash is compared to the stored hash value for the user if the hash values match, a JWT (token) is created and signed using ECDSA-256 (adjustable to ECDSA-384, ECDSA-521, RSA-256, RSA-384, RSA-512) the JWT is passed back to the caller and must henceforth be included in the http header of all requests using the Authorization field the user\u0026rsquo;s access credentials are updated in the servicing group-member\u0026rsquo;s cache the user\u0026rsquo;s access credentials are passed via the cache subsystem to all other group-members  In addition to fulfilling the authorization requirements, the JWT is also used as a CSRF equivalent. By default the generated JWT has a validity of one-hour, but this may be adjusted via the application configuration file. See the Authorization and End-Point Security section for more details regarding the content and use of the JWT content/claims.\nAuthorizations \u0026amp; End-Point Security In addition to password authentication, generated applications provide the ability to manage access to their end-points via an authorization scheme. At a high-level:\n An Authorization is generated and linked to each end-point Authorizations are assigned to User Groups User Groups are allocated to Users via a Groups field in the Usr master  -\u0026gt; User | --\u0026gt; Group 1 | | | --\u0026gt; Auth_EndPoint_A | --\u0026gt; Auth_EndPoint_B | --\u0026gt; Auth_EndPoint_C | --\u0026gt; Group 2 | --\u0026gt; Auth_EndPoint_K --\u0026gt; Auth_EndPoint_M  Authorizations Application access can be restricted at the end-point level. Each generated end-point is given a name based on its entity, http method and purpose. The gorilla mux provides an easy way to assign names to end-points in a route declaration, and these names are defined in the generated application as Authorizations or Auths.\nAuthorizations are created per end-point and are therefore known to the router, which in turn allows the route middleware of the generated application to determine which Authorization is needed in order to permit the request to proceed. Recall that an authenticated user is sent a signed base64-encoded JWT token that must be passed in the http header Authorization field of each request. The generated router middleware validates the signature, decodes the token, and then examines its Claims in order to determine whether the request should be allowed to proceed. This level of checking can be thought of as the Authentication verification; does the requesting party have a valid access token for the system in general?\nAssuming that the requesting user has a valid access token, the next step is to determine whether the user has permission to access the requested end-point. Each User is assigned to one or more User Groups and these are included as a Groups Claim in the JWT token when the User logs into the application. As a result, the route middleware is able to examine the content of the Groups Claim in order to determine whether the User is permitted to access the requested end-point. The route authorization check unfolds as follows:\n Verify the requesting user has a valid access token (JWT); can the signature be verified? Is the JWT still valid? Read the Groups Claim from the JWT token Determine the \u0026lsquo;Name\u0026rsquo; (Authorization) of the current route Examine the authorization cache for each Group the User has been assigned to If the required Authorization is found in any of the User Groups that the User has been assigned to, the request is allowed to proceed  The last bullet point is interesting, as it means that end-point access of protected routes is denied by default. Unless access is specifically granted via Authorization -\u0026gt; User Group -\u0026gt; User assignment, the protected end-point is not accessible.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/interprocess/ip-content-a/",
	"title": "Group Membership Overview",
	"tags": [],
	"description": "",
	"content": " Overview  Jiffy-generated applications can be deployed as single or multiple instances. When running multiple instances of a Jiffy-generated application, a group-membership service establishes connectivity between all running instances. An application instance knows to start its group-membership service if the -gm flag is provided during startup. Each application instance running the group-membership service can be thought of as a process. At any point in time, the group has an elected leader. The group-leader information must be made available via an external persistent store. An interface is provided (gmcom.GMLeaderSetterGetter) in order to support the passing of implementation-specific persistent store accessors to a starting process. This allows the implementer to store the persisted leader information in any accessible medium (ie. redis, db, flat-file etc.) Jiffy ships with a sample implementation of gmcom.GMLeaderSetterGetter that facilitates the use of a simple web-sockets-based key-store application (see github.com/1414C/sluggo). Each process has a uint id (PID) that is assigned by the group-leader upon joining the group. Processes join the group by querying the well-known persistent store to obtain the current group-leader information. Once the group-leader is known, the joining instance contacts the leader\u0026rsquo;s address:port and sends a JOIN message. The leader will allocate a new PID for the joining process and send an ACK message in response. The joining process set it\u0026rsquo;s PID based on the PID contained in the ACK message. Processes can join and drop out of the group without any changes to the configuration. Group-membership is managed dynamically via inter-process messaging between group-members. Each process knows the PID and maintains a local status of every other process in the group. Each process maintains a status-count for every other process in the group.  "
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/gs-content-c/",
	"title": "Let&#39;s Build Something",
	"tags": [],
	"description": "",
	"content": "Now that Jiffy is installed, we will build a simple service to test it out.\nJiffy\u0026rsquo;s source tree comes with a number of sample model files that you can use to get the hang of things. We are going to use a simple model file that contains an entity named \u0026lsquo;Person\u0026rsquo;. The model file can be found in the Jiffy source tree, or pulled directly from the Jiffy github repository.\n $GOPATH/src/github.com/1414C/jiffy/support/testing_models/simpleSingleEntityModel.json jiffy repository  For now we are not going to worry about the content of the model file, but we will look at the structure of our new \u0026lsquo;Person\u0026rsquo; entity briefly.\n// Person structure type Person struct { ID uint64 `json:\u0026quot;id\u0026quot; sqac:\u0026quot;primary_key:inc;start:10000000\u0026quot;` Href string `json:\u0026quot;href\u0026quot; sqac:\u0026quot;-\u0026quot;` Name *string `json:\u0026quot;name,omitempty\u0026quot; sqac:\u0026quot;nullable:true;index:non-unique\u0026quot;` Age *uint `json:\u0026quot;age,omitempty\u0026quot; sqac:\u0026quot;nullable:true\u0026quot;` Weight *float64 `json:\u0026quot;weight,omitempty\u0026quot; sqac:\u0026quot;nullable:true\u0026quot;` ValidLicense *bool `json:\u0026quot;valid_license,omitempty\u0026quot; sqac:\u0026quot;nullable:true;index:non-unique\u0026quot;` }  We can see that jiffy will create a Person model with a small set of fields, each with a number of attributes. For the moment, we will concern ourselves only with the field names and types, as we will need to use this information to construct some tests for the new service.\n\u0026lsquo;sqac\u0026rsquo; tags are used to pass information to jiffy\u0026rsquo;s ORM layer.\n \nCreate a new target directory for your project under $GOPATH/src.\n$ cd $GOPATH/src $ mkdir jiffy_tests  \nExecute the jiffy binary, specifying the model file to use, as well as the target directory/project name.\n$ jiffy -m $GOPATH/src/github.com/1414C/jiffy/support/testing_models/simpleSingleEntityModel.json -p /jiffy_tests/first_app  -m tells jiffy which model file should be used to construct the new service.\n-p tells jiffy where to write the generated application code.\nNote that the location of the folder specified by the -p flag is deemed to be relative to $GOPATH/src.\n \nIf everything has gone according to plan, a new application has been generated and should be ready to run. Let\u0026rsquo;s take a look at what jiffy generated for us!\n$ cd $GOPATH/src/jiffy_tests/first_app $ ls -l  This should result in a list of the files and folders comprising our new application.\ndrwxr-xr-x 12 stevem staff 384 5 Feb 21:44 . drwxr-xr-x 10 stevem staff 320 5 Feb 21:44 .. -rwxr-xr-x 1 stevem staff 588 5 Feb 21:44 .dev.config.json -rwxr-xr-x 1 stevem staff 611 5 Feb 21:44 .prd.config.json drwxr-xr-x 4 stevem staff 128 5 Feb 21:44 appobj drwxr-xr-x 10 stevem staff 320 5 Feb 21:44 controllers drwxr-xr-x 4 stevem staff 128 5 Feb 21:44 jwtkeys -rwxr-xr-x 1 stevem staff 839 5 Feb 21:44 main.go -rwxr-xr-x 1 stevem staff 18421 5 Feb 21:44 main_test.go drwxr-xr-x 3 stevem staff 96 5 Feb 21:44 middleware drwxr-xr-x 12 stevem staff 384 5 Feb 21:44 models drwxr-xr-x 3 stevem staff 96 5 Feb 21:44 util $  Jiffy generates two sample configuration files each time it is executed. We are going to run our application with development environment settings, so lets take a quick look at .dev.config.json to make sure there are no horrible surprises.\n{ \u0026quot;port\u0026quot;: 8080, \u0026quot;env\u0026quot;: \u0026quot;dev\u0026quot;, \u0026quot;pepper\u0026quot;: \u0026quot;secret-pepper-key\u0026quot;, \u0026quot;database\u0026quot;: { \u0026quot;db_dialect\u0026quot;: \u0026quot;sqlite\u0026quot;, \u0026quot;host\u0026quot;: \u0026quot;127.0.0.1\u0026quot;, \u0026quot;port\u0026quot;: 0, \u0026quot;usr\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;password\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;testdb.sqlite\u0026quot; }, \u0026quot;cert_file\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;key_file\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;jwt_priv_key_file\u0026quot;: \u0026quot;jwtkeys/private.pem\u0026quot;, \u0026quot;jwt_pub_key_file\u0026quot;: \u0026quot;jwtkeys/public.pem\u0026quot;, \u0026quot;service_activations\u0026quot;: [ { \u0026quot;service_name\u0026quot;: \u0026quot;Person\u0026quot;, \u0026quot;service_active\u0026quot;: true } ] }  Jiffy decides by default to run against a sqlite database and generates what should be a suitable configuration file for most systems. Again, we are not going to worry too much about what is in the configuration file at this point, but know that database file \u0026lsquo;testdb.sqlite\u0026rsquo; will be created in the generated application\u0026rsquo;s root folder.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/extensionpoints/ep-content-b/",
	"title": "Controller Extension Points",
	"tags": [],
	"description": "",
	"content": " Overview Controller extension-points exist for the Create, Update and Get CRUD operations. Each operation has a related extension-point interface, for which an empty implementation is created when the application is generated. If the generator sees that the extension-point implementation file for an entity has already been created, it will not over-write or create a new version.\nFile ./myapp/controllers/ext/extc_interfaces.go contains the generated entity controller extension-point interface declarations. Each interface and interface method is documented in this file.\nFile ./myapp/controllers/ext/\u0026lt;entity_name\u0026gt;c_ext.go is generated for each entity with empty extension-point interface implementations. This file may be edited by the application developer to add custom application logic.\nController Extension-Point Interfaces  Interface ControllerCreateExt   BeforeFirst(w http.ResponseWriter, r *http.Request) error BeforeFirst is an extension-point that can be implemented in order to examine and potentially reject a Create entity request. This extension-point is the first code executed in the controller's Create method. Authentication and Authorization checks should be performed upstream in the route middleware-layer and detailed checks of a request.Body should be carried out by the validator in the model-layer.    AfterBodyDecode(ent interface{}) error AfterBodyDecode is an extension-point that can be implemented to perform preliminary checks and changes to the unmarshalled content of the request.Body. Detailed checks of the unmarshalled data from the request.Body should be carried out by the validator in the model-layer. This extension-point should only be used to carry out deal-breaker checks and perhaps to default data in the entity struct prior to calling the validator/normalization methods in the model-layer.    BeforeResponse(ent interface{}) error BeforeResponse is an extension-point that can be implemented to perform checks following the return of the call to the model-layer. At this point, changes to the db will have been made, so failing the call should take this into consideration.     Interface ControllerUpdateExt   BeforeFirst(w http.ResponseWriter, r *http.Request) error BeforeFirst is an extension-point that can be implemented in order to examine and potentially reject an Update entity request. This extension-point is the first code executed in the controller's Update method. Authentication and Authorization checks should be performed upstream in the route middleware-layer and detailed checks of a request.Body should be carried out by the validator in the model-layer.    AfterBodyDecode(ent interface{}) error AfterBodyDecode is an extension-point that can be implemented to perform preliminary checks and changes to the unmarshalled content of the request.Body. Detailed checks of the unmarshalled data from the request.Body should be carried out by the validator in the model-layer. This extension-point should only be used to carry out deal-breaker checks and perhaps to default data in the entity struct prior to calling the validator/normalization methods in the model-layer.    BeforeResponse(ent interface{}) error BeforeResponse is an extension-point that can be implemented to perform checks following the return of the call to the model-layer. At this point, changes to the db will have been made, so failing the call should take this into consideration.     Interface ControllerGetExt   BeforeFirst(w http.ResponseWriter, r *http.Request) error BeforeFirst is an extension-point that can be implemented in order to examine and potentially reject a Get entity request. This extension-point is the first code executed in the controller's Create method. Authentication and Authorization checks should be performed upstream in the route middleware-layer.    BeforeModelCall(ent interface{}) error BeforeModelCall is an extension-point that can be implemented in order to make changes to the content of the entity structure prior to calling the model-layer. By default the controller's Get method will populate the ID field of the entity structure using the :id value provided in the request URL. The use of this extension-point would be seemingly rare and any values added to the struct would be over-written in the model-layer when the call to the DBMS is made. The added values would however be available for use in the validation/normalization and DBMS access methods prior to the call to the ORM.    BeforeResponse(ent interface{}) error BeforeResponse is an extension-point that can be implemented to perform checks / changes following the return of the call to the model-layer. At this point, the db has been read and the populated entity structure is about to be marshaled into JSON and passed back to the router/mux.    "
},
{
	"uri": "https://1414c.github.io/jiffy/generation/gn-content-b/",
	"title": "Generated &#39;application&#39; Folder",
	"tags": [],
	"description": "",
	"content": "Following the execution of the application generator, a folder containing the generated app\u0026rsquo;s files is created as shown. The application folder follows the name provided via the -p Jiffy execution flag. In this case, the name of the application folder is \u0026lsquo;FirstApp\u0026rsquo;.\nFirstApp ├── appobj │ ├── appconf.go │ └── appobj.go ├── controllers │ ├── ... │ ├── ... . . . ├── .dev.config.json ├── .prd.config.json ├── main_test.go └── main.go  "
},
{
	"uri": "https://1414c.github.io/jiffy/models/mo-content-b/",
	"title": "Simple Two Entity Model",
	"tags": [],
	"description": "",
	"content": " Two Entity Model The following JSON illustrates the definition of a simple two-entity model file. In this case, model entities \u0026lsquo;Person\u0026rsquo; and \u0026lsquo;Country\u0026rsquo; will be created in the generated application, along with corresponding database tables \u0026lsquo;person\u0026rsquo; and \u0026lsquo;country\u0026rsquo;. No relationships have been defined between the two entities; this example simply illustrates how to add multiple entity definitions to a model file.\nsimpleTwoEntityModel.json\n{ \u0026quot;entities\u0026quot;: [ { \u0026quot;typeName\u0026quot;: \u0026quot;Person\u0026quot;, \u0026quot;properties\u0026quot;: { \u0026quot;name\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: false, \u0026quot;unique\u0026quot;: false, \u0026quot;index\u0026quot;: \u0026quot;nonUnique\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,like\u0026quot; }, \u0026quot;age\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;uint\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: false, \u0026quot;unique\u0026quot;: false, \u0026quot;index\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,lt,gt\u0026quot; }, \u0026quot;weight\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;float64\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: false, \u0026quot;unique\u0026quot;: false, \u0026quot;index\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,lt,le,gt,ge\u0026quot; }, \u0026quot;validLicense\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;bool\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: false, \u0026quot;unique\u0026quot;: false, \u0026quot;index\u0026quot;: \u0026quot;nonUnique\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,ne\u0026quot; } } }, { \u0026quot;typeName\u0026quot;: \u0026quot;Country\u0026quot;, \u0026quot;properties\u0026quot;: { \u0026quot;name\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: false, \u0026quot;unique\u0026quot;: false, \u0026quot;index\u0026quot;: \u0026quot;nonUnique\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,like\u0026quot; }, \u0026quot;isoCode\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;uint\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: false, \u0026quot;unique\u0026quot;: false, \u0026quot;index\u0026quot;: \u0026quot;unique\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,lt,gt\u0026quot; } } } ] }  simpleTwoEntityModel.json\n"
},
{
	"uri": "https://1414c.github.io/jiffy/execution/ex-content-b/",
	"title": "Jiffy Execution Flags",
	"tags": [],
	"description": "",
	"content": " Generation Flags Flags are kept to a minimum, but there are a few flags that can be appended to the execution command:\n go run *.go -p   The -p switch is used to specify the target directory for generated application source-code relative to $GOPATH/src.   $ go run main.go -p \u0026quot;github.com/footle.com/myrestfulsvc\u0026quot;   go run main.go -m .json  By default, the application will attempt to use ./support/testing_models/models.json as the model source, but inclusion of the -m flag permits the use of an alternate model file. The path of model file in the application base directory must be prefaced with ./ . If the model file is not located in the base directory of the application, the full path must be specified when using the -m flag.   go run main.go -m \u0026quot;./my_model.json\u0026quot;   go run main.go -mf   By default, the application will attempt to use ./support/testing_models/models.json as the model source, but inclusion of the -mf flag instructs the generator to read and process all model files contained in the specified folder. The path of models folder in the application base directory must be prefaced with ./ . If the models folder is not located in the base directory of the application, the full path must be specified when using the -mf flag.   go run main.go -mf \u0026quot;./models_folder\u0026quot;  Typical Use Typically you will want to provide your own model file and direct Jiffy to write the source code for the new application to a non-default destination.\ngo run main.go -m \u0026quot;./my_model.json\u0026quot; -p \u0026quot;github.com/footle.com/myrestfulsvc\u0026quot;  In the case where you have created more than one model file for your application, the -mf flag is used to instruct Jiffy to read all the models in specified location.\ngo run main.go -mf \u0026quot;./models_folder\u0026quot; -p \u0026quot;github.com/footle.com/myrestfulsvc\u0026quot;  "
},
{
	"uri": "https://1414c.github.io/jiffy/installation/in-content-b/",
	"title": "Jiffy Installation",
	"tags": [],
	"description": "",
	"content": " Installation Steps The easiest way to install Jiffy is to use go get on the command-line to pull the latest version from github, as shown below:\n$ go get -u github.com/1414C/jiffy  This will pull the jiffy github repository into your $GOPATH/src/github.com folder, as well as any dependencies referenced by the jiffy source code. The -u flag is included to instruct go get to check for and pull updates to jiffy packages and their dependencies. This is the least sophisticated way of managing dependencies in go.\nOnce the jiffy source code and dependencies have been installed into your $GOPATH, you can use go build to compile a binary from the jiffy sources. The easiest way to do this is to open a terminal window, switch to $GOPATH/src/github.com/1414C/jiffy and run go build as shown below.\n$ go build -v  This will result in the creation of a binary file called \u0026lsquo;jiffy\u0026rsquo;. You may move the \u0026lsquo;jiffy\u0026rsquo; binary anywhere in your $PATH, but convention would have you install it in /usr/local/bin. Once you have moved the \u0026lsquo;jiffy\u0026rsquo; binary to its new home, open a new terminal window and use the which command to ensure that you can access the binary.\n$ which jiffy -a  If which cannot find the jiffy binary (or finds the wrong one!), you need to make sure that your $PATH is set correctly.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/overview/ov-content-b/",
	"title": "Jiffy Application Overview",
	"tags": [],
	"description": "",
	"content": " What does a generated Jiffy application look like? Generated Jiffy applications can be pointed at the DBMS of your choice without the need to recompile the binary (architecture differences not withstanding). This means that a developer can build a model, fully test it locally using SQLite and then redirect the application to a formal testing environment running SAP Hana, or any of the other supported database systems.\nApplications are generated based on model files which are encoded as simple JSON. The concepts of entity and resource-id form the cornerstones upon which the model, application and RESTful end-points are built.\nEntities can be thought of anything that needs to be modeled; Order, Customer, Invoice, Truck, \u0026hellip;, \u0026hellip; Each entity is mandated to have an ID field, which is analogous to a primary-key or row-id in the backend database. ID is used as the primary resource identifier for an entity, and is setup by default as an auto-incrementing column in the database. ID is implemented as go-type uint64 and is inserted into the model entity definition during application generation.\nSimple CRUD Access Accessing an entity via the generated CRUD interface is very simple. For example, a customer entity could be defined in the model and then accessed via the application as follows:\n Create a customer entity:\n https://servername:port/customer + {JSON body}  Update a customer entity:\n https://servername:port/customer/:id + {JSON body}  Read a customer entity:\n https://servername:port/customer/:id  Delete a customer entity:\n https://servername:port/customer/:id  Read all customer entities:\n https://servername:port/customers   Filters and Relationships Additional routes can also be generated based on the model file, including custom filters for GET operations, static end-points for common GET operations, HasOne, HasMany and BelongsTo relationships:\n Use a filter to Get customers where the last name is \u0026lsquo;Smith\u0026rsquo;:\n https://servername:port/customers/?last_name=Smith  Use a generated static end-point to Get customers where credit score is less than 4:\n https://servername:port/customers/credit_score(LT 4)  Use a generated relationship to retrieve all orders for a specific customer (10023):\n https://servername:port/customer/10023/orders  Use a generated relationship to retrieve a specific order (99000022) for the specified customer (10023):\n https://servername:port/customer/10023/order/99000022  Use a generated belongsTo relationship to retrieve the customer for a specific order (990000222):\n https://servername:port/order/99000022/customer   Commands A set of commands can be appended to an operation\u0026rsquo;s URL to perform some common activities. The commands can be appended to the URL in any order.\n Get a count of all customer entities:\n https://servername:port/customer/$count  Limit the number of returned customer entities to 3. The default ordering for this example would be ascending based on the entity ID field.\n https://servername:port/customer/$limit=3  Offset the database selection by 2 records, top-down, using the default order; (ascending based on the entity ID field):\n https://servername:port/customer/$offset=2  Select records in descending order based on the entity ID field:\n https://servername:port/customer/$desc  Select records in descending order using the customer name field as the order-by criteria:\n https://servername:port/customer/$orderby=name$desc  Limit the number of selected records to 3 and select in descending order based on the entity ID field:\n https://servername:port/customer/$limit=3/$desc  Limit the number of selected records to 3 and select in ascending order using the customer name field as the order-by criteria:\n https://servername:port/customer/$limit=3;$orderby=name$asc  Limit the number of selected records to 3 with an offset of 2 and select the records in ascending order using the customer name field as the sort criteria:\n https://servername:port/customer/$limit=3$offset=2$orderby=name$asc  Limit the return of a static filter end-point to 3 records:\n https://servername:port/customers/credit_score(LT4)/$limit=3   More details regarding application modeling are contained in later sections of this documentation.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/accesscontrol/ac-content-b/",
	"title": "Authorizations",
	"tags": [],
	"description": "",
	"content": " Standard CRUD Authorizations As discussed in the Access Control Overview, each of the generated services end-points is assigned a name which is used as an Authorization object by the router middleware.\nStandard CRUD end-points for entity Library are generated as follows:\n// ====================== Library protected routes for standard CRUD access ====================== a.router.HandleFunc(\u0026quot;/librarys\u0026quot;, requireUserMw.ApplyFn(a.libraryC.GetLibrarys)).Methods(\u0026quot;GET\u0026quot;).Name(\u0026quot;library.GET_SET\u0026quot;) a.router.HandleFunc(\u0026quot;/library\u0026quot;, requireUserMw.ApplyFn(a.libraryC.Create)).Methods(\u0026quot;POST\u0026quot;).Name(\u0026quot;library.CREATE\u0026quot;) a.router.HandleFunc(\u0026quot;/library/{id:[0-9]+}\u0026quot;, requireUserMw.ApplyFn(a.libraryC.Get)).Methods(\u0026quot;GET\u0026quot;).Name(\u0026quot;library.GET_ID\u0026quot;) a.router.HandleFunc(\u0026quot;/library/{id:[0-9]+}\u0026quot;, requireUserMw.ApplyFn(a.libraryC.Update)).Methods(\u0026quot;PUT\u0026quot;).Name(\u0026quot;library.UPDATE\u0026quot;) a.router.HandleFunc(\u0026quot;/library/{id:[0-9]+}\u0026quot;, requireUserMw.ApplyFn(a.libraryC.Delete)).Methods(\u0026quot;DELETE\u0026quot;).Name(\u0026quot;library.DELETE\u0026quot;)  Notice that each end-point handler is assigned a name via the gorilla.mux.Route.Name(\u0026ldquo;string\u0026rdquo;) method. The generated end-point names follow the standard shown here, but in practice it is safe to change them to whatever works best for your implementation. Duplicate names in the same router will cause the existing name-route combination to be overwritten by the latest name-route addition as per the gorilla API docs. Avoid the use of duplicate names. The set of generated Authorizations for the Library entities CRUD end-points are:\n library.GET_SET library.CREATE library.GET_ID library.UPDATE library.DELETE  Static Filter Authorizations Static Filter end-points for entity Library follow the same rules as mentioned above and are generated as follows:\n//=================================== Library Static Filters =================================== // http://127.0.0.1:\u0026lt;port\u0026gt;/librarys/name(EQ '\u0026lt;sel_string\u0026gt;') a.router.HandleFunc(\u0026quot;/librarys/name{name:[(]+(?:EQ|eq|LIKE|like)+[ ']+[a-zA-Z0-9_]+[')]+}\u0026quot;, requireUserMw.ApplyFn(a.libraryC.GetLibrarysByName)).Methods(\u0026quot;GET\u0026quot;).Name(\u0026quot;library.STATICFLTR_ByName\u0026quot;) // http://127.0.0.1:\u0026lt;port\u0026gt;/librarys/city(EQ '\u0026lt;sel_string\u0026gt;') a.router.HandleFunc(\u0026quot;/librarys/city{city:[(]+(?:EQ|eq)+[ ']+[a-zA-Z0-9_]+[')]+}\u0026quot;, requireUserMw.ApplyFn(a.libraryC.GetLibrarysByCity)).Methods(\u0026quot;GET\u0026quot;).Name(\u0026quot;library.STATICFLTR_ByCity\u0026quot;)  The set of generated Authorizations for the Library entity\u0026rsquo;s static filter end-points are:\n library.STATICFLTR_ByName library.STATICFLTR_ByCity  Relation Authorizations Relation end-points for entity Library follow the same rules as mentioned above and are generated as follows:\n//====================================== Library Relations ====================================== // hasMany relation ToBooks for Library a.router.HandleFunc(\u0026quot;/library/{library_id:[0-9]+}/tobooks\u0026quot;, requireUserMw.ApplyFn(a.libraryC.GetLibraryToBooks)).Methods(\u0026quot;GET\u0026quot;).Name(\u0026quot;library.REL_tobooks\u0026quot;) a.router.HandleFunc(\u0026quot;/library/{library_id:[0-9]+}/tobooks/{book_id:[0-9]+}\u0026quot;, requireUserMw.ApplyFn(a.libraryC.GetLibraryToBooks)).Methods(\u0026quot;GET\u0026quot;).Name(\u0026quot;library.REL_tobooks_id\u0026quot;)  The set of generated Authorizations for the Library entity\u0026rsquo;s relation end-points are:\n library.REL_tobooks library.REL_tobooks_id  Authorization Generation Authorizations are assigned to end-points in the route declarations as described in the preceding sections. They are also added to a table (auth) in the backing database, as are the User Groups (table usrgroup) and the assignment of Authorizations to the same (via table groupauth).\nAt application start-up, a walk of the router is performed in order to obtain a complete list of Authorizations. This is necessary, as changes may have been made to the application since the last time it was run. For example, a new entity may have been added; the Authorizations for the corresponding end-points need to be made available via the creation of new entries in the auth table. The creation of the new Authorizations in the auth table does not add them to any User Groups, but simply makes them available for use.\nAuthorization Maintenance The end-points related to Authorization, User Group and User maintenance are protected by default. This means that in order to perform any activities (such as create Users) in the generated application, an initial User belonging to a User Group with sufficient Authorizations is required. To this end, a User called \u0026lsquo;admin\u0026rsquo; and a User Group called \u0026lsquo;Super\u0026rsquo; are created by default the first time the application is run. This unfolds as follows:\n A complete list of the route Authorizations is obtained by walking the router as described above in the Authorization Generation section. Table usrgroup is checked for the existence of the \u0026lsquo;Super\u0026rsquo; group. If the \u0026lsquo;Super\u0026rsquo; User Group is not found, it is created. All existing Authorization allocations to the \u0026lsquo;Super\u0026rsquo; User Group are deleted. The list of route Authorizations is then used to allocate Authorization for each end-point to the \u0026lsquo;Super\u0026rsquo; User Group. A check for the existence of the \u0026lsquo;admin\u0026rsquo; user is executed against the usr table. If the \u0026lsquo;admin\u0026rsquo; user does not exist, it is created as a member of the \u0026lsquo;Super\u0026rsquo; User Group, with an initial password of \u0026lsquo;initpass\u0026rsquo;. As the User Group Authorizations are cached on all application instances in the pool, the cache is re-initialized locally and then distributed to the other pool members so that the \u0026lsquo;Super\u0026rsquo; group is generally available.  It is possible to force a rebuild of the \u0026lsquo;Super\u0026rsquo; User Group\u0026rsquo;s Authorization allocations by starting the generated application with the -rs (rebuild super) flag. This will force the application to run through the preceding list of steps, resulting in a \u0026lsquo;Super\u0026rsquo; User Group that contains a complete list of the Authorizations needed to access all end-points, as well as removing any end-point Authorizations that may no longer exist. Only the \u0026lsquo;Super\u0026rsquo; User Group may be updated in this manner. Changes to existing User Groups must be carried out manually by an authorized user via the end-points related to User, User Group and Authorization maintenance.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/interprocess/ip-content-b/",
	"title": "Failure Detector",
	"tags": [],
	"description": "",
	"content": " Group Membership Failure Detector  When discussing deployment of a Jiffy-generated application, each instance of the application is referred to as a process. Processes may fail. Processes exist with one of three publicly disseminated and well-known statuses: {ACTIVE; SUSPECT; FAILED} Processes exist with a publicly (within the group) disseminated incarnation number. Process viability is checked at selectable intervals (ping-cycle time) via a ping-ack mechanism. Each process pings all other processes in the group once per ping-cycle in random order. This means that each process is guaranteed to ping every other process in the group in (2n-1) pings, where n is the number of non-failed processes in the process-list. Processes failing a ping-ack exchange are not immediately failed but are moved into the SUSPECT state. The failure-threshold outlining the number of permissible ping-ack failures for a SUSPECT process is configurable via the \u0026lsquo;failure_threshold\u0026rsquo; key in the configuration file. At the moment, the configuration value is used directly, but in large groups or groups where the number of active members varies greatly it would make sense to use the configuration value in combination with the number of active processes in the group to determine an appropriate SUSPECT to FAILURE threshold value. The local status-count of the SUSPECT process is incremented once for each failed ping or notification of a failed Ping from another process in the group. Process status is disseminated across all processes by way of a gossip-based infection-style piggybacking of process information on top of a process\u0026rsquo;s outgoing Ping messages. Pinging process (Pi) sends a Ping containing it\u0026rsquo;s local group-membership list to a target process (Pj). Process Pj receives the Ping, takes note of the included group-membership list from Pi, updates its own group-membership list, then sends an Ack message back to Pi. Ping status scenarios are broken out in a subsequent section. Once a SUSPECT process (Pj) reaches the failure-threshold in any pinging process (Pi), process Pi moves process Pj from the SUSPECT to the FAILED state in its local group-membership list.  Typically the implementer should not have to worry about the failure detector beyond establishing reasonable limits for SUSPECT status Ping failures and setting a reasonable ping-cycle time.\nProcess Status Scenarios Consider a group-membership of {P1; P2; P3} where failure-threshold == 3:\nP1 Ping-Cycle\n (P1-Ping) -\u0026gt; (P2) (P2-Ack) -\u0026gt; (P1) (P1-Ping) -\u0026gt; (P3) (P3-Ack) -\u0026gt; (P1) (P1-Ping) -\u0026gt; (P1) (P1-Ack) -\u0026gt; (P1)  P2 Ping-Cycle\n (P2-Ping) -\u0026gt; (P1\u0026gt; (P1-Ack) -\u0026gt; (P2) (P2-Ping) -\u0026gt; (P3) (P3-Ack) -\u0026gt; (P2) (P2-Ping) -\u0026gt; (P2) (P2-Ack) -\u0026gt; (P2)  P3 Ping-Cycle\n (P3-Ping) -\u0026gt; (P1) (P1-Ack) -\u0026gt; (P3) (P3-Ping) -\u0026gt; (P2) (P2-Ack) -\u0026gt; (P3) (P3-Ping) -\u0026gt; (P3) (P3-Ack) -\u0026gt; (P3)  Example 1 (P1-Ping-1) -\u0026gt; (P2)\n(P2-NoAck)\nP1 moves P2\u0026rsquo;s status to SUSPECT in the local P1 group-membership list and sets the P2 status-count back to 1.\n\u0026hellip; ping-cycle completes\n(P1-Ping-2) -\u0026gt; (P2)\n(P2-NoAck)\nP1 leaves P2\u0026rsquo;s status as SUSPECT in the local P1 group-membership list and increments the P2 status-count by 1 (==2).\n\u0026hellip; ping-cycle completes\n(P1-Ping-3) -\u0026gt; (P2)\n(P2-NoAck)\nP1 moves P2\u0026rsquo;s status to FAILED in the local P1 group-membership list and increments the P2 status-count by 1 (==3).\n\u0026hellip; ping-cycle completes\nAs P1\u0026rsquo;s group-membership list is being updated with the P2 ping failures, P1 is disseminating that information to the other processes in the group. It is likely that other processes in the group have also noticed that P2 is not responding, so these processes are also disseminating the P2 SUSPECT status to all other processes in the group - including P1. As a result, failing processes will accrue SUSPECT status counts rapidly in each process\u0026rsquo;s group-membership list; the failure threshold value should be computed as a product of the number of running processes in the group (TODO).\nExample 2 (P1-Ping-1) -\u0026gt; (P2)\n(P2-NoAck)\nP1 moves P2\u0026rsquo;s status to SUSPECT in the local P1 group-membership list and sets the P2 status-count back to 1.\n\u0026hellip; ping -cycle completes\n(P1-Ping-2) -\u0026gt; (P2)\n(P2-NoAck)\nP1 leaves P2\u0026rsquo;s status as SUSPECT in the local P1 group-membership list and increments the P2 status-count by 1 (==2).\n\u0026hellip; ping-cycle completes\n(P1-Ping-3) -\u0026gt; (P2)\n(P2-Ack) -\u0026gt; (P1)\nP1 may set P2\u0026rsquo;s status back to ALIVE in the local P1 group-membership list and reset the P2 status-count back to 1).\n\u0026hellip; ping-cycle completes\nWhy would P1 not guarantee the reset of P2\u0026rsquo;s status to the ALIVE state after receiving an Ack for last Ping message?\nAs the ping-cycles run, the possibility exists that if P2 were to come back online it may receive a Ping message containing a group-membership list where it (P2) is in a SUSPECT state. If P2 sees that it is SUSPECT, it reacts by incrementing it\u0026rsquo;s incarnation-number which is then relayed to the group-members via P2\u0026rsquo;s ping messages. When a process (let\u0026rsquo;s say P1), sees that SUSPECT process P2 has sent a Ping, it checks the embedded incarnation-number to see if it is greater than the P2 incarnation-number presently stored in P1\u0026rsquo;s local group-membership list. If the incarnation-number contained in the Ping is greater, P1 updates it\u0026rsquo;s group-membership list to indicate that P2 is ALIVE with a new incarnation number. If the incarnation-number in the (P2-Ping) is lower or the same as that of the P2 record in the local P1 group-membership list, the Ping is discarded.\nP2 can still send the Ack\u0026rsquo;s in response to Pings coming from other processes, and due to the concurrent nature of the service, it may well send a Ping to the other group-members (P1 for example) in time to prevent itself from being failed, but this is an unavoidable edge-case. When a SUSPECT process recovers to the extent that it is reachable again, and one or more group-members are very close to reaching the failure-threshold for the process in question, there is a chance that the recovered process will be failed anyway.\nThere is a lot more to write here in order to completely describe the mechanics of how the failure detector works.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/overview/ov-content-c/",
	"title": "Jiffy Application Structure",
	"tags": [],
	"description": "",
	"content": " Jiffy Application File Structure This is what Jiffy generates when provided with a model-file describing a simple \u0026lsquo;Person\u0026rsquo; entity. The structure and files look more or less standard if you are used to looking at such things. Explanations of each folder and its content are discussed throughout the documentation.\nFirstApp ├── appobj │ ├── appconf.go │ └── appobj.go ├── controllers │ ├── authc.go │ ├── controllerfuncs.go │ ├── groupauthc.go │ ├── person_relationsc.go │ ├── personc.go │ ├── usrc.go │ ├── usr_groupc.go │ └── ext │ ├── extc_interfaces.go │ └── personc_ext.go ├── group │ ├── gmcl │ │ ├── gmclient.go │ ├── gmcom │ │ ├── gmcache.go │ │ ├── gmclsrv.go │ │ ├── gmerrors.go │ │ └── gmomap.go │ └── gmsrv │ ├── gmprocessors.go │ ├── gmprotocol_senders.go │ ├── gmserver.go │ └── gmtxrx.go ├── jwtkeys │ ├── ecdsa256 │ │ ├── ecdsa.priv.pem │ │ └── ecdsa.pub.pem │ ├── ecdsa384 │ │ ├── ecdsa384.prive.pem │ │ └── ecdsa384.pub.pem │ ├── ecdsa521 │ │ ├── ecdsa521.priv.pem │ │ └── ecdsa521.pub.pem │ ├── rsa256 │ │ ├── rsa.priv.pem │ │ └── rsa.pub.pem │ ├── rsa384 │ │ ├── rsa384.prive.pem │ │ └── rsa384.pub.pem │ └── rsa512 │ ├── rsa512.priv.pem │ └── rsa512.pub.pem ├── middleware │ └── requireuser.go ├── models │ ├── authm.go │ ├── errors.go │ ├── group_authm.go │ ├── modelfuncs.go │ ├── personm_ext.go │ ├── personm.go │ ├── servicesm.go │ ├── usr_groupm.go │ ├── usrm.go │ └── ext │ └── model_ext_interfaces.go ├── util │ └── strings.go ├── .dev.config.json ├── .prd.config.json ├── main_test.go └── main.go  Jiffy Application Services Jiffy approaches the API from a services perspective. Each entity has a corresponding service that can be started when the application initializes. The Usr, UsrGroup, Auth and GroupAuth services are always generated by default when creating a Jiffy application. Additional services are generated based on the model files created based on the business scenario.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/gs-content-d/",
	"title": "Let&#39;s Run Something",
	"tags": [],
	"description": "",
	"content": "Let\u0026rsquo;s execute our first application!\n$ cd $GOPATH/src/jiffy_tests/first_app $ go run main.go -dev -rs  Executing with the -dev and -rs flags instructs our new application to initialize itself using the development settings file, and forces a rebuild of the \u0026lsquo;Super\u0026rsquo; authorization-group. Consequently, you will see some warning and info messages scroll up the screen which is expected.\n2018/02/05 22:29:26 package sqac init is running 2018/02/05 22:29:26 successfully loaded the config file... 2018/02/05 22:29:26 JWTPrivKeyFile: jwtkeys/private.pem 2018/02/05 22:29:26 JWTPubKeyFile: jwtkeys/public.pem 2018/02/05 22:29:26 warning: auth usr.GET_SET not found in the db Auth master data 2018/02/05 22:29:26 warning: auth usr.CREATE not found in the db Auth master data 2018/02/05 22:29:26 warning: auth usr.GET_ID not found in the db Auth master data ... ... 2018/02/05 22:29:26 info: creating auth usr.GET_SET in the db Auth master data 2018/02/05 22:29:26 warning: new auth usr.GET_SET must be added to at least one group 2018/02/05 22:29:26 info: creating auth usr.CREATE in the db Auth master data 2018/02/05 22:29:26 warning: new auth usr.CREATE must be added to at least one group ... ... 2018/02/05 22:29:26 warning: new auth person.STATICFLTR_ByValidLicense must be added to at least one group 2018/02/05 22:29:26 info: creating auth person.STATICFLTR_CMD_ByValidLicense in the db Auth master data 2018/02/05 22:29:26 warning: new auth person.STATICFLTR_CMD_ByValidLicense must be added to at least one group 2018/02/05 22:29:26 The Super UsrGroup has been initialized with 42 Auth objects. 2018/02/05 22:29:26 re-initializing local middleware to accomodate Super group changes. 2018/02/05 22:29:27 admin user created with ID: 1 and initial password of initpass Development settings selected... Starting http server on port... 8080  You should see a message indicating that the application is running. During the startup, the application executed a number of steps.\n Loaded the development configuration file. Initialized a handle to the underlying ORM. Checked for and loaded the public and private keys for JWT support. Checked for and created the user, auth, and usrgroup tables in the database. Checked for and created the person table in the database based on the Person model. Checked for and created authorizations in the database for each service end-point. Checked for and created the Super user-group in the database. Assigned all authorizations to the Super user-group. Created the \u0026lsquo;admin\u0026rsquo; user and assigned it to the \u0026lsquo;Super\u0026rsquo; user-group. Initialized the authorization cache in the router. Started the router. Looked at the leader-persistence store to determine the group-leader (and failed). Became the defacto group-leader, set own process-id (usually to 1 in this case). Updated the leader-persistence store withe the new group-leader information. Started the inter-process failure-detector.  Congratulations! Your first application is now open for business at http://127.0.0.1:8080\n"
},
{
	"uri": "https://1414c.github.io/jiffy/extensionpoints/ep-content-c/",
	"title": "Model Extension Points",
	"tags": [],
	"description": "",
	"content": " Overview Model extension-points exist for the Create, Update and Get CRUD operations. Each operation has a related extension-point interface, for which an empty implementation is created when the application is generated. If the generator sees that the extension-point implementation file for an entity has already been created, it will not over-write or create a new version.\nFile ./myapp/models/ext/extm_interfaces.go contains the generated entity model extension-point interface declarations. Each interface and interface method is documented in this file.\nFile ./myapp/controllers/m_ext.go is generated for each entity with empty extension-point interface implementations. This file may be edited by the application developer to add custom application logic.\nModel Extension-Point Interfaces  Interface ModelCreateExt   BeforeDB(ent interface{}) error BeforeDB is an extension-point that can be implemented in order to examine and potentially make changes to the values in the entity structure immediately before the insertion request is made to the ORM. This extension-point is the first code executed in the model's Create method. Authentication and Authorization checks should be performed upstream in the route middleware-layer and detailed checks of an entity's data should be carried out in the validator-layer.    AfterDB(ent interface{}) error CreateAfterDB is an extension-point that can be implemented in order to examine and potentially make changes to the values in the entity structure immediately following the return of the ORM insertion request. This extension-point is the last code executed in the model's Create method. As the insertion will have already occurred at this point, care should be taken when deciding whether to issue an error in this extension-point. Augmentation of the of the Create result may be carried out in this method in order to calculate non-persistent entity values for example.     Interface ModelUpdateExt   BeforeDB(ent interface{}) error BeforeDB is an extension-point that can be implemented in order to examine and potentially make changes to the values in the entity structure immediately before the update request is made to the ORM. This extension-point is the first code executed in the model's Update method. Authentication and Authorization checks should be performed upstream in the route middleware-layer and detailed checks and normalization of the entity's data should be carried out in the validator-layer.    AfterDB(ent interface{}) error AfterDB is an extension-point that can be implemented in order to examine and potentially make changes to the values in the entity structure immediately following the return of the ORM update request. This extension-point is the last code executed in the model's Update method. As the update will have already occurred at this point, care should be taken when deciding whether to issue an error in this extension-point. Augmentation of the of the Update result may be carried out in this method in order to calculate non-persistent entity values for example.     Interface ModelGetExt   BeforeDB(ent interface{}) error BeforeDB is an extension-point that can be implemented in order to examine and potentially make changes to the values in the entity structure immediately before the read-entity request is made to the ORM. This extension-point is the first code executed in the model's Get method. Authentication and Authorization checks should be performed upstream in the route middleware-layer and detailed checks of an entity's data should be carried out in the validator-layer.    AfterDB(ent interface{}) error AfterDB is an extension-point that can be implemented in order to examine and potentially make changes to the values in the entity structure immediately following the return of the ORM read-entity request. This extension-point is the last code executed in the model's Get method. As the read will have already occurred at this point, care should be taken when deciding whether to issue an error in this extension-point. Augmentation of the of the Get result may be carried out in this method in order to calculate non-persistent entity values for example. Note that the AfterDB(ent interface{}) method is called after the single and set Get CRUD operations for an entity.    "
},
{
	"uri": "https://1414c.github.io/jiffy/generation/gn-content-c/",
	"title": "Generated &#39;appobj&#39; Folder",
	"tags": [],
	"description": "",
	"content": " The \u0026lsquo;appobj\u0026rsquo; Folder  The appobj folder contains the generated application\u0026rsquo;s configuration loader and the main application object. \nFirstApp ├── appobj │ ├── appconf.go │ └── appobj.go ├── controllers │ ├── ... │ ├── ... . . . ├── .dev.config.json ├── .prd.config.json ├── main_test.go └── main.go  appobj.go The entry point for go applications is always the main() function, but we seldom write the so-called \u0026lsquo;main\u0026rsquo; part of the application in this monolithic function. To that end, an AppObj struct is declared and the main thread of the application runs against it. The content of main.go simply creates an instance of an AppObj struct, parses the flags and then calls the AppObj.Run() method.\nWhen the generated application is started, AppObj.Run() is responsible for:\n loading the specified config creating the runtime services performing auto-migration of database artifacts initializing the keys for JWT/ECDSA support instantiating controllers initializing routes starting the mux reading the group-leader information from the group persistent store joining (or creating) the group starting the inter-process group-membership failure detector  The creation of the runtime services bears closer inspection before moving on. Generated applications contain an internal \u0026lsquo;service\u0026rsquo; for each entity declared in the source model files. The AppObj is responsible for the instantiation of these services when the application is started via the AppObj.createServices() method.\nA Services object containing each of the entity runtime services is created on the one-and-only instance of the AppObj. A runtime service is first created to support access to the backend DBMS via the sqac ORM, then a service is started for each entity. Entity services contain a reference to the ORM access handle, as well as an instance of the entity\u0026rsquo;s validator class which is contained in the model-layer.\nappconf.go The code in appconf.go contains the functions used to load application configuration files, as well as functions containing so-called \u0026lsquo;default\u0026rsquo; configuration. It is possible to edit the DefaultConfig() function so that it holds values specific to the local test/development environment. This prevents the need for maintaining a set of configuration files that the development staff need to keep in sync.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/models/mo-content-c/",
	"title": "Model with Composite Index",
	"tags": [],
	"description": "",
	"content": " Two Entity Model with Composite Index The following JSON illustrates the addition of a composite-index to an entity definition. An index composed of the \u0026lsquo;name\u0026rsquo; and \u0026lsquo;province\u0026rsquo; fields has been declared in the \u0026lsquo;Owner\u0026rsquo; entity. This declaration will result in the creation of a non-unique b-tree index for columns \u0026lsquo;name\u0026rsquo; and \u0026lsquo;province\u0026rsquo; in the database. Any number of composite indices may be declared for an entity. No relationships have been defined between the two entities; this example simply illustrates how to declare a composite-index for an entity.\ntwoEntityWithCompositeIndex.json\n{ \u0026quot;entities\u0026quot;: [ { \u0026quot;typeName\u0026quot;: \u0026quot;Owner\u0026quot;, \u0026quot;properties\u0026quot;: { \u0026quot;Name\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: false, \u0026quot;unique\u0026quot;: false, \u0026quot;index\u0026quot;: \u0026quot;nonUnique\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,like\u0026quot; }, \u0026quot;LicenseNumber\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;uint\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: false, \u0026quot;unique\u0026quot;: true, \u0026quot;index\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,lt,gt\u0026quot; }, \u0026quot;Province\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: false, \u0026quot;unique\u0026quot;: false, \u0026quot;index\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,lt,gt\u0026quot; } }, \u0026quot;compositeIndexes\u0026quot;: [ {\u0026quot;index\u0026quot;: \u0026quot;name, province\u0026quot;} ] }, { \u0026quot;typeName\u0026quot;: \u0026quot;Car\u0026quot;, \u0026quot;properties\u0026quot;: { \u0026quot;Model\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: true, \u0026quot;index\u0026quot;: \u0026quot;nonUnique\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,like\u0026quot; }, \u0026quot;Make\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: true, \u0026quot;index\u0026quot;: \u0026quot;nonUnique\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,like\u0026quot; } } } ] }  "
},
{
	"uri": "https://1414c.github.io/jiffy/accesscontrol/ac-content-c/",
	"title": "Access Revocation and Renewal",
	"tags": [],
	"description": "",
	"content": " JWT Tokens and Access Revocation Jiffy applications do not support the revocation or automatic renewal of JWT tokens. Instead, a cross-process cache of User information is maintained via a group-membership service. The service ensures that changes to User information (create/update/delete) are disseminated to all running instances of the Jiffy generated application. Consequently, in Jiffy-based applications it makes sense to discuss User access revocation from the perspective of an administrator making a call to the user-API to perform general User deletion or deactivation. Such changes are affected in the backend database, and then updated in the application server caches by way of the web-sockets-based group-membership service.\nJWT Token Expiration JWT\u0026rsquo;s contain a standard set of registered claims as outlined in RFC7519 https://tools.ietf.org/html/rfc7519#section-4.1. Login to a jiffy generated application results in the creation of a new JWT where the standard \u0026lsquo;exp\u0026rsquo; claim is set based on the value of the \u0026lsquo;jwt_lifetime\u0026rsquo; key in the application\u0026rsquo;s configuration file. When the current (server) date-time exceeds the value contained in a JWT\u0026rsquo;s \u0026lsquo;exp\u0026rsquo; claim, the token is no longer accepted by the application. After JWT expiration, the used is forced to login again.\nJWT Token Renewal It would be possible to alter the Jiffy application to create self-renewing JWT\u0026rsquo;s. Doing so would mandate that the client developer compare the Authorization field in the response header to the one that was sent in the request. For now, the strategy is to have the application configuration set a JWT validity of ~12 hours, and then force the user to login again once the time limit expires.\nOn one hand, this approach to (not supporting) JWT renewal means that the client/consumer of the RESTful services need not worry about checking the JWT content at the end of each exchange. On the other hand, the current strategy may be a concern in system-to-system interfaces especially where it is not acceptable to set a very long JWT expiry limit in the configuration.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/interprocess/ip-content-c/",
	"title": "Process Startup / Join",
	"tags": [],
	"description": "",
	"content": " Process Startup with Group Membership When an instance (process) starts in a group-membership scenario, the group-membership subsystem is started as a goroutine within the application.\nMember Communication The group-membership service communicates between processes via web-sockets connections. Each process accepts group-membership messages on the address:port specified by the \u0026lsquo;internal_address\u0026rsquo; key in the configuration file. This port is not secured, and the group-membership messages are not encrypted in any way. It is advisable that the address:port used here is not accessible to the outside world.\nDue to the round-robin every-process-pings-every-other-process model used by the failure detector, the group-membership service can be rather busy.\nGroup Leadership Overview Election Overview In order to participate in a group, each starting process needs to know who the current group-leader is. Group-leadership is determined internally via the failure-detector and a bully-type leader-election. Each process knows who the current group-leader is at any given time. If a failure of the group-leader is detected, an election is held whereby the process with the highest process-id (PID) assumes leadership of the group.\nAssertion of leadership is disseminated to all group-members by the new leader via the COORDINATOR message. This takes care of the current group-members, but processes wishing to join the group must have a way to determine who the current group-leader is.\nJoining Overview Joining processes must access a well-known persistent store that holds the current group-leader information. This means that each joining process must know the location of and the manner in which the persistent store can be queried. The persistent store exists outside of the group-membership and is typically some sort of name-value key-store like redis or memcached.\nTo this end, a general interface is provided by Jiffy to allow the implementing developer to access the persistent store of their choice. The rationale here is that many implementers will have a preference in terms of the key-value store they use, and may already have a suitable kvs in their productive landscape. The interface provided by Jiffy for this purpose is gmcom.GMLeaderSetterGetter and it must be implemented in the application\u0026rsquo;s main.go and passed into the AppObj.Run() method on application startup.\nInterface gmcom.GMGetterSetter Interface gmcom.GMGetterSetter contains methods to facilitate read/write access to the persisted leader record in any key-value-store. Applications implementing the interface may choose to store the persisted current leader in a number of mediums; flat-file, db table record, redis, memcached etc.\n Interface gmcom.GMGetterSetter  \nGetDBLeader() (*GMLeader, error) GetDBLeader is provided in order to allow the implementer to retrieve the current group-leader information from the persistent store. The implementation of this method is intended to be self-contained. For example, if the implementation calls for the current leader information to be persisted in redis, the implementer should code a self-contained method to connect to redis, retrieve the leader information and return it in the GMLeader pointer. Failure to read a current leader from the persistent store should result in the return of a nil in place of the *GMLeader pointer and a non-nil error value.    SetDBLeader(l GMLeader) error SetDBLeader is provided in order to allow the implementer to persist a newly elected leader\u0026rsquo;s information in the persistent store. The implementation of this method is intended to be self-contained. For example, if the implementation calls for the current leader information to be persisted in redis, the implementer should code a self-contained method to connect to redis and store the leader information provided by input parameter l. Failure to persist the provided leader information should result in the implementer returning a non-nil value in the error return parameter.    Interface gmcom.GMSetterGetter Sample Implementation // LeadSetGet provides a sample implementation of the GMLeaderSetterGetter // interface in order to support persistence of the current group-leader // information. re-implement these methods as you see fit to facilitate // storage and retrieval of the leader information to and from the persistent // storage. This example uses a quick and dirty web-socket-based cache to // handle the persistence. It works well enough for testing, but you should // use something more robust like a database, redis etc. The methods in the // GMLeaderSetterGetter interface are called when a new process is attempting // to join the group and also when a new leader is selected via the coordinator // process. // // To test with the delivered interface implementation, install and run sluggo: // go get -u github.com/1414C/sluggo // // Execute sluggo from the command-line as follows: // go run main.go -a \u0026lt;ipaddress:port\u0026gt; // For example: // $ go run main.go -a 192.168.1.40:7070 // type LeadSetGet struct { gmcom.GMLeaderSetterGetter } // GetDBLeader retrieves the current leader information from // the persistence layer. func (sg *LeadSetGet) GetDBLeader() (*gmcom.GMLeader, error) { // access the database here to read the current leader l := \u0026amp;gmcom.GMLeader{} wscl.GetCacheEntry(\u0026quot;LEADER\u0026quot;, l, \u0026quot;192.168.1.40:7070\u0026quot;) return l, nil } // SetDBLeader stores the current leader information in the // persistence layer. func (sg *LeadSetGet) SetDBLeader(l gmcom.GMLeader) error { // access the database here to set a new current leader wscl.AddUpdCacheEntry(\u0026quot;LEADER\u0026quot;, \u0026amp;l, \u0026quot;192.168.1.40:7070\u0026quot;) return nil }  Startup \u0026amp; Leader Identification When the application starts in group-membership mode, the process must determine who the group-leader is as described in the preceding sections. The process tries to join an existing group four times before giving up, and within each join attempt the process tries to read the current leader PID from the persistent store three times.\nLeader Identification When the starting process is able to read the PID and IP Address:port of the current group-leader from the persistent store, it proceeds to the next step where an attempt to contact the leader is made.\nIf the starting process is unable to read the leader information from the persistent store, the process waits for a randomized period of between 1 and 1000 ms. Once the wait is over, the process tries to read the current leader from the persistent store again. This loop will be repeated up to four times before the process gives up and attempts to assume leadership itself.\nA distinction is not currently made between being unable to contact the persistent store and not finding a current leader after reading the persistent store.\nLeader is Found but not Contactable When a value is read from the persistent store, it is assumed to be that of the current group-leader. This may not always be true, particularly in the case of an application startup where the external leader kvs has not been restarted or when old leader information has not been evicted.\nLeader is Found and has the Current PID\u0026rsquo;s IP Address It is possible that the starting PID\u0026rsquo;s address matches that of the leader that was read from the persistent store. This can happen in scenarios where the leader is the last process standing and then terminates without warning.\nThe persistent store retains the last leader information (Pi) resulting in a successful leader-ping if the first process to restart in the group happens to hold the same ip-address as that of the old leader. A successful ping (Pi-\u0026gt;Pi) looks like there is a functioning leader.\nIf the joining process sees it\u0026rsquo;s own ip-address in the leader slot within the persistent store, it is best to act like there is no current leader and wipe the read (leader) information clean. This will repeat four times as described above, then the current PID will attempt to assert itself as group-leader. The randomized time is used to offset potentially simultaneous multiple group-leadership assertions in mass cold-start situations.\nIt is important to remember/know that a starting process does not start participating in the group failure-detector until it has either joined an existing group, or has become the leader thereby starting a new group.\ni.e. {inGetDBLeader 0 192.168.1.42:5050 0 0 1 192.168.1.42:5050 0 0 0 true \u0026lt;nil\u0026gt;} see if the persisted leader is contactable or not...  Leader is Found Once that starting process has obtained a set of group-leader information from the persistent store that looks valid, it uses the information to send a Join message to the group-leader. There are a few possible outcomes to the Join message:\n The leader could not be contacted. In this case, the starting process waits for a randomized period of time between 1 and 1000ms, then loops back to read the leader information from the persistent store again in hope that it has been updated. This can occur up to four times, after which the starting process will attempt to become the group-leader. The leader information read from the persistent store was not correct. It is possible that the leader information in the persistent store is stale during a cold-startup. In this case, although a process was reachable at the leader\u0026rsquo;s ip-address:port, the so-called leader process was not in fact the leader. In this case, the starting process waits for a randomized period of time between 1 and 1000ms, then loops back to read the leader information from the persistent store again in hope that it has been updated. This can occur up to four times, after which the starting process will report an error and gracefully exit. The leader reports that the ip-address:port of the starting process is already in use within the group. This can occur due to a misconfigured failure threshold value (too high), or when a process is killed and restarted immediately. In this case, the starting process waits 5 seconds and then loops back to read the leader information and make another attempt to join the group. This can occur up to four times, after which the starting process will report an error and gracefully exit. An unknown error occurs. This is a catch-all for failed join attempts. In this case, the starting process waits 5 seconds and then loops back to read the leader information and make another attempt to join the group. This can occur up to four times, after which the starting process will report an error and gracefully exit.  No Leader is Found If a valid group-leader has not been found after four attempts, the starting process attempts to become the group-leader. The starting process will:\n Set it\u0026rsquo;s PID to 1. Add itself to the local process member map. Call gm.SendSetDBLeader to set itself as group-leader in the persistent store. Start it\u0026rsquo;s failure-detector loop in a go-routine.  "
},
{
	"uri": "https://1414c.github.io/jiffy/overview/ov-content-d/",
	"title": "Jiffy Application Architecture",
	"tags": [],
	"description": "",
	"content": " Jiffy Application Architecture Jiffy approaches the API from a services perspective. Each entity has a corresponding service that can be started when the application initializes. The Usr, UsrGroup, Auth and GroupAuth services are always generated by default when creating a Jiffy application. Additional services are generated based on the content of your project\u0026rsquo;s model files.\nGenerated application services can be broken down into five high-level areas: \ngraph TD; subgraph A(End-Points)--B(Middleware) B--C(Controllers) C--D(Models) D--E(Database) end  \n End-Points expose the service APIs to the consumer such as a web-app or another server. End-points may be customized by way of the application model files. Middleware provides user authentication / authorization services and is tightly-coupled to the end-point definitions. The middleware offers comprehensive services such as authorization via JWT claims inspection, as well as some caching of user and group authorization details. This is an area of active development. Controllers are the entry point into the application proper, and are called after a request has been granted access to the end-point by the middleware. It is here that the body of the request is unmarshalled and mapped into the correct go model structure. Extension-points conforming to standard Jiffy interfaces are provided in the controllers for post-generation enhancements. Models are where the entity data from the request is checked, normalized and prepared for submission to the database. Extension-points conforming to standard Jiffy interfaces are provided in the models for post-generation enhancements. Database refers to the backend DBMS that is being used to house the entity data. Jiffy generated applications can connect to PostgreSQL, MariaDB/MySQL, MSSQL, SAP HanaDB or SQLite. It is easy to extend the database support to other relational platforms provided that there is an existing go sql driver for the database in question. It is possible to override the generated Jiffy call to the database and \u0026lsquo;roll-your-own\u0026rsquo; should the need arise.  "
},
{
	"uri": "https://1414c.github.io/jiffy/generation/gn-content-d/",
	"title": "Generated &#39;controllers&#39; Folder",
	"tags": [],
	"description": "",
	"content": " The \u0026lsquo;controllers\u0026rsquo; Folder FirstApp ├── appobj │ ├── appconf.go │ └── appobj.go ├── controllers │ ├── authc.go │ ├── controllerfuncs.go │ ├── groupauthc.go │ ├── person_relationsc.go │ ├── personc.go │ ├── usrc.go │ ├── usr_groupc.go │ └── ext │ ├── extc_interfaces.go │ └── personc_ext.go ├── group │ ├── ... │ │ ├── ... . . . . . ├── .dev.config.json ├── .prd.config.json ├── main_test.go └── main.go  A controller is created for each entity that has been declared in the model files, as well as a number of static controllers that are used to handle the application\u0026rsquo;s users and authorization objects.\nControllers act as a bridge between an entity\u0026rsquo;s routes and its model layer. Each entity mux route is assigned a method in their respective controller based on the intent of that route. For example, to create a new new Library entity the following POST could be made:\nhttps://servername:port/library {JSON body} + POST  The route for this call is defined in appobj.go as follows, where \u0026lsquo;a\u0026rsquo; is the one-and-only instance of the AppObj:\na.router.HandleFunc(\u0026quot;/library\u0026quot;, requireUserMw.ApplyFn(a.libraryC.Create)).Methods(\u0026quot;POST\u0026quot;)  The \u0026lsquo;/library\u0026rsquo;-POST route is assigned a HandleFunc belonging to the instance of the LibraryController that has been created on the appobj. a.libraryC.Create is called for the \u0026lsquo;library\u0026rsquo; route when the http method equals \u0026lsquo;POST\u0026rsquo;. The route contains some additional code related to authentication and authorization of the requester but this can be ignored for now. The handler function for a mux.route must conform to the standard go http.Handler interface:\ntype Handler interface { ServeHTTP(ResponseWriter, *Request) }  This interface facilitates the passing of the incoming request header and body to the controller method, as well as the passing of the formatted response back to the router. With this out of out the way, let\u0026rsquo;s look at generated Controller method LibraryController.Create:\n// Create facilitates the creation of a new Library. This method is bound // to the gorilla.mux router in main.go. // // POST /library func (lc *LibraryController) Create(w http.ResponseWriter, r *http.Request) { var l models.Library decoder := json.NewDecoder(r.Body) if err := decoder.Decode(\u0026amp;l); err != nil { log.Println(\u0026quot;Library Create:\u0026quot;, err) respondWithError(w, http.StatusBadRequest, \u0026quot;libraryc: Invalid request payload\u0026quot;) return } defer r.Body.Close() // fill the model library := models.Library{ Name: l.Name, City: l.City, } // build a base urlString for the JSON Body self-referencing Href tag urlString := buildHrefStringFromCRUDReq(r, true) // call the Create method on the library model err := lc.ls.Create(\u0026amp;library) if err != nil { log.Println(\u0026quot;Library Create:\u0026quot;, err) respondWithError(w, http.StatusBadRequest, err.Error()) return } library.Href = urlString + strconv.FormatUint(uint64(library.ID), 10) respondWithJSON(w, http.StatusCreated, library) }  The complete Library.Create(http.Handler) controller method is shown exactly as it has been generated.\nEach section of the method is broken down in the following subsets of commented code:\n// declare a local variable of struct type models.Library to hold the decoded // JSON body provided in the request.Body. var l models.Library // create a new JSON decoder passing in the request.Body decoder := json.NewDecoder(r.Body) // call the Decoder.Decode(interface{}) method passing a reference to the locally // declared models.Library struct 'l'. if the decoder is able to decode the JSON // contained in the request.Body, the member fields of 'l' will be populated. if // the decoder fails to parse and map the incoming JSON to the models.Library // struct, it will return an error. The problem will be logged to stdout (for now) // on the server-instance, and a response conforming to the http.Handler interface // will be constructed and passed back to the router. if the JSON was parsed // closed upon exit of the method. if err := decoder.Decode(\u0026amp;l); err != nil { log.Println(\u0026quot;Library Create:\u0026quot;, err) respondWithError(w, http.StatusBadRequest, \u0026quot;libraryc: Invalid request payload\u0026quot;) return } defer r.Body.Close() // fill the model with the parsed content of the JSON body. this step looks // redundant, but can be thought of as a way to separate the incoming data // from the response. going forward from this point, 'l' is ignored and // all data transformation occurs on the 'library' variable. library := models.Library{ Name: l.Name, City: l.City, } // build a base urlString for the JSON Body self-referencing Href tag urlString := buildHrefStringFromCRUDReq(r, true) // call the Create method on the library model. each controller contains an // instance of the Service for it's respective entity. the Create method on // the service is called, passing a reference to the 'library' data structure. // recall that the Service for an entity provides the link to that entity's // model-layer by way of the entity's validator. lc.ls.Create(\u0026amp;library) will // result in a call the model Validator Create() method for the Library // entity, and in-turn, call to the enitity's model.Create() method where // the data will be passed to the ORM-layer. if the Create() call returns // an error, the problem will be logged to stdout (for now) on the server- // instance, and a response conforming to the http.Handler interface will be // constructed and passed back to the router. err := lc.ls.Create(\u0026amp;library) if err != nil { log.Println(\u0026quot;Library Create:\u0026quot;, err) respondWithError(w, http.StatusBadRequest, err.Error()) return } // if the call to the model-layer was successful, it indicates that a new // Library entity was created in the DBMS. the 'library' reference passsed // to the Create() method(s) in the model-layer will now contiain the new // Library's information. first, the ID for the new Library will be added // to the urlString and assigned to the library struct's Href member field. // Href is another injected field in the entity and fullfills the purpose // of providing a direct URI for the returned entity. finally the populated // 'library' struct is formatted as a JSON response and passed back to the // router along with an http status-code indicating success. library.Href = urlString + strconv.FormatUint(uint64(library.ID), 10) respondWithJSON(w, http.StatusCreated, library) }  The controllers folder also contains an \u0026lsquo;ext\u0026rsquo; sub-directory which is used to hold the interface definitions for controller extension-points as well as the associated empty implementation for each entity. See the \u0026lsquo;Extension Points\u0026rsquo; section of this document for more details.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/models/mo-content-d/",
	"title": "Entity Relations",
	"tags": [],
	"description": "",
	"content": " Modeling Entity Relationships Relationships between entities can be declared in the application model file via the addition of a \u0026lsquo;relations\u0026rsquo; block inside an entity\u0026rsquo;s declaration. Relationships are based on resource id\u0026rsquo;s by default, although it is possible to specify non-default key fields in the configuration, or implement complex joins directly by maintaining the entity\u0026rsquo;s controller and model. \u0026lsquo;relations\u0026rsquo; blocks look as follows:\n\u0026quot;relations\u0026quot;: [ { \u0026quot;relName\u0026quot;: \u0026quot;ToOwner\u0026quot;, \u0026quot;properties\u0026quot;: { \u0026quot;relType\u0026quot;: \u0026quot;hasOne\u0026quot;, \u0026quot;toEntity\u0026quot;: \u0026quot;Owner\u0026quot; } } ]  The sample relations block illustrates the declaration of a HasOne relationship between Car and Owner making use of default-keys.\nhasOne Relationship \u0026lsquo;hasOne\u0026rsquo; relationships establish a one-to-one relationship between two model entities. As an example, let\u0026rsquo;s posit that a Car can have one Owner. If the Car and Owner were modeled as entities, we could declare a \u0026lsquo;hasOne\u0026rsquo; (1:1) relationship between them. The relation would be added to the \u0026lsquo;relations\u0026rsquo; block inside the Car entity definition (as shown above).\nA break-down of the relations block fields is as follows:\n{ \u0026quot;relations\u0026quot;: [ The 'entities' block contains an array of relations belonging to the containing entity definition. Each relation is defined from the perspective of the containing entity having a relationship of the specified type (in this case hasOne), with the entity referenced in the declaration. A Car has one Owner - in our example at least. { \u0026quot;relName\u0026quot;: \u0026quot;Owner\u0026quot; Field 'relName' refers to the name the relationship will be known by inside the application and in the end-point definition in the mux routes. It must be capitalized and written in CamelCase. Any name may be chosen for this field, but keep in mind this name will be exposed to the service consumer via the URI, so something respecting the relationship enities and cardinality is best. For the example, we have chosen a relName of 'ToOwner' to demonstrate the difference between the toEntity and relName fields. 'relName' is a mandatory field in a relations declaration. \u0026quot;properties\u0026quot;: { The 'properties' block contains the details of the relationship. \u0026quot;relType\u0026quot;: Field 'relType' is used to indicate what sort of relationship is being declared between the containing (from) entity and the toEntity. Valid values are {hasOne, hasMany and belongsTo}. This is a mandatory field. \u0026quot;toEntity\u0026quot;: Field 'toEntity' is used to specify the target entity in the relationship. The toEnity must be capitalized and provided in CamelCase that matches that used in the toEntity's declaration. The toEntity need not appear prior to the containing entity in the model file or files. This is a mandatory field. } } ] }  hasMany Relationship \u0026lsquo;hasMany\u0026rsquo; relationships establish a one-to-many relationship between two model entities. As an example, let\u0026rsquo;s posit that a Library can have many Books. If Library and Book were modeled as entities, we could declare a \u0026lsquo;hasMany\u0026rsquo; (1:N) relationship between them. The relation would be added to the \u0026lsquo;relations\u0026rsquo; block inside the Library entity definition:\n{ \u0026quot;entities\u0026quot;: [ { \u0026quot;typeName\u0026quot;: \u0026quot;Library\u0026quot;, \u0026quot;properties\u0026quot;: { \u0026quot;Name\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: true, \u0026quot;unique\u0026quot;: false, \u0026quot;index\u0026quot;: \u0026quot;nonUnique\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,like\u0026quot; }, \u0026quot;City\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: true, \u0026quot;unique\u0026quot;: false, \u0026quot;index\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,lt,gt\u0026quot; } }, \u0026quot;compositeIndexes\u0026quot;: [ {\u0026quot;index\u0026quot;: \u0026quot;name, city\u0026quot;} ], \u0026quot;relations\u0026quot;: [ { \u0026quot;relName\u0026quot;: \u0026quot;ToBooks\u0026quot;, \u0026quot;properties\u0026quot;: { \u0026quot;relType\u0026quot;: \u0026quot;hasMany\u0026quot;, \u0026quot;toEntity\u0026quot;: \u0026quot;Book\u0026quot; } } ] }, { \u0026quot;typeName\u0026quot;: \u0026quot;Book\u0026quot;, \u0026quot;properties\u0026quot;: { \u0026quot;Title\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: true, \u0026quot;index\u0026quot;: \u0026quot;nonUnique\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,like\u0026quot; }, \u0026quot;Hardcover\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;bool\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: true, \u0026quot;index\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,ne\u0026quot; }, \u0026quot;Copies\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;uint64\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: true, \u0026quot;index\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,lt,gt\u0026quot; }, \u0026quot;LibraryID\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;uint64\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: true, \u0026quot;index\u0026quot;: \u0026quot;nonUnique\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,like\u0026quot; } } } ] }  belongsTo Relationship \u0026lsquo;belongsTo\u0026rsquo; relationships are used to form the inverse of the \u0026lsquo;hasOne\u0026rsquo; and \u0026lsquo;hasMany\u0026rsquo; relations. Consider the Library \u0026lsquo;hasMany\u0026rsquo; Books example; A Library has many books, but we can also posit that \u0026lsquo;a Book belongs to a Library\u0026rsquo;; this is an example of a \u0026lsquo;belongsTo\u0026rsquo; relationship. The JSON below extends the Library -\u0026gt; Book example by adding the \u0026lsquo;belongsTo\u0026rsquo; relationship to the Book entity definition:\n{ \u0026quot;entities\u0026quot;: [ { \u0026quot;typeName\u0026quot;: \u0026quot;Library\u0026quot;, \u0026quot;properties\u0026quot;: { \u0026quot;Name\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: true, \u0026quot;unique\u0026quot;: false, \u0026quot;index\u0026quot;: \u0026quot;nonUnique\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,like\u0026quot; }, \u0026quot;City\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: true, \u0026quot;unique\u0026quot;: false, \u0026quot;index\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,lt,gt\u0026quot; } }, \u0026quot;compositeIndexes\u0026quot;: [ {\u0026quot;index\u0026quot;: \u0026quot;name, city\u0026quot;} ], \u0026quot;relations\u0026quot;: [ { \u0026quot;relName\u0026quot;: \u0026quot;ToBooks\u0026quot;, \u0026quot;properties\u0026quot;: { \u0026quot;relType\u0026quot;: \u0026quot;hasMany\u0026quot;, \u0026quot;toEntity\u0026quot;: \u0026quot;Book\u0026quot; } } ] }, { \u0026quot;typeName\u0026quot;: \u0026quot;Book\u0026quot;, \u0026quot;properties\u0026quot;: { \u0026quot;Title\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: true, \u0026quot;index\u0026quot;: \u0026quot;nonUnique\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,like\u0026quot; }, \u0026quot;Hardcover\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;bool\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: true, \u0026quot;index\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,ne\u0026quot; }, \u0026quot;Copies\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;uint64\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: true, \u0026quot;index\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,lt,gt\u0026quot; }, \u0026quot;LibraryID\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;uint64\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: true, \u0026quot;index\u0026quot;: \u0026quot;nonUnique\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,like\u0026quot; } }, \u0026quot;relations\u0026quot;: [ { \u0026quot;relName\u0026quot;: \u0026quot;ToLibrary\u0026quot;, \u0026quot;properties\u0026quot;: { \u0026quot;relType\u0026quot;: \u0026quot;belongsTo\u0026quot;, \u0026quot;toEntity\u0026quot;: \u0026quot;Library\u0026quot; } } ] } ] }  By relying on the default key determinations for the \u0026lsquo;belongsTo\u0026rsquo; relationship, the generator determines that the Book.LibraryID field should be matched against field Library.ID. If alternate keys are desired, they can be specified in the \u0026lsquo;refKey\u0026rsquo; and \u0026lsquo;foreignKey\u0026rsquo; property fields in the \u0026lsquo;belongsTo\u0026rsquo; relation declaration.\nWhat if more complex relationships are required? At the moment the generator only supports \u0026lsquo;hasOne\u0026rsquo;, \u0026lsquo;hasMany\u0026rsquo; and \u0026lsquo;belongsTo\u0026rsquo; relations, as in practice these tend to be the most widely used. The generated code can be extended to accommodate additional relationships and joins if need be. There is a tentative plan to support more complex relations in the generator in the future. Most of the supporting code is in place, but the controller_rel templates would need to be enhanced to support it. In the meantime, a combination of foreign-keys and static filters can be employed as an alternative to formally defined relationships in cases where the entity-id model is not sufficient.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/interprocess/ip-content-d/",
	"title": "Access Revocation and Renewal",
	"tags": [],
	"description": "",
	"content": " JWT Tokens and Access Revocation Jiffy applications do not support the revocation or automatic renewal of JWT tokens. Instead, the service ensures that changes to User information (create/update/delete) are disseminated to all running instances of the Jiffy generated application. This is accomplished by maintaining a cross-process cache of User information via the group-membership service.\nConsequently, in Jiffy-based applications it makes sense to discuss User access revocation from the perspective of an administrator making a call to the user-API to perform general User deletion or deactivation. Such changes are affected in the backend database, and then updated in the application server caches by way of the web-sockets-based group-membership service.\nUser Access Revocation Example Conditions\n User \u0026lsquo;tester@test.com\u0026rsquo; has access to a number of services in a Jiffy-generated application. We now wish to remove access from this user. JWT lifetime in our test system is set to 12 hours. tester@test.com has a current and valid JWT that will expire in 8 hours.  Revocation Steps\n A user with administrative privileges in the Jiffy-generated application makes a call to the Usr service of the Jiffy-generated application to deactivate the \u0026lsquo;tester@test.com\u0026rsquo; account. This call can be made to any running instance of the application. Once the Usr record has been updated in the backend the id in question will not be able to login to the application. On confirmation of the successful update to the Usr record, the Usr controller will disseminate the new status of the Usr record to the other group-members. Each group-member will update their Usr cache with the new information.  Revocation Results\n If the user attempts to login to any of the application instances, the middleware will see that the Usr has been deactivated when it checks the Usr cache and the login will be rejected. If the user has a valid JWT, but has their access revoked as described in the previous steps, all attempts to access application services will be denied.\n The JWT remains valid. The JWT contains the user\u0026rsquo;s ID. The route middleware examines the JWT Claims for every call made to the application services. The UID claim in the JWT is used by the middleware to read the Usr cache. In this example, the middleware cache will indicate that the user is no longer active. This approach allows us to focus on the maintenance and buffering of the persistent object (Usr) rather than trying to maintain/cache the transient JWT.   JWT Token Renewal It would be possible to alter the Jiffy application to create self-renewing JWT\u0026rsquo;s. Doing so would mandate that the client developer compare the Authorization field in the response header to the one that was sent in the request. For now, the strategy is to have the application configuration set a JWT validity of ~12 hours, and then force the user to login again once the time limit expires.\nOn one hand, this approach to (not supporting) JWT renewal means that the client/consumer of the RESTful services need not worry about checking the JWT content at the end of each exchange. On the other hand, the current strategy may be a concern in system-to-system interfaces especially where it is not acceptable to set a very long JWT expiry limit in the configuration.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/overview/ov-content-e/",
	"title": "Jiffy Development Steps",
	"tags": [],
	"description": "",
	"content": " Jiffy Pre-Generation Workflow Jiffy is intended to generate a clean, straight-forward and secure application services platform just like the one you would write by hand. Jiffy originally started as a few go templates I used to generate boiler-plate code that I do not like to type. Generation is a lot nicer than cut-and-paste. There are places in the generated code where things could be more elegant, but the code is intended to be easy to work on even if one is not familiar with it. File and folder names are somewhat subjective; I have tried to be descriptive and organized.\nDesign Steps  You are building a back-end of some sort where you need to reliably read and write data. Before you start building the \u0026lsquo;real\u0026rsquo; Jiffy model of your application, try some of the demo models to get a feel for what Jiffy is and what it isn\u0026rsquo;t. It is a lot easier to design if you know what the platform provides and what it does not.\n Start messing around with entity ideas. What is the best way to represent your data? Transferring your ideas into a few rough diagrams often changes your understanding of what you are modeling.\n Consider the relationships you would like to have between your entities. Does your model still hold up?\n Add some detail to your proposed entities in terms of fields. Remember that Jiffy will insert a primary-key (id), as well as a self-referencing entity href into the model for you. This is important when you are considering relationships, as Jiffy applications have some expectations regarding the name of the referencing field. See the Relations section of this documentation set for details.\n Once you are comfortable with the entities and the fields that they will contain, it is time to create the model in the Jiffy model file format.\n Jiffy model files are simple JSON and at the moment need to be coded up by hand. Taking a copy of one of the sample model-files is the best way to start. Short of creating a graphical model file generator, maintaining the models via direct file maintenance is the most direct and transparent way to edit them. Remember that you do not have to put your entire model in one file. Jiffy is quite happy to accept any number of model files for your project with the entities defined in any order. The generator will sort it all out.\n Check your model files as best as possible before feeding them into Jiffy. If you get an error, don\u0026rsquo;t worry; I get them all the time too. Look at the error message, then check the model-file for problems. If you can\u0026rsquo;t see anything wrong, log an issue and I will take a look. Usual suspects for errors are missing double-quotes on field-names or string-values, missing closing parentheses on a list, missing brace on struct or sub-struct, putting quotes on a bool value, putting quotes on an int or dec value etc.\n Again, don\u0026rsquo;t worry too much about formal inter-entity rules in the beginning. The idea is to get something up and running fast so you can try out the services. You can generate your application many times over without touching anything but the model-file / model-files. Generation is fast.\n Generate a version of your application and start it up. Try it out with a tool like Postman. See the Quickstart for an overview of application generation through to application testing, or go to the formal section dealing with each of the application creation steps.\n It is not (typically) necessary to do early development testing via https. If this is not the case for you, see the testing with https section in this document set. Step-by-step instructions are given to create and install self-signed certificates that will permit you to test locally with https.\n As you test your application, you will probably see some fields missing, some fields that you don\u0026rsquo;t care for, and maybe the need for an additional entity. Update your model files and generate the application again. Try it out. Repeat.\n As your model becomes more refined, consider formally adding relationships. Generate, test, repeat.\n Consider foreign-keys. Generate, test, repeat.\n Consider start-values for id. Not everybody is okay to start at 1, particularly if you are planning on migrating existing data into your application. Generate and test.\n Consider static-queries and add the selection options to each field that can be queried. Generate, test, repeat. See the static query section for details.\n Consider indices and add indexes to the model definitions where needed. Generate, test, repeat.\n Access restrictions can be assigned at the end-point-level, and this is built into the generated application. Don\u0026rsquo;t worry about testing authorization and authentication for now.\n  Development  When you are satisfied with your model, generate a version of the application and place it under source-code control.\n Implement extension-points in the controller and model go source as per your requirements. Implemented extension-points will not be over-written should you need to regenerate the application. Test often.\n Implement normalization and validation at the field-level in the generated entity model go source file. This part is slightly contentious, as field normalization and validation is performed directly in the generated code, rather than off to the side in extension-points. We suggest that if you are worried about over-writing your normalization and validation code with an accidental regeneration, you create a model_normalization package for each model and implement field-level normalizations and checks there. Of course, you are free to ignore the provided field-level normalization and validation methods and perform all checks in one of the model extension-points. Its up to you, and it will make more sense once you take a look through one of the generated files.\n When you are happy with the way things are working, think about user access. Sketch out user-groups and assign end-points to them until you have something that you like. Use Postman to create UserGroups and assign Auths to them, then create new users and allocate the relevant UserGroups to their ID. That is all you need to do; the Jiffy middleware will take care of the rest. See the Authentication and Authorization section for a detailed discussion of how users are authenticated and authorized.\n  Deployment Jiffy generated applications can be deployed in any number of ways. For example:\n On your laptop On a server under your desk On a blade running the os of your choice On a VM (xen etc.) Docker image / Droplet / Cloud Foundry etc. Across a collection of the above  At the software level, the Jiffy generated application can be deployed as:\n A single environment hosting the DBMS and application A single application instance talking to a database on your SAN Multiple application instances talking to a database on your SAN  Considerations for deployment  SSL certificates Do you need to support JWT\u0026rsquo;s from other SSO providers? If so, you will need their public-keys. JWT expiration policy You have tested your user-access revocation? Jiffy makes provisions for the revocation of user-access based on the user master. If a user is deleted or marked as inactive, even a valid JWT for that user will not permit access. Data migration; have you run real test migrations with the key relationships etc. in place? If you disabled certain database features for migration, have you turned them back on again? Looking at you foreign-keys\u0026hellip; User access; users have been assigned to Groups and the create/update/delete end-points are locked down in accordance with your use-cases? Do you need a reverse-proxy / is there a need to route traffic based on expected load? Service activations; is there a need to route traffic based on expected load? If you need to scale horizontally or vertically do you have a plan?  "
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/level-two/",
	"title": "Let&#39;s Test Something",
	"tags": [],
	"description": "",
	"content": "We have a running application, but what can we do with it? If you clicked on the http://127.0.0.1:8080 link at the end of the preceding section, you didn\u0026rsquo;t get a very good looking response\u0026hellip;\nJiffy services are best tested using a RESTful test utility. If you have a tool that works for you, use that to follow along. If you don\u0026rsquo;t have a test utility, Google\u0026rsquo;s Postman is a great choice and that is what we are going to use for the rest of the quick-start.\nLet\u0026rsquo;s make a quick list of things that we are going to do in order to test our new Person service.\n Login Create a new Person entity Create another new Person entity Read each Person by their key Read a list of Person entities Update a Person entity Create yet another new Person entity See what options we can add to an entity request Delete an entity  "
},
{
	"uri": "https://1414c.github.io/jiffy/generation/gn-content-e/",
	"title": "Generated &#39;models&#39; Folder",
	"tags": [],
	"description": "",
	"content": " The \u0026lsquo;models\u0026rsquo; Folder FirstApp ├── appobj │ ├── appconf.go │ └── appobj.go . . . ├── models │ ├── authm.go │ ├── errors.go │ ├── group_authm.go │ ├── modelfuncs.go │ ├── personm_ext.go │ ├── personm.go │ ├── servicesm.go │ ├── usr_groupm.go │ ├── usrm.go │ └── ext │ └── model_ext_interfaces.go ├── util │ └── strings.go ├── .dev.config.json ├── .prd.config.json ├── main_test.go └── main.go  A model is created for each entity that has been modeled in the .json files, as well as well as the static models used to support users and authorizations.\nModels define an entity\u0026rsquo;s structure and member field characteristics such as type, required/not-required, db-type etc. Each model has a corresponding controller that examines the request, parses the incoming JSON data into the model structure, and then calls the appropriate method in the entity-model based on the end-point / http method. The model provides a validator, which can be used to perform detailed checks and normalizations on the entity data prior to making the call to the ORM.\nEmpty model validations are generated for each entity field, and are designed to be extended by the application developer. Validation methods are generated for each entity field and added to the model\u0026rsquo;s entity validator. For example, the model source file for entity \u0026lsquo;Library\u0026rsquo; (./models/librarym.go), contains a \u0026lsquo;libraryValidator\u0026rsquo; type. Validation methods for each of the library entity\u0026rsquo;s fields are attached to this type.\nThe validator type also contains methods matching the public interface (LibraryDB) of the model\u0026rsquo;s service definition. The model\u0026rsquo;s service declaration includes a validator member, and due to the manner of the declaration, it is the validator that is passed back to the caller (controller) when model access is needed.\n// newLibraryValidator returns a new libraryValidator func newLibraryValidator(ldb LibraryDB) *libraryValidator { return \u0026amp;libraryValidator{ LibraryDB: ldb, } } // NewLibraryService declaration func NewLibraryService(handle sqac.PublicDB) LibraryService { ls := \u0026amp;librarySqac{handle} lv := newLibraryValidator(ls) // *db return \u0026amp;libraryService{ LibraryDB: lv, } }  In the NewLibraryService function, see that two members are declared:\n ls contains an implementation of the generated LibraryDB interface which is used to call the ORM layer following successful execution of the model\u0026rsquo;s validations lv contains an implementation of the generated LibraryDB interface, as well as the set of empty generated field validation methods  Using the creation of a new Library entity as an example, the controller will parse the JSON body of the incoming request into a Library entity struct. The controller will then call the entity\u0026rsquo;s model.Create method. The \u0026lsquo;libraryValidator.Create\u0026rsquo; method (on lv) will execute the implemented field validations, then call the service\u0026rsquo;s model.Create() method (on ls)which will in-turn make the required call to the ORM.\n// Create validates and normalizes data used in the library creation. // Create then calls the creation code contained in LibraryService. func (lv *libraryValidator) Create(library *Library) error { // perform normalization and validation -- comment out checks that are not required // note that the check calls are generated as a straight enumeration of the entity // structure. It may be neccessary to adjust the calling order depending on the // relationships between the fields in the entity structure. err := runLibraryValFuncs(library, lv.normvalName, lv.normvalCity, ) if err != nil { return err } // use method-chaining to call the library service Create method return lv.LibraryDB.Create(library) }  The last line of the method is the most interesting, as it demonstrates something known as method-chaining which allows the call to implicitly access the \u0026lsquo;ls\u0026rsquo; methods. Look carefully at the code in this area so you understand what is happening, and perhaps lookup \u0026lsquo;method-chaining\u0026rsquo; as it pertains to golang.\nNote that at the moment, validations are intended to be coded directly in the body of the generated model code. This is in contrast with the extension-point technique implemented in the controller and at the sqacService level in the model file (see Extension Points in this document). The reasons for this are as follows:\n It is expected that no validations will be coded until the model has been stabilized. It is generally desirable to get an application working (or mostly working), then start worrying about validations. Extension points exist as a convenience in the case where data needs pre/post processing. For most entities, some sort of validation will be required on the majority of fields. We treat the validations as first-class citizens in the application rather than extension-points. By treating validations as first-class citizens we do not need to use type assertion and reflection in the validation layer when performing the checks. If there is a concern regarding the over-writing of coded validations due to application regeneration, it is simple for an application developer to implement their own sub-package with methods or functions containing the check code. The Jiffy application will not over-write files that it is not responsible for during a regeneration of an application.  By default, a CRUD interface is generated for each entity. Using the Library example, the generated code for the CRUD end-points look as follows:\n// ====================== Library protected routes for standard CRUD access ====================== a.router.HandleFunc(\u0026quot;/librarys\u0026quot;, requireUserMw.ApplyFn(a.libraryC.GetLibrarys)).Methods(\u0026quot;GET\u0026quot;).Name(\u0026quot;library.GET_SET\u0026quot;) a.router.HandleFunc(\u0026quot;/library\u0026quot;, requireUserMw.ApplyFn(a.libraryC.Create)).Methods(\u0026quot;POST\u0026quot;).Name(\u0026quot;library.CREATE\u0026quot;) a.router.HandleFunc(\u0026quot;/library/{id:[0-9]+}\u0026quot;, requireUserMw.ApplyFn(a.libraryC.Get)).Methods(\u0026quot;GET\u0026quot;).Name(\u0026quot;library.GET_ID\u0026quot;) a.router.HandleFunc(\u0026quot;/library/{id:[0-9]+}\u0026quot;, requireUserMw.ApplyFn(a.libraryC.Update)).Methods(\u0026quot;PUT\u0026quot;).Name(\u0026quot;library.UPDATE\u0026quot;) a.router.HandleFunc(\u0026quot;/library/{id:[0-9]+}\u0026quot;, requireUserMw.ApplyFn(a.libraryC.Delete)).Methods(\u0026quot;DELETE\u0026quot;).Name(\u0026quot;library.DELETE\u0026quot;)  The generated go struct for the Library model looks as follows:\n// Library structure type Library struct { ID uint64 `json:\u0026quot;id\u0026quot; db:\u0026quot;id\u0026quot; sqac:\u0026quot;primary_key:inc\u0026quot;` Href string `json:\u0026quot;href\u0026quot; db:\u0026quot;href\u0026quot; sqac:\u0026quot;-\u0026quot;` Name string `json:\u0026quot;name\u0026quot; db:\u0026quot;name\u0026quot; sqac:\u0026quot;nullable:false;index:non-unique;index:idx_library_name_city\u0026quot;` City string `json:\u0026quot;city\u0026quot; db:\u0026quot;city\u0026quot; sqac:\u0026quot;nullable:false;index:idx_library_name_city\u0026quot;` }  The model structure and tags are explained:\n   Field Name Description     ID This is the generated key for the entity. The sqac tag \u0026ldquo;primary_key:inc\u0026rdquo; instructs the ORM that this field is to be created as an auto-incrementing column in the backend DBMS.   Href Each entity has an Href field injected into its structure when the application is generated. The Href value provides a direct link to read, update or delete the represented entity. This can be useful if the entity was returned as part of a list, or via a relation-based request. Changes to entities must be carried out via the direct links rather than through relation-type requests. Enforcement of this precludes the requirement of coding / executing additional checks during updates to makes sure that the relationship path is valid. Authorization for end-point access is also simplified via this model. Sqac tag \u0026ldquo;-\u0026rdquo; indicates that this field is not persisted on the database and is not included in the table schema.   Name Name is a field from the model file, and has the following attributes in the backend DBMS based on the sqac tag-values: Not nullable, has a non-unique btree index, is part of a composite (non-unique) index consisting of the \u0026lsquo;name\u0026rsquo; and \u0026lsquo;city\u0026rsquo; table columns.   City City is a field from the model file, and has the following attributes in the backend DBMS based on the sqac tag-values: Not nullable, is part of a composite (non-unique) index consisting of the \u0026lsquo;name\u0026rsquo; and \u0026lsquo;city\u0026rsquo; table columns.    For a more complete explanation of the Sqac ORM tags and operation, see the README.md of the sqac library at: https://github.com/1414C/sqac\nThe models folder also contains an \u0026lsquo;ext\u0026rsquo; sub-directory which is used to hold the interface definitions for model extension-points. See the \u0026lsquo;Extension Points\u0026rsquo; section of this document for more details.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/generation/gn-content-f/",
	"title": "Generated &#39;middleware&#39; Folder",
	"tags": [],
	"description": "",
	"content": " The \u0026lsquo;middleware\u0026rsquo; Folder FirstApp ├── appobj │ ├── ... │ └── ... . . . ├── middleware │ └── requireuser.go . . . ├── .dev.config.json ├── .prd.config.json ├── main_test.go └── main.go  The middleware folder contains all of the code related to the application the of Authentication and Authorization concepts discussed in the \u0026lsquo;Access Control Overview\u0026rsquo; and \u0026lsquo;Authorizations \u0026amp; End-Point Security\u0026rsquo; sections of this document.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/generation/gn-content-g/",
	"title": "Generated &#39;jwtkeys&#39; Folder",
	"tags": [],
	"description": "",
	"content": " The \u0026lsquo;jwtkeys\u0026rsquo; Folder FirstApp ├── appobj │ ├── ... │ └── ... . . . ├── jwtkeys │ ├── ecdsa256 │ │ ├── ecdsa.priv.pem │ │ └── ecdsa.pub.pem │ ├── ecdsa384 │ │ ├── ecdsa384.prive.pem │ │ └── ecdsa384.pub.pem │ ├── ecdsa521 │ │ ├── ecdsa521.priv.pem │ │ └── ecdsa521.pub.pem │ ├── rsa256 │ │ ├── rsa.priv.pem │ │ └── rsa.pub.pem │ ├── rsa384 │ │ ├── rsa384.prive.pem │ │ └── rsa384.pub.pem │ └── rsa512 │ ├── rsa512.priv.pem │ └── rsa512.pub.pem . . . ├── .dev.config.json ├── .prd.config.json ├── main_test.go └── main.go  The jwtkeys folder contains the public and private keys that are generated in order to support the use of JWT tokens. Jiffy generates public/private keys for all supported JWT signing algorithms. It would probably be okay to place the keys into a common location, as they are only read once by each application instance during its initialization. JWT\u0026rsquo;s and key usage are discussed in greater detail in the \u0026lsquo;Authorizations \u0026amp; End-Point Security\u0026rsquo; section of this documentation.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/generation/gn-content-h/",
	"title": "Other Generated Folders",
	"tags": [],
	"description": "",
	"content": " The \u0026lsquo;ext\u0026rsquo; Folders \u0026lsquo;ext\u0026rsquo; folders contain Jiffy application interface definitions and empty implementations of the same for controller and model extension-points. See the \u0026lsquo;Extension Point\u0026rsquo; section of this documentation.\nThe group/gmcl Folder The group/gmcl folder contains the source files for the usr, auth, usrgroup and groupauth cache clients. This package is for internal use only. See the \u0026lsquo;Group Membership\u0026rsquo; and \u0026lsquo;Failure Detection\u0026rsquo; sections of this documentation.\nThe group/gmcom Folder The group/gmcom folder contains source files holding artifacts that are needed by the groups/\u0026hellip; packages and those of the generated jiffy application. This package is for internal use only. See the \u0026lsquo;Group Membership\u0026rsquo; and \u0026lsquo;Failure Detection\u0026rsquo; sections of this documentation.\nThe group/gmsrv Folder The group/gmsrv folder contains the source files for the group-membership service, the failure detector and the leader-election mechanism. This package is for internal use only. See the \u0026lsquo;Group Membership\u0026rsquo; and \u0026lsquo;Failure Detection\u0026rsquo; sections of this documentation.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/level-two/l2-content-a/",
	"title": "Login",
	"tags": [],
	"description": "",
	"content": "Launch Postman and specify a target URL of: http://127.0.0.1:8080/usr/login making sure to select the http POST method. Maintain the request body to provide a user-id and password as shown in the following JSON snippet. Typically the user-id for a jiffy application is an email address, but we make an exception for the default administration user.\n{ \u0026quot;email\u0026quot;: \u0026quot;admin\u0026quot;, \u0026quot;password\u0026quot;: \u0026quot;initpass\u0026quot; }  \nWhen you have finished and your Postman (or other test utility) looks like the following image, click the \u0026lsquo;Send\u0026rsquo; button to post your login request to the running application.  If all goes well, you will get a http response code of 200 (status ok), and a block of JSON with a single \u0026lsquo;token\u0026rsquo; tag containing a jumble of letters and numbers. This is the JWT that will be used to validate our authorization to access the Person entity\u0026rsquo;s service end-points. If you want to read more about JWT\u0026rsquo;s, jwt.io is a good place to start, or you can refer to the Authentication and Authorization sections of this document set. "
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/level-two/l2-content-b/",
	"title": "Create a Person",
	"tags": [],
	"description": "",
	"content": "Now that we have successfully logged into the application and received our first JWT, it is time to create a new Person entity. Start by copying the content of the \u0026lsquo;token\u0026rsquo; tag from the login response body to the clipboard. This JWT must henceforth be included in the http header of every subsequent request.\nCreate a new tab in Postman and specify a target URL of http://127.0.0.1:8080/person with the http POST method. Next, add the following key-value pairs to the http header:\n Content-Type : application\\json Authorization : Bearer *paste-your-JWT-here*  When you have finished maintaining the http header-values, click on \u0026lsquo;Body\u0026rsquo; and maintain it using the \u0026lsquo;raw\u0026rsquo; setting. This will allow you to paste the following JSON code snippet into the request\u0026rsquo;s body:\n{ \u0026quot;name\u0026quot;: \u0026quot;Steve Dallas\u0026quot;, \u0026quot;age\u0026quot;: 46, \u0026quot;weight\u0026quot;: 185, \u0026quot;valid_license\u0026quot;: true, \u0026quot;license_class\u0026quot;: \u0026quot;A\u0026quot; }  \nWhen you have finished, the test session should look as follows and it is time to create our first Person entity. Click \u0026lsquo;Send\u0026rsquo; to post the new entity to the application.\n\nCongratulations! You have created your first Person entity!\nThe router matched the request URL to a route (service end-point), the middleware layer in the matched route examined the JWT, verified it was okay to proceed and then passed the raw JSON from the request body to the Person entity\u0026rsquo;s controller. The controller unmarshalled the JSON into a Person struct and then passed the result to the Create method in the model/validation layer. Validation of the Person struct\u0026rsquo;s content occurred, and then a call was made to the underlying ORM to create the entity on the database.\nThe ORM-layer returned the new entity to the application\u0026rsquo;s model-layer, where it was checked and passed back to the controller layer, whereupon it was serialized (struct content becomes JSON) and written to the the response-writer.\nThis is a high-level view of what transpired, but the general flow of things is accurate.\nNotice that the entity passed back to us seems to have a couple of extra fields? All entities created via a jiffy model file are injected with a primary-key of \u0026lsquo;id\u0026rsquo; as well as a non-persistent \u0026lsquo;href\u0026rsquo; field. In this example, our entity\u0026rsquo;s \u0026lsquo;id\u0026rsquo; field was specified to be auto-incrementing with a starting value of 10000000. See the sqac-tag section in the documentation for details regarding key options.\nHref is included in each entity\u0026rsquo;s GET responses, and acts as a self-reference providing the entity\u0026rsquo;s direct access URI to the consumer.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/level-two/l2-content-c/",
	"title": "Create Another Person",
	"tags": [],
	"description": "",
	"content": "Let\u0026rsquo;s change a few things in our request-body and create another Person entity. Edit the JSON body in the request section of your Postman session and click \u0026lsquo;Send\u0026rsquo; when you are ready.\n\nAnother Person entity has been created.\n\nCreate one more Person entity so we have three (or more) in total.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/level-two/l2-content-d/",
	"title": "Get Some Persons",
	"tags": [],
	"description": "",
	"content": "So far we have created two Person entities. We have observed that upon successful creation of an entity, a JSON representation of that entity is passed back to us via the response-writer. Let\u0026rsquo;s now look at how we can get a list of all of our Person entities.\nCreate a new tab in Postman and specify a target URL of http://127.0.0.1:8080/persons making sure to select the http GET method. Next, add the following key-value pair to the http header:\n Authorization : Bearer *paste-your-JWT-here*  When you have finished, the test session should look as follows and it is time to read some Person entities from the database. Click \u0026lsquo;Send\u0026rsquo; to issue our read request to the application.\n\nWe just read the complete list of Person entities. Adding an \u0026rsquo;s\u0026rsquo; to the entity name and issuing the request with a GET http verb tells a jiffy application to read all of the Person entities. In some cases this looks odd, but it makes it quite easy to consume the services. Notice that the \u0026lsquo;href\u0026rsquo; field of each Person entity provides a direct link to the entity that it is a part of.\n\n"
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/level-two/l2-content-e/",
	"title": "Get a Person",
	"tags": [],
	"description": "",
	"content": "What if we need to read a single Person, or isolate a Person entity from a list of entities? Let\u0026rsquo;s try reading a Person entity using its \u0026lsquo;id\u0026rsquo; key.\nCreate a new tab in Postman and specify a target URL of http://127.0.0.1:8080/person/10000001 making sure to select the http GET method. Next, add the following key-value pair to the http header:\n Authorization : Bearer *paste-your-JWT-here*  When you have finished, the test session should look as follows and it is time to read Person 10000001 from the database. Click \u0026lsquo;Send\u0026rsquo; to issue our read request to the application.\n\nWe just read the Person entity with \u0026lsquo;id\u0026rsquo; key 10000001. While this is not a very human-friendly way to search for a Person, it is a simple way to isolate and reference an entity for reading, updating or deletion.\n\n"
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/level-two/l2-content-f/",
	"title": "Update a Person",
	"tags": [],
	"description": "",
	"content": "If you have been following along, we have created Person entities, read Person entities both in bulk and by \u0026lsquo;id\u0026rsquo; key. We are now going to take a look at updating an existing entity.\nRead Person entity 10000001 from the database as shown in the Get a Person example.\nOnce you have successfully read Person entity 10000001 into your Postman session, copy the content of the response body to your clipboard. We are going to reuse our GET Person Postman tab to perform an update, so change the http verb from GET to PUT. Changing the http verb to PUT will allow us to maintain the request-body in our Postman tab. Next, add the following key-value pair to the http header:\n Content-Type : application\\json  Now paste the GET Person response-body into the request-body of our new PUT request, then edit it so that Opus\u0026rsquo;s full name is given. Strictly speaking, you do not need to include the \u0026lsquo;id\u0026rsquo; or \u0026lsquo;href\u0026rsquo; fields in an update, but it does not hurt anything to do so.\n{ \u0026quot;id\u0026quot;: 10000001, \u0026quot;href\u0026quot;: \u0026quot;http://127.0.0.1:8080/person/10000001\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Opus the Penguin\u0026quot;, \u0026quot;age\u0026quot;: 8, \u0026quot;weight\u0026quot;: 385, \u0026quot;valid_license\u0026quot;: false }  \nWhen you have finished, you should have something that looks as follows. Click \u0026lsquo;Send\u0026rsquo; to issue the PUT request to the application.\n\nThe PUT request should update the entity using the \u0026lsquo;id\u0026rsquo; key as its update criteria, and then return a JSON representation of the updated entity. This is a little different than other approaches, where the result of an update is measured simply by the http response code. If you don\u0026rsquo;t like the way this works, it is very easy to update the generated source code to omit the response body following a PUT.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/level-two/l2-content-g/",
	"title": "Get Persons With Restrictions",
	"tags": [],
	"description": "",
	"content": "We have seen how to Create, Get, and Update a Person entity, but before we get around to the Delete operation, let\u0026rsquo;s take a quick look at some other simple things we can do with Get entity lists.\n  Get a count of Person entities in the database   http://127.0.0.1:8080/persons/$count .\n    Get all Person entities in the database ordered-by age   http://127.0.0.1:8080/persons$orderby=age .\n \n  Get all Person entities in the database ordered-by age descending   http://127.0.0.1:8080/persons$orderby=age$desc .\n \n  Get all Person entities in the database ordered-by age descending with a selection offset of 1   http://127.0.0.1:8080/persons/$orderby=age$desc$offset=1 .\n \n  Get all Person entities in the database ordered-by age descending with a limit of 2   http://127.0.0.1:8080/persons/$orderby=age$desc$limit=2 .\n \n  Get all Person entities in the database with name like %qui%   http://127.0.0.1:8080/persons/name(LIKE 'qui') .\n \n  Get all Person entities in the database with age equal to 46   http://127.0.0.1:8080/persons/$age(EQ 46) .\n \n"
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/level-two/l2-content-h/",
	"title": "Delete a Person",
	"tags": [],
	"description": "",
	"content": "Time to delete one of our Person entities. Create a new tab in Postman and specify a target URL of http://127.0.0.1:8080/person/10000000 with the http DELETE method. Next, add the following key-value pairs to the http header:\n Content-Type : application\\json Authorization : Bearer *paste-your-JWT-here*  When you have something that looks as follows, click the \u0026lsquo;Send\u0026rsquo; button to issue the delete request to the application.\nIf the delete request was successful, you will see a http response-code of 202 (Accepted). Try to read the entity by converting your delete request into a get request and verify that Person entity 10000000 has truly been deleted.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/level-two/l2-content-i/",
	"title": "Next Steps",
	"tags": [],
	"description": "",
	"content": "That is a quick overview of the sort of things you can do with an application generated by Jiffy. There is a lot more to see however!\nGood places to start would be in the Jiffy Overview and the Model File section.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/",
	"title": "",
	"tags": [],
	"description": "",
	"content": " Jiffy RESTful Services Generator Jiffy is a model-based RESTful application services generator written in Go. Jiffy processes model files to generate Go source code for a complete backend services application. It was originally developed as an experiment to offer an alternative avenue when developing native applications for SAP Hana. The Jiffy application allows a developer to treat the data persistence layer as an abstraction, thereby removing the need to make use of CDS and the SAP XS(A) libraries.\nWhile this is not for everybody, it does reduce the mental cost of entry and allows deployment of a web-based application on SAP Hana with virtually no prior Hana knowledge. Jiffy also works nicely with other databases.\nMain Features  generated applications can be connected to Postgres, MSSQL, SAP Hana, SQLite or MariaDB with no source-code changes no database specific code is compiled into the binary bcrypt salt/pepper based authentication scheme session management and end-point authorizations are provided via jwt built-in support for the creation of jwt signing-keys service end-points are secured by way of jwt claims in the route handler middleware service end-point security is generated by default, along with corresponding authorization objects uses JSON model file(s) for Entity, Index, Relationship and Foreign-Key definitions generates a set of CRUD-type RESTful services for each entity in the model file(s) built-in support for https getSet type end-points support /$count, $limit=n, $offset=n, $orderby=field_name ($asc|$desc) generates end-points for hasOne, hasMany and belongsTo entity relationships generates static query end-points each entity\u0026rsquo;s corresponding service can be enabled and disabled on a per process basis generated models support persistent and non-persistent fields generated apps create and alter backend database artifacts based on model definitions baked in normalization and validation in the model-layer generates a comprehensive set of working tests via go test generated code is easily extended either via direct editing, or through an extension-point concept is designed to be deployed across multiple VM\u0026rsquo;s or containers by way of a leader-election and failure detection subsystem utilizes an internally replicated cache for user, user-group and authorization artifacts entity caching can be easily extensible via enhancement-points in the controller or model layers (redis / memcached for example)  "
},
{
	"uri": "https://1414c.github.io/jiffy/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://1414c.github.io/jiffy/credits/",
	"title": "Credits",
	"tags": [],
	"description": "",
	"content": " Contributors Thanks to them  for making Open Source Software a better place !\nPackages and libraries  sqlx jwt-go go-sql-driver/mysql lib/pq go-sqlite3 go-mssqldb go-hdb  Tooling  Hugo Hugo Learn Theme  "
},
{
	"uri": "https://1414c.github.io/jiffy/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]