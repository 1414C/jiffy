[
{
	"uri": "https://1414c.github.io/jiffy/getting-started/gs-content-a/",
	"title": "Go Environment",
	"tags": [],
	"description": "",
	"content": "If you already have Go installed and know that your installation is working, you should skip to the next section. If you need to get Go installed on your machine, keep reading.\nGo is easy to setup and can be installed from source or binary package, both which are available at golang.org.\n Go binary installation instructions Go build-from-source installation instructions  "
},
{
	"uri": "https://1414c.github.io/jiffy/overview/",
	"title": "Jiffy Overview",
	"tags": [],
	"description": "",
	"content": " Overview and Features Jiffy "
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/",
	"title": "Getting Started",
	"tags": [],
	"description": "",
	"content": " Getting Started Initial Setup Before we get start generating services, there are few things to get out of the way. First we need to make sure that the Go environment is setup, then we need to get jiffy installed.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/installation/",
	"title": "Jiffy Installation",
	"tags": [],
	"description": "",
	"content": " Installation and Dependencies Jiffy "
},
{
	"uri": "https://1414c.github.io/jiffy/execution/",
	"title": "Jiffy Execution",
	"tags": [],
	"description": "",
	"content": " Execution Options Jiffy "
},
{
	"uri": "https://1414c.github.io/jiffy/models/",
	"title": "Model Maintenance",
	"tags": [],
	"description": "",
	"content": " Model Maintenance Jiffy "
},
{
	"uri": "https://1414c.github.io/jiffy/generation/",
	"title": "Generation",
	"tags": [],
	"description": "",
	"content": " Application Generation Jiffy "
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/gs-content-b/",
	"title": "Installing Jiffy",
	"tags": [],
	"description": "",
	"content": "The easiest way to install Jiffy is to use go get on the command-line to pull the latest version from github, as shown below:\n$ go get -u github.com/1414C/jiffy  This will pull the jiffy github repository into your $GOPATH/src/github.com folder, as well as any dependencies referenced by the jiffy source code. The -u flag is included to instruct go get to check for and pull updates to jiffy packages and their dependencies. This is the least sophisticated way of managing dependencies in go.\nOnce the jiffy source code and dependencies have been installed into your $GOPATH, you can use go build to compile a binary from the jiffy sources. The easiest way to do this is to open a terminal window, switch to $GOPATH/src/github.com/1414C/jiffy and run go build as shown below.\n$ go build -v  This will result in the creation of a binary file called \u0026lsquo;jiffy\u0026rsquo;. You may move the \u0026lsquo;jiffy\u0026rsquo; binary anywhere in your $PATH, but convention would have you install it in /usr/local/bin. Once you have moved the \u0026lsquo;jiffy\u0026rsquo; binary to its new home, open a new terminal window and use the which command to ensure that you can access the binary.\n$ which jiffy -a  If which cannot find the jiffy binary (or finds the wrong one!), you need to make sure that your $PATH is set correctly.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/generation/gn-content-a/",
	"title": "Generation Overview",
	"tags": [],
	"description": "",
	"content": " Jiffy Application File Structure Running the Jiffy generator creates a set of files that comprise a basic working backend services application. Jiffy generates the follwing source code when provided with a model-file describing a simple \u0026lsquo;Person\u0026rsquo; entity. The structure and files look more or less standard if you are used to looking at such things. Explanations of each folder and its content are discussed thoughout the documentation.\nFirstApp ├── appobj │ ├── appconf.go │ └── appobj.go ├── controllers │ ├── authc.go │ ├── controllerfuncs.go │ ├── groupauthc.go │ ├── person_relationsc.go │ ├── personc.go │ ├── usrc.go │ ├── usr_groupc.go │ └── ext │ ├── extc_interfaces.go │ └── personc_ext.go ├── group │ ├── gmcl │ │ ├── gmclient.go │ ├── gmcom │ │ ├── gmcache.go │ │ ├── gmclsrv.go │ │ ├── gmerrors.go │ │ └── gmomap.go │ └── gmsrv │ ├── gmprocessors.go │ ├── gmprotocol_senders.go │ ├── gmserver.go │ └── gmtxrx.go ├── jwtkeys │ ├── private.pem │ └── public.pem ├── middleware │ └── requireuser.go ├── models │ ├── authm.go │ ├── errors.go │ ├── group_authm.go │ ├── modelfuncs.go │ ├── personm_ext.go │ ├── personm.go │ ├── servicesm.go │ ├── usr_groupm.go │ ├── usrm.go │ └── ext │ └── model_ext_interfaces.go ├── util │ └── strings.go ├── .dev.config.json ├── .prd.config.json ├── main_test.go └── main.go  Basic Application Flow Incoming requests are handled by a mux, which validates / authenticates the request, and then matches it to a route. The selected route passes the request to a controller specific to the entity-type, where the incoming information is mapped into a go struct matching the entity declaration. The controller then calls the appropriate model function for the http operation and entity-type combination, passing it the entity structure. The model handler passes the entity struct through a member-field validation layer, and then to the model\u0026rsquo;s interface to the underlying sqac ORM. The database request is handled by the ORM, and then the response is passed from the model back to the controller where it is packaged as a JSON payload and sent back to the caller in the response-writer\u0026rsquo;s body.\nJiffy applications contain an embedded leader-based group-membership sub-system that is used for interprocess communication when the generated jiffy application is deployed as multiple processes.\n When a jiffy application is deployed as more than one process, there is a need for changes to users, auths, groups and group/auth associations to be communicated to all running instances. These common application entities are cached locally on each running instance in order to avoid accessing the database uneccessarily. An internal subsystem was chosen in order to avoid dependencies on external solutions like redis/memcached etc. Given that there is interprocess communication for the cache updates, the status of the group members must be tracked. The subsytem uses a SWIM (Scalable Weakly-Consistent Infection-Style Process-Membership) protocol to check and disseminate the statues of the group\u0026rsquo;s processes. A ping is sent from each process to every other known process in the group in random order once per ping-cycle. The ping message contains a piggybacked process-map containing the pinging process\u0026rsquo;s view of the world in terms of process status. Processes may have one of the following three statuses (ALIVE, SUSPECT, FAILED), as well as a status count indicating how many times the pinging process has noted that a process is in a particular state.  See the Group Membership section of this document for a detailed overview of the group-membership subsystem.\nThere are more elegant ways to express certain aspects of the generated application. The coding style has been deliberately kept as simple and straight-forward as possible in order to facilitate easier understanding and adjustment of the generated code.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/models/mo-content-a/",
	"title": "Model Overview",
	"tags": [],
	"description": "",
	"content": " Model Files Model files contain the Entity, Index and Relation definitions that you wish to generate services for. Entity model defintion consists of an array of JSON objects, with each object being limited to a flat hierarchy and basic go-data-types, (although this is easily extended). By default, the Jiffy generator expects a models.json file in the execution directory, but a correctly formatted JSON file can be loaded from any location by executing with the -m flag.\nIt is possible to use more than one model-file, as long as there is no duplication of entity definitions across files. Model files may be loaded in any order, but the complete set of files must be loaded at the same time. As an example, it would be fine to create three model files; Library.json, Book.json, LibraryCard.json, but all three files should be complete and processed at the same time via the -mf flag in order to allow the correct generation of relationships etc.\nSample models.json files are installed with the application and can be found in the support/testing_models folder of the Jiffy source tree. The sample models are used as the basis for the following sections.\nSimple Single Entity Model The following JSON illustrates the defintion of a simple single-entity model file. In this case, a model entity called \u0026lsquo;Person\u0026rsquo; will be created in the generated application, along with corresponding database table \u0026lsquo;person\u0026rsquo;. Table \u0026lsquo;person\u0026rsquo; will be created (if it does not already exist) when the application is started for the first time. See the application startup sequence section of this document for details regarding database artifact creation and updates.\n{ \u0026quot;entities\u0026quot;: [ { \u0026quot;typeName\u0026quot;: \u0026quot;Person\u0026quot;, \u0026quot;id_properties\u0026quot;: { \u0026quot;start\u0026quot;: 10000000 }, \u0026quot;properties\u0026quot;: { \u0026quot;name\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;db_type\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;no_db\u0026quot;: false, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: false, \u0026quot;unique\u0026quot;: false, \u0026quot;index\u0026quot;: \u0026quot;nonUnique\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,like\u0026quot; }, \u0026quot;age\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;uint\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: false, \u0026quot;unique\u0026quot;: false, \u0026quot;index\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,lt,gt\u0026quot; }, \u0026quot;weight\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;float64\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: false, \u0026quot;unique\u0026quot;: false, \u0026quot;index\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,lt,le,gt,ge\u0026quot; }, \u0026quot;validLicense\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;bool\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: false, \u0026quot;unique\u0026quot;: false, \u0026quot;index\u0026quot;: \u0026quot;nonUnique\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,ne\u0026quot; } } } ] }  The simpleSingleEntityModel.json file structure and content is explained below:\n{ \u0026quot;entities\u0026quot;: [ The 'entities' block contains an array of entities belonging to the application model. Each entity relates directly to a database table (or view). Entities contain information that the application generator uses to create and update database artifacts such as tables, indexes, sequences and foreign-keys, as well as information informing the application runtime of the member field properties. This is a mandatory model element. { \u0026quot;typeName\u0026quot;: \u0026quot;Person\u0026quot; Field 'typeName' refers to the name of an entity. It should be capitalized and written in CamelCase. An Entity given a typeName of \u0026quot;Person\u0026quot; will result in an internal model object of type Person and a database table called 'person'. This is a mandatory model element. \u0026quot;id_properties\u0026quot;: { The 'id_properties' block contains a single entry for now, and is used to provide guidance to the application generator regarding the setup of the entity's ID field. This is an optional model element. \u0026quot;start\u0026quot;: 10000000, Field 'start' can be used to provide a starting point for an entity's ID field. This is a mandatory model element if the 'id_properties' block has been included in the model. }, \u0026quot;properties\u0026quot;: { The 'properties' block contains 1:n entity member field definitions. Member fields should be defined in camelCase and can start with a lower or upper-case character. In the context of the \u0026quot;entity\u0026quot; with a 'typeName' of 'Person', 'properties' refer to the data fields of the generated \u0026quot;Person\u0026quot; model structure. 'properties' are a collection of free-form name-tags, each with a child-block containing the 'property' attributes. This is a mandatory model element. The \u0026quot;name\u0026quot; property block is described below: \u0026quot;name\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, Field 'type' in a 'properties'-\u0026gt;'name' JSON-block refers to the go data-type associated with the current 'property'. 'type' is a mandatory field in an \u0026quot;entity\u0026quot; 'property' block. \u0026quot;dbtype\u0026quot;: \u0026quot;varchar(100)\u0026quot;, Field 'dbtype' can be used to specify a native db-field-type for the property. This feature can be useful if for example, the developer is confident that a string will never exceed 100 characters in length. Care should be taken to ensure that the specified DB-Type is consistent with the go-type that will be generated in the model.\u0026lt;Entity\u0026gt; defintion in the application. Consider also that making use of this field to some extent limits the backend portability of the generated code. For example, not all database systems have a TINYINT data-type, so specifying a 'db_type' of TINYINT could be problematic if multiple database systems are being used for testing. This is an optional field. \u0026quot;no_db\u0026quot;: Field 'no_db' can be used to instruct the generator to create the field as a member in the enitity struture, but to prevent the field from being persisted to the backend database. Data like passwords for example should never be persisted to the database, but it handy to have in the user entitiy definition to help with the login process. Non-persisted fields are not created in the database table schemas, and values passed into the application are wiped from their respective internal structures following use. \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, Field 'format' is not currently used, but is intended to deal with field conversion from strings / floats to timestamp formats etc. This is an optional field. \u0026quot;required\u0026quot;: false, Field 'required' is used to instruct the generator to set a 'NOT NULL' database constraint on the column related to the property. Allowed values include {true, false}. This is a mandatory field. \u0026quot;unique\u0026quot;: false, Field 'unique' is used to instruct the database not to accept duplicate values in the database column related to the property. Setting this field to true will cause a 'UNIQUE' constraint to be applied to the related database column. Allowed values include {true, false}. This is a mandatory field. \u0026quot;index\u0026quot;: \u0026quot;nonUnique\u0026quot;, Field 'index' is used to instruct the database to create an index on the db table-column related to the property. See the 'indexes' element in the type definition for the creation of compound indices. Allowed values include {\u0026quot;unique\u0026quot;, \u0026quot;nonUnique\u0026quot;, \u0026quot;\u0026quot;}. This is an optional field. \u0026quot;selectable\u0026quot;: \u0026quot;eq,like\u0026quot; Field 'selectable' can be used to instruct the code-generator to create simple REST query accessor routes for the current 'property'. The generator creates routes to permit GET operations that can be called based on the entity 'typeName' and 'property' values. Allowed values include {\u0026quot;EQ\u0026quot;, \u0026quot;eq\u0026quot;, \u0026quot;LT\u0026quot;, \u0026quot;lt\u0026quot;, \u0026quot;GT\u0026quot;, \u0026quot;gt\u0026quot;, \u0026quot;GE\u0026quot;, \u0026quot;ge\u0026quot;, \u0026quot;LIKE\u0026quot;, \u0026quot;like\u0026quot;, \u0026quot;NE\u0026quot;, \u0026quot;ne\u0026quot;, \u0026quot;\u0026quot;} Additional restrictions are imposed based on the 'type' field value. For example, a bool type need not support LT or GT operators. Sample routes for Person-\u0026gt;Name selection with \u0026quot;eq,like\u0026quot; are shown: https://localhost:\u0026lt;port\u0026gt;/persons/name(EQ '\u0026lt;sel_string\u0026gt;') https://localhost:\u0026lt;port\u0026gt;/persons/name(LIKE '\u0026lt;sel_string\u0026gt;') Note that this is not the same thing as filtering insofar as setting the selectable options results in the creation of parameterized static routes in the application mux. }, \u0026quot;age\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;uint\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: false, \u0026quot;unique\u0026quot;: false, \u0026quot;index\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,lt,le,gt,ge,ne\u0026quot; }, ... ... }, } }, { ... next entity definition } ] }  Entity ID The ID field is visibly absent from the preceding entity declarations. The original intent was to support any name for the primary key / resource identifier of an entity. While it is possile to do this, it seems that ID is the universal \u0026lsquo;non-standard\u0026rsquo; way of representing object identifiers in RESTful-type services, so we went with it. As a result, ID is injected into the model defintion of every entity as a uint64 field and is marked as the primary-key in the database backend. By default, the ID is created as an auto-incrementing column in the DBMS, but this functionality can be suppressed (future). The ability to allow a specific starting point for the ID key range is supported via the entity header-level \u0026ldquo;start\u0026rdquo; value.\nIf the ID field really needs to be known as CustomerNumber for example, the generated code can be edited in a few locations to support the change. It is worth mentioning that the number of edits required to rename \u0026lsquo;ID\u0026rsquo; increases in direct relation to the number and complexity of entity relations (both to and from).\nAs an alternative to renaming ID, it is also conceivable that it can be ignored. Ignoring the ID means that the generated CRUD controller/model/routes are not as useful as they could be, but they offer a great starting point for your own coding. Entities can be defined with column constraints that mimic those of DBMS primary / complex keys, then the generated CRUD artifacts based on ID can be ignored, copied then ignored, or modified to accmodate the modelled entities.\nIt is also possible to go completely custom and write your own models and controllers from scratch using a generated model as a reference template. In addition to exposing a generic internal CRUD interface to the backend, the more interesting go/sql calls are exposed internally along with some lightly wrapped and super useful calls from jmoirons widely used sqlx package.\nhttps://github.com/jmoiron/sqlx\nhttp://jmoiron.github.io/sqlx/\nAlthough Jiffy eschews non-standard lib packages wherever possible, sqlx is really great.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/execution/ex-content-a/",
	"title": "Running Jiffy",
	"tags": [],
	"description": "",
	"content": " Execution In order to run the application generator, ensure the following:\n Make sure go has been installed in the test environment. See http://www.golang.org for installation files and instructions.\n Make sure that the Jiffy source code and dependencies have been installed: Jiffy Installation\n You will need access to a Postgres, MySQL, MSSQL or SAP Hana database, either locally or over the network. It is also possible to run tests with SQLite3.\n Jiffy can be started in two ways:\n From $GOPATH/src/github.com/1414C/jiffy you may execute the application directly from the Jiffy source code as follows.   $ go run main.go   A binary can also be built from $GOPATH/src/github.com/1414C/jiffy by typing the following.  $ cd $GOPATH/src/github.com/1414C/jiffy $ go build . $ ./jiffy   "
},
{
	"uri": "https://1414c.github.io/jiffy/installation/ov-content-a/",
	"title": "Jiffy Dependencies",
	"tags": [],
	"description": "",
	"content": " What does Jiffy need to run? Wherever possible and reasonable, Jiffy relies on packages found in the Go standard library. As of this writing, Go version 1.10 is required in order to build the Jiffy binary.\nDatabase Drivers The following golang database drivers are required, even if you are only planning to make use of one of the DBMS\u0026rsquo;s in the supported list. This is due to the fact that Jiffy attempts to connect to your test database during the code generation process and there is no guarantee what that database may be. It is possible that a developer tests with SQLite locally when generating the code and performing initial tests, but intends to ultimately connect to Postgres.\n github.com/SAP/go-hdb/driver github.com/denisenkom/go-mssqldb github.com/go-sql-driver/mysql github.com/lib/pq github.com/mattn/go-sqlite3  The database drivers need to be pulled down from their respective repositories via the go get command. The latest version of each should be fine.\ngo get -u github.com/lib/pq  Sqac ORM Jiffy also requires the sqac ORM. This should be pulled down automatically during the Jiffy installation process, but can also be manually installed using go get as shown below.\ngo get -u github.com/1414C/sqac  See the sqac ORM README.md file for verification and testing instructions.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/overview/ov-content-a/",
	"title": "What is Jiffy?",
	"tags": [],
	"description": "",
	"content": " What does Jiffy do? Jiffy is a model-based RESTful application services generator written in go. Think of Jiffy as an accelerator. Jiffy generates a complete backend services application for you, and that generated application is what you will run in production.\nJiffy allows a developer to generate a robust go-based application that treats the data persistence layer in a generic manner. This allows the generated application to connect to number of different database systems (outlined below), without any code changes. Generated applications can be targeted at SAP Hana; Postgres, MySQL, MSSQL or SQLite simply by updating one configuration file.\nWhy write in Go?  Go has a good standard library, thereby keeping dependencies on public packages to a minimum Go offers concurrency via lightweight threads known as goroutines  no blocking in the i/o layer during compute intensive tasks no lost callbacks or broken promises goroutines will use all available cores to handle incoming requests  Go offers type-safety Go is a small language Go projects compile to a static single binary which simplifies deployments Go cross-compiles to virtually any platform and architecture; write and test on a chromebook - deploy to amd64/ppc64/arm64/s390  What does a Jiffy application provide out of the box? Jiffy consumes simple JSON model-files and uses them to generate a working, secure and extensible application server codebase. Generated applications need no additional coding to run, although it would probably be a good idea to implement some validations and do a bit of testing before you roll things out.\nHere are some of the features that are automatically included in a generated Jiffy application:\n generated applications can be connected to Postgres, MSSQL, SAP Hana, SQLite or MariaDB no database specific code is compiled into the binary; an app can be pointed from SQLite to SAP Hana with no code changes login / authorization management via JWT built-in support for the creation of signing-keys for JWT (RS256, RS384, RS512, ES256, ES384, ES521) supports JWT\u0026rsquo;s created by other IDP\u0026rsquo;s (RS256, RS384, RS512, ES256, ES384, ES521) bcrypt salt/pepper based authentication scheme where passwords are never stored in the db JSON configuration (model) file(s) for Entity, Index, Foreign-Key and Relationship definitions models support persistent and non-persistent fields generated apps create and alter database artifacts based on the model file (tables, indices, sequences etc.) supports single and composite index declarations via the model file built-in support for https built-in normalization and validation in the model-layer each entity\u0026rsquo;s correspsonding service can be enabled and disabled on a per-app-server basis based on config generates a working set of CRUD-type RESTful services for each entity in the model file get-set type end-points support /$count, $limit=n, $offset=n, $orderby=field_name ($asc|$desc) supports and generates working end-points for hasOne, hasMany and belongsTo entity relationships generates static query end-points end-points are secured by way of scope inspection (JWT claims) in the route handler middleware end-point security is generated by default via a auths -\u0026gt; auth-groups -\u0026gt; user arrangement generates a comprehensive set of working tests (go test) generated code is easily extended either via direct editing, or through an extension-point concept in the model and controller-layers a leader-election-based group-membership service exists between running instances of the application to facilite internal caching of user information  How does Jiffy interface to the underlying database? Jiffy sits on top of a thin ORM that was written to talk to the SAP Hana in-memory db and then extended to the other support DBMS systems. The ORM code is very simple and can easily be extended to accomodate databases that have not been mentioned here. Bear in mind that the generated queries are designed to accomodate the lowest-common-denominator-type CRUD access. It is expected that a serious deployment will involve extending the generated codebase to optimize access in certain scenarios.\nORM\u0026rsquo;s sound like a bad idea to a lot of people. In practice however, as soon as you want to support more than one type of backend DBMS a level of abstraction (like a thin ORM) starts to look a bit more appealing. However\u0026hellip;\nIf you look at the generated code and don\u0026rsquo;t like what you see, the ORM handle exposes the standard go/sql and the awesome jmoiron/sqlx libraries to you directly. This will effectively allow you to make use of the generated applcation, but code the SQL against the database using the standard go/sql package.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/gs-content-c/",
	"title": "Let&#39;s Build Something",
	"tags": [],
	"description": "",
	"content": "Now that Jiffy is installed, we will build a simple service to test it out.\nJiffy\u0026rsquo;s source tree comes with a number of sample model files that you can use to get the hang of things. We are going to use a simple model file that contains an entity named \u0026lsquo;Person\u0026rsquo;. The model file can be found in the Jiffy source tree, or pulled directly from the Jiffy github repository.\n $GOPATH/src/github.com/1414C/jiffy/support/testing_models/simpleSingleEntityModel.json jiffy repository  For now we are not going to worry about the content of the model file, but we will look at the structure of our new \u0026lsquo;Person\u0026rsquo; entity briefly.\n// Person structure type Person struct { ID uint64 `json:\u0026quot;id\u0026quot; sqac:\u0026quot;primary_key:inc;start:10000000\u0026quot;` Href string `json:\u0026quot;href\u0026quot; sqac:\u0026quot;-\u0026quot;` Name *string `json:\u0026quot;name,omitempty\u0026quot; sqac:\u0026quot;nullable:true;index:non-unique\u0026quot;` Age *uint `json:\u0026quot;age,omitempty\u0026quot; sqac:\u0026quot;nullable:true\u0026quot;` Weight *float64 `json:\u0026quot;weight,omitempty\u0026quot; sqac:\u0026quot;nullable:true\u0026quot;` ValidLicense *bool `json:\u0026quot;valid_license,omitempty\u0026quot; sqac:\u0026quot;nullable:true;index:non-unique\u0026quot;` }  We can see that jiffy will create a Person model with a small set of fields, each with a number of attributes. For the moment, we will concern ourselves only with the field names and types, as we will need to use this information to construct some tests for the new service.\n\u0026lsquo;sqac\u0026rsquo; tags are used to pass information to jiffy\u0026rsquo;s ORM layer.\n \nCreate a new target directory for your project under $GOPATH/src.\n$ cd $GOPATH/src $ mkdir jiffy_tests  \nExecute the jiffy binary, specifying the model file to use, as well as the target directory/project name.\n$ jiffy -m $GOPATH/src/github.com/1414C/jiffy/support/testing_models/simpleSingleEntityModel.json -p /jiffy_tests/first_app  -m tells jiffy which model file should be used to construct the new service.\n-p tells jiffy where to write the generated application code.\nNote that the location of the folder specified by the -p flag is deemed to be relative to $GOPATH/src.\n \nIf everything has gone according to plan, a new application has been generated and should be ready to run. Let\u0026rsquo;s take a look at what jiffy generated for us!\n$ cd $GOPATH/src/jiffy_tests/first_app $ ls -l  This should result in a list of the files and folders comprising our new application.\ndrwxr-xr-x 12 stevem staff 384 5 Feb 21:44 . drwxr-xr-x 10 stevem staff 320 5 Feb 21:44 .. -rwxr-xr-x 1 stevem staff 588 5 Feb 21:44 .dev.config.json -rwxr-xr-x 1 stevem staff 611 5 Feb 21:44 .prd.config.json drwxr-xr-x 4 stevem staff 128 5 Feb 21:44 appobj drwxr-xr-x 10 stevem staff 320 5 Feb 21:44 controllers drwxr-xr-x 4 stevem staff 128 5 Feb 21:44 jwtkeys -rwxr-xr-x 1 stevem staff 839 5 Feb 21:44 main.go -rwxr-xr-x 1 stevem staff 18421 5 Feb 21:44 main_test.go drwxr-xr-x 3 stevem staff 96 5 Feb 21:44 middleware drwxr-xr-x 12 stevem staff 384 5 Feb 21:44 models drwxr-xr-x 3 stevem staff 96 5 Feb 21:44 util $  Jiffy generates two sample configuration files each time it is executed. We are going to run our application with development environment settings, so lets take a quick look at .dev.config.json to make sure there are no horrible surprises.\n{ \u0026quot;port\u0026quot;: 8080, \u0026quot;env\u0026quot;: \u0026quot;dev\u0026quot;, \u0026quot;pepper\u0026quot;: \u0026quot;secret-pepper-key\u0026quot;, \u0026quot;database\u0026quot;: { \u0026quot;db_dialect\u0026quot;: \u0026quot;sqlite\u0026quot;, \u0026quot;host\u0026quot;: \u0026quot;127.0.0.1\u0026quot;, \u0026quot;port\u0026quot;: 0, \u0026quot;usr\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;password\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;testdb.sqlite\u0026quot; }, \u0026quot;cert_file\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;key_file\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;jwt_priv_key_file\u0026quot;: \u0026quot;jwtkeys/private.pem\u0026quot;, \u0026quot;jwt_pub_key_file\u0026quot;: \u0026quot;jwtkeys/public.pem\u0026quot;, \u0026quot;service_activations\u0026quot;: [ { \u0026quot;service_name\u0026quot;: \u0026quot;Person\u0026quot;, \u0026quot;service_active\u0026quot;: true } ] }  Jiffy decides by default to run against a sqlite database and generates what should be a suitable configuration file for most systems. Again, we are not going to worry too much about what is in the configuration file at this point, but know that database file \u0026lsquo;testdb.sqlite\u0026rsquo; will be created in the generated application\u0026rsquo;s root folder.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/generation/gn-content-b/",
	"title": "Generated &#39;application&#39; Folder",
	"tags": [],
	"description": "",
	"content": "Following the execution of the application generator, a folder containing the generated app\u0026rsquo;s files is created as shown. The application folder follows the name provided via the -p Jiffy execution flag. In this case, the name of the application folder is \u0026lsquo;FirstApp\u0026rsquo;.\nFirstApp ├── appobj │ ├── appconf.go │ └── appobj.go ├── controllers │ ├── ... │ ├── ... . . . ├── .dev.config.json ├── .prd.config.json ├── main_test.go └── main.go  "
},
{
	"uri": "https://1414c.github.io/jiffy/models/mo-content-b/",
	"title": "Simple Two Entity Model",
	"tags": [],
	"description": "",
	"content": " Two Entity Model The following JSON illustrates the defintion of a simple two-entity model file. In this case, model entities \u0026lsquo;Person\u0026rsquo; and \u0026lsquo;Country\u0026rsquo; will be created in the generated application, along with corresponding database tables \u0026lsquo;person\u0026rsquo; and \u0026lsquo;country\u0026rsquo;. No relationships have been defined between the two entities; this example simply illustrates how to add multiple entity definitions to a model file.\nsimpleTwoEntityModel.json\n{ \u0026quot;entities\u0026quot;: [ { \u0026quot;typeName\u0026quot;: \u0026quot;Person\u0026quot;, \u0026quot;properties\u0026quot;: { \u0026quot;name\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: false, \u0026quot;unique\u0026quot;: false, \u0026quot;index\u0026quot;: \u0026quot;nonUnique\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,like\u0026quot; }, \u0026quot;age\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;uint\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: false, \u0026quot;unique\u0026quot;: false, \u0026quot;index\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,lt,gt\u0026quot; }, \u0026quot;weight\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;float64\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: false, \u0026quot;unique\u0026quot;: false, \u0026quot;index\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,lt,le,gt,ge\u0026quot; }, \u0026quot;validLicense\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;bool\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: false, \u0026quot;unique\u0026quot;: false, \u0026quot;index\u0026quot;: \u0026quot;nonUnique\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,ne\u0026quot; } } }, { \u0026quot;typeName\u0026quot;: \u0026quot;Country\u0026quot;, \u0026quot;properties\u0026quot;: { \u0026quot;name\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: false, \u0026quot;unique\u0026quot;: false, \u0026quot;index\u0026quot;: \u0026quot;nonUnique\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,like\u0026quot; }, \u0026quot;isoCode\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;uint\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: false, \u0026quot;unique\u0026quot;: false, \u0026quot;index\u0026quot;: \u0026quot;unique\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,lt,gt\u0026quot; } } } ] }  simpleTwoEntityModel.json\n"
},
{
	"uri": "https://1414c.github.io/jiffy/execution/ex-content-b/",
	"title": "Jiffy Execution Flags",
	"tags": [],
	"description": "",
	"content": " Generation Flags Flags are kept to a minimum, but there are a few flags that can be appended to the execution command:\n go run *.go -p   The -p switch is used to specify the target directory for generated application source-code relative to $GOPATH/src.   $ go run main.go -p \u0026quot;github.com/footle.com/myrestfulsvc\u0026quot;   go run main.go -m .json  By default, the application will attempt to use ./support/testing_models/models.json as the model source, but inclusion of the -m flag permits the use of an alternate model file. The path of model file in the application base directory must be prefaced with ./ . If the model file is not located in the base directory of the application, the full path must be specified when using the -m flag.   go run main.go -m \u0026quot;./my_model.json\u0026quot;   go run main.go -mf   By default, the application will attempt to use ./support/testing_models/models.json as the model source, but inclusion of the -mf flag instructs the generator to read and process all model files contained in the specified folder. The path of models folder in the application base directory must be prefaced with ./ . If the models folder is not located in the base directory of the application, the full path must be specified when using the -mf flag.   go run main.go -mf \u0026quot;./models_folder\u0026quot;  Typical Use Typically you will want to provide your own model file and direct Jiffy to write the source code for the new application to a non-default destination.\ngo run main.go -m \u0026quot;./my_model.json\u0026quot; -p \u0026quot;github.com/footle.com/myrestfulsvc\u0026quot;  In the case where you have created more than one model file for your application, the -mf flag is used to instruct Jiffy to read all the models in specified location.\ngo run main.go -mf \u0026quot;./models_folder\u0026quot; -p \u0026quot;github.com/footle.com/myrestfulsvc\u0026quot;  "
},
{
	"uri": "https://1414c.github.io/jiffy/installation/ov-content-b/",
	"title": "Jiffy Installation",
	"tags": [],
	"description": "",
	"content": " Installation Steps The easiest way to install Jiffy is to use go get on the command-line to pull the latest version from github, as shown below:\n$ go get -u github.com/1414C/jiffy  This will pull the jiffy github repository into your $GOPATH/src/github.com folder, as well as any dependencies referenced by the jiffy source code. The -u flag is included to instruct go get to check for and pull updates to jiffy packages and their dependencies. This is the least sophisticated way of managing dependencies in go.\nOnce the jiffy source code and dependencies have been installed into your $GOPATH, you can use go build to compile a binary from the jiffy sources. The easiest way to do this is to open a terminal window, switch to $GOPATH/src/github.com/1414C/jiffy and run go build as shown below.\n$ go build -v  This will result in the creation of a binary file called \u0026lsquo;jiffy\u0026rsquo;. You may move the \u0026lsquo;jiffy\u0026rsquo; binary anywhere in your $PATH, but convention would have you install it in /usr/local/bin. Once you have moved the \u0026lsquo;jiffy\u0026rsquo; binary to its new home, open a new terminal window and use the which command to ensure that you can access the binary.\n$ which jiffy -a  If which cannot find the jiffy binary (or finds the wrong one!), you need to make sure that your $PATH is set correctly.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/overview/ov-content-b/",
	"title": "Jiffy Application Overview",
	"tags": [],
	"description": "",
	"content": " What does a generated Jiffy application look like? Generated Jiffy applications can be pointed at the DBMS of your choice without the need to recompile the binary (architecture differences not withstanding). This means that a developer can build a model, fully test it locally using SQLite and then redirect the appplication to a formal testing environment running SAP Hana, or any of the other supported database systems.\nApplications are generated based on model files which are encoded as simple JSON. The concepts of entity and resource-id form the cornerstones upon which the model, application and RESTful end-points are built.\nEntities can be thought of anything that needs to be modelled; Order, Customer, Invoice, Truck, \u0026hellip;, \u0026hellip; Each entity is mandated to have an ID field, which is analagous to a primary-key or row-id in the backend database. ID is used as the primary resource identifier for an entity, and is setup by default as an auto-incrementing column in the database. ID is implemented as go-type uint64 and is inserted into the model entity definition during application generation.\nSimple CRUD Access Accessing an entity via the generated CRUD interface is very simple. For example, a customer entity could be defined in the model and then accessed via the application as follows:\n Create a customer entity:\n https://servername:port/customer + {JSON body}  Update a customer entity:\n https://servername:port/customer/:id + {JSON body}  Read a customer entity:\n https://servername:port/customer/:id  Delete a customer entity:\n https://servername:port/customer/:id  Read all customer entities:\n https://servername:port/customers   Filters and Relationships Additional routes can also be generated based on the model file, including custom filters for GET operations, static end-points for common GET operations, HasOne, HasMany and BelongsTo relationships:\n Use a filter to Get customers where the last name is \u0026lsquo;Smith\u0026rsquo;:\n https://servername:port/customers/?last_name=Smith  Use a generated static end-point to Get customers where credit score is less than 4:\n https://servername:port/customers/credit_score(LT 4)  Use a generated relationship to retrieve all orders for a specific customer (10023):\n https://servername:port/customer/10023/orders  Use a generated relationship to retrieve a specific order (99000022) for the specified customer (10023):\n https://servername:port/customer/10023/order/99000022  Use a generated belongsTo relationship to retrieve the customer for a specific order (990000222):\n https://servername:port/order/99000022/customer   Commands A set of commands can be appended to an operation\u0026rsquo;s URL to perform some common activities. The commands can be appended to the URL in any order.\n Get a count of all customer entities:\n https://servername:port/customer/$count  Limit the number of returned customer entities to 3. The default ordering for this example would be ascending based on the entity ID field.\n https://servername:port/customer/$limit=3  Offset the database selection by 2 records, top-down, using the default order; (ascending based on the entity ID field):\n https://servername:port/customer/$offset=2  Select records in descending order based on the entity ID field:\n https://servername:port/customer/$desc  Select records in descending order using the customer name field as the order-by criteria:\n https://servername:port/customer/$orderby=name$desc  Limit the number of selected records to 3 and select in descending order based on the entity ID field:\n https://servername:port/customer/$limit=3/$desc  Limit the number of selected records to 3 and select in ascending order using the customer name field as the order-by criteria:\n https://servername:port/customer/$limit=3;$orderby=name$asc  Limit the number of selected records to 3 with an offset of 2 and select the records in ascending order using the customer name field as the sort criteria:\n https://servername:port/customer/$limit=3$offset=2$orderby=name$asc  Limit the return of a static filter end-point to 3 records:\n https://servername:port/customers/credit_score(LT4)/$limit=3   More details regarding application modlelling are contained in later sections of this documentation.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/overview/ov-content-c/",
	"title": "Jiffy Application Structure",
	"tags": [],
	"description": "",
	"content": " Jiffy Application File Structure This is what Jiffy generates when provided with a model-file describing a simple \u0026lsquo;Person\u0026rsquo; entity. The structure and files look more or less standard if you are used to looking at such things. Explanations of each folder and its content are discussed thoughout the documentation.\nFirstApp ├── appobj │ ├── appconf.go │ └── appobj.go ├── controllers │ ├── authc.go │ ├── controllerfuncs.go │ ├── groupauthc.go │ ├── person_relationsc.go │ ├── personc.go │ ├── usrc.go │ ├── usr_groupc.go │ └── ext │ ├── extc_interfaces.go │ └── personc_ext.go ├── group │ ├── gmcl │ │ ├── gmclient.go │ ├── gmcom │ │ ├── gmcache.go │ │ ├── gmclsrv.go │ │ ├── gmerrors.go │ │ └── gmomap.go │ └── gmsrv │ ├── gmprocessors.go │ ├── gmprotocol_senders.go │ ├── gmserver.go │ └── gmtxrx.go ├── jwtkeys │ ├── private.pem │ └── public.pem ├── middleware │ └── requireuser.go ├── models │ ├── authm.go │ ├── errors.go │ ├── group_authm.go │ ├── modelfuncs.go │ ├── personm_ext.go │ ├── personm.go │ ├── servicesm.go │ ├── usr_groupm.go │ ├── usrm.go │ └── ext │ └── model_ext_interfaces.go ├── util │ └── strings.go ├── .dev.config.json ├── .prd.config.json ├── main_test.go └── main.go  Jiffy Application Services Jiffy approaches the API from a services perspective. Each entity has a corresponding service that can be started when the application initializes. The Usr, UsrGroup, Auth and GroupAuth services are always generated by default when creating a Jiffy application. Additional services are generated based on the model files created based on the business scenario.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/gs-content-d/",
	"title": "Let&#39;s Run Something",
	"tags": [],
	"description": "",
	"content": "Let\u0026rsquo;s execute our first application!\n$ cd $GOPATH/src/jiffy_tests/first_app $ go run main.go -dev -rs  Executing with the -dev and -rs flags instructs our new application to initialize itself using the development settings file, and forces a rebuild of the \u0026lsquo;Super\u0026rsquo; authorization-group. Consequently, you will see some warning and info messages scroll up the screen which is expected.\n2018/02/05 22:29:26 package sqac init is running 2018/02/05 22:29:26 successfully loaded the config file... 2018/02/05 22:29:26 JWTPrivKeyFile: jwtkeys/private.pem 2018/02/05 22:29:26 JWTPubKeyFile: jwtkeys/public.pem 2018/02/05 22:29:26 warning: auth usr.GET_SET not found in the db Auth master data 2018/02/05 22:29:26 warning: auth usr.CREATE not found in the db Auth master data 2018/02/05 22:29:26 warning: auth usr.GET_ID not found in the db Auth master data ... ... 2018/02/05 22:29:26 info: creating auth usr.GET_SET in the db Auth master data 2018/02/05 22:29:26 warning: new auth usr.GET_SET must be added to at least one group 2018/02/05 22:29:26 info: creating auth usr.CREATE in the db Auth master data 2018/02/05 22:29:26 warning: new auth usr.CREATE must be added to at least one group ... ... 2018/02/05 22:29:26 warning: new auth person.STATICFLTR_ByValidLicense must be added to at least one group 2018/02/05 22:29:26 info: creating auth person.STATICFLTR_CMD_ByValidLicense in the db Auth master data 2018/02/05 22:29:26 warning: new auth person.STATICFLTR_CMD_ByValidLicense must be added to at least one group 2018/02/05 22:29:26 The Super UsrGroup has been initialized with 42 Auth objects. 2018/02/05 22:29:26 re-initializing local middleware to accomodate Super group changes. 2018/02/05 22:29:27 admin user created with ID: 1 and initial password of initpass Development settings selected... Starting http server on port... 8080  You should see a message indicating that the application is running. During the startup, the application executed a number of steps.\n Loaded the development configuration file. Initialized a handle to the underlying ORM. Checked for and loaded the public and private keys for JWT support. Checked for and created the user, auth, and usergroup tables in the database. Checked for and created the person table in the database based on the Person model. Checked for and created authorizations in the database for each service end-point. Checked for and created the Super user-group in the database. Assigned all authorizations to the Super user-group. Created the \u0026lsquo;admin\u0026rsquo; user and assigned it to the \u0026lsquo;Super\u0026rsquo; user-group. Initialized the authorization cache in the router. Started the router. Looked at the leader-persistence store to determine the group-leader (and failed). Became the defacto group-leader, set own process-id (usually to 1 in this case). Updated the leader-persistence store withe the new group-leader information. Started the inter-process failure-detector.  Congratulations! Your first application is now open for business at http://127.0.0.1:8080\n"
},
{
	"uri": "https://1414c.github.io/jiffy/generation/gn-content-c/",
	"title": "Generated &#39;appobj&#39; Folder",
	"tags": [],
	"description": "",
	"content": " The \u0026lsquo;appobj\u0026rsquo; Folder  The appobj folder contains the generated application\u0026rsquo;s configuration loader and the main application object. \nFirstApp ├── appobj │ ├── appconf.go │ └── appobj.go ├── controllers │ ├── ... │ ├── ... . . . ├── .dev.config.json ├── .prd.config.json ├── main_test.go └── main.go  appobj.go The entry point for go applications is always the main() function, but we seldom write the so-called \u0026lsquo;main\u0026rsquo; part of the application in this monolithic function. To that end, an AppObj struct is declared and the main thread of the application runs against it. The content of main.go simply creates an instance of an AppObj struct, parses the flags and then calls the AppObj.Run() method.\nWhen the generated application is started, AppObj.Run() is responsible for:\n loading the specified config creating the runtime services performing auto-migration of database artifacts initializing the keys for JWT/ECDSA support instantiating controllers initializing routes starting the mux reading the group-leader information from the group persistent store joining (or creating) the group starting the inter-process group-membership failure detector  The creation of the runtime services bears closer inspection before moving on. Generated applications contain an internal \u0026lsquo;service\u0026rsquo; for each entity declared in the source model files. The AppObj is responsible for the instantiation of these services when the application is started via the AppObj.createServices() method.\nA Services object containing each of the entity runtime services is created on the one-and-only instance of the AppObj. A runtime service is first created to support access to the backend DBMS via the sqac ORM, then a service is started for each entity. Entity services contain a reference to the ORM access handle, as well as an instance of the entity\u0026rsquo;s validator class which is contained in the model-layer.\nappconf.go The code in appconf.go contains the functions used to load application configuration files, as well as functions containing so-called \u0026lsquo;default\u0026rsquo; configuration. It is possible to edit the DefaultConfig() function so that it holds values specific to the local test/development environment. This prevents the need for maintaining a set of configuration files that the development staff need to keep in sync.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/models/mo-content-c/",
	"title": "Model with Composite Index",
	"tags": [],
	"description": "",
	"content": " Two Entity Model with Composite Index The following JSON illustrates the addition of a composite-index to an entity definition. An index composed of the \u0026lsquo;name\u0026rsquo; and \u0026lsquo;province\u0026rsquo; fields has been declared in the \u0026lsquo;Owner\u0026rsquo; entity. This declaration will result in the creation of a non-unique b-tree index for columns \u0026lsquo;name\u0026rsquo; and \u0026lsquo;province\u0026rsquo; in the database. Any number of composite indices may be declared for an entity. No relationships have been defined between the two entities; this example simply illustrates how to declare a composite-index for an entity.\ntwoEntityWithCompositeIndex.json\n{ \u0026quot;entities\u0026quot;: [ { \u0026quot;typeName\u0026quot;: \u0026quot;Owner\u0026quot;, \u0026quot;properties\u0026quot;: { \u0026quot;Name\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: false, \u0026quot;unique\u0026quot;: false, \u0026quot;index\u0026quot;: \u0026quot;nonUnique\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,like\u0026quot; }, \u0026quot;LicenseNumber\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;uint\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: false, \u0026quot;unique\u0026quot;: true, \u0026quot;index\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,lt,gt\u0026quot; }, \u0026quot;Province\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: false, \u0026quot;unique\u0026quot;: false, \u0026quot;index\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,lt,gt\u0026quot; } }, \u0026quot;compositeIndexes\u0026quot;: [ {\u0026quot;index\u0026quot;: \u0026quot;name, province\u0026quot;} ] }, { \u0026quot;typeName\u0026quot;: \u0026quot;Car\u0026quot;, \u0026quot;properties\u0026quot;: { \u0026quot;Model\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: true, \u0026quot;index\u0026quot;: \u0026quot;nonUnique\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,like\u0026quot; }, \u0026quot;Make\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: true, \u0026quot;index\u0026quot;: \u0026quot;nonUnique\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,like\u0026quot; } } } ] }  "
},
{
	"uri": "https://1414c.github.io/jiffy/overview/ov-content-d/",
	"title": "Jiffy Application Architecture",
	"tags": [],
	"description": "",
	"content": " Jiffy Application Architecture Jiffy approaches the API from a services perspective. Each entity has a corresponding service that can be started when the application initializes. The Usr, UsrGroup, Auth and GroupAuth services are always generated by default when creating a Jiffy application. Additional services are generated based on the content of your project\u0026rsquo;s model files.\nGenerated application services can be broken down into five high-level areas: \ngraph TD; subgraph A(End-Points)--B(Middleware) B--C(Controllers) C--D(Models) D--E(Database) end  \n End-Points expose the service APIs to the consumer such as a web-app or another server. End-points may be customized by way of the application model files. Middleware provides user authentication / authorization services and is tightly-coupled to the end-point definitions. The middleware offers comprehensive services such as authorization via JWT claims inspection, as well as some caching of user and group authorization details. This is an area of active development. Controllers are the entry point into the application proper, and are called after a request has been granted access to the end-point by the middleware. It is here that the body of the request is unmarshalled and mapped into the correct go model structure. Extension-points conforming to standard Jiffy interfaces are provided in the controllers for post-generation enhancements. Models are where the entity data from the request is checked, normalized and prepared for submission to the database. Extension-points conforming to standard Jiffy interfaces are provided in the models for post-generation enhancements. Database refers to the backend DBMS that is being used to house the entity data. Jiffy generated applications can connect to PostgreSQL, MariaDB/MySQL, MSSQL, SAP HanaDB or SQLite. It is easy to extend the database support to other relational platforms provided that there is an existing go sql driver for the database in question. It is possible to override the generated Jiffy call to the database and \u0026lsquo;roll-your-own\u0026rsquo; should the need arise.  "
},
{
	"uri": "https://1414c.github.io/jiffy/generation/gn-content-d/",
	"title": "Generated &#39;controllers&#39; Folder",
	"tags": [],
	"description": "",
	"content": " The \u0026lsquo;controllers\u0026rsquo; Folder FirstApp ├── appobj │ ├── appconf.go │ └── appobj.go ├── controllers │ ├── authc.go │ ├── controllerfuncs.go │ ├── groupauthc.go │ ├── person_relationsc.go │ ├── personc.go │ ├── usrc.go │ ├── usr_groupc.go │ └── ext │ ├── extc_interfaces.go │ └── personc_ext.go ├── group │ ├── ... │ │ ├── ... . . . . . ├── .dev.config.json ├── .prd.config.json ├── main_test.go └── main.go  A controller is created for each entity that has been declared in the model files, as well as a number of static controllers that are used to handle the application\u0026rsquo;s users and authoziation objects.\nControllers act as a bridge between an entity\u0026rsquo;s routes and its model layer. Each entity mux route is assigned a method in their respective controller based on the intent of that route. For example, to create a new new Library entity the following POST could be made:\nhttps://servername:port/library {JSON body} + POST  The route for this call is defined in appobj.go as follows, where \u0026lsquo;a\u0026rsquo; is the one-and-only instance of the AppObj:\na.router.HandleFunc(\u0026quot;/library\u0026quot;, requireUserMw.ApplyFn(a.libraryC.Create)).Methods(\u0026quot;POST\u0026quot;)  The \u0026lsquo;/library\u0026rsquo;-POST route is assigned a HandleFunc belonging to the instance of the LibraryController that has been created on the appobj. a.libraryC.Create is called for the \u0026lsquo;library\u0026rsquo; route when the http method equals \u0026lsquo;POST\u0026rsquo;. The route contains some additional code related to authentication and authorization of the requester but this can be ignored for now. The handler function for a mux.route must conform to the standard go http.Handler interface:\ntype Handler interface { ServeHTTP(ResponseWriter, *Request) }  This interface facilitates the passing of the incoming request header and body to the controller method, as well as the passing of the formatted response back to the router. With this out of out the way, let\u0026rsquo;s look at generated Controller method LibraryController.Create:\n// Create facilitates the creation of a new Library. This method is bound // to the gorilla.mux router in main.go. // // POST /library func (lc *LibraryController) Create(w http.ResponseWriter, r *http.Request) { var l models.Library decoder := json.NewDecoder(r.Body) if err := decoder.Decode(\u0026amp;l); err != nil { log.Println(\u0026quot;Library Create:\u0026quot;, err) respondWithError(w, http.StatusBadRequest, \u0026quot;libraryc: Invalid request payload\u0026quot;) return } defer r.Body.Close() // fill the model library := models.Library{ Name: l.Name, City: l.City, } // build a base urlString for the JSON Body self-referencing Href tag urlString := buildHrefStringFromCRUDReq(r, true) // call the Create method on the library model err := lc.ls.Create(\u0026amp;library) if err != nil { log.Println(\u0026quot;Library Create:\u0026quot;, err) respondWithError(w, http.StatusBadRequest, err.Error()) return } library.Href = urlString + strconv.FormatUint(uint64(library.ID), 10) respondWithJSON(w, http.StatusCreated, library) }  The complete Library.Create(http.Handler) controller method is shown exactly as it has been generated.\nEach section of the method is broken down in the following subsets of commented code:\n// declare a local variable of struct type models.Library to hold the decoded // JSON body provided in the request.Body. var l models.Library // create a new JSON decoder passing in the request.Body decoder := json.NewDecoder(r.Body) // call the Decoder.Decode(interface{}) method passing a reference to the locally // declared models.Library struct 'l'. if the decoder is able to decode the JSON // contained in the request.Body, the member fields of 'l' will be populated. if // the decoder fails to parse and map the incoming JSON to the models.Library // struct, it will return an error. The problem will be logged to stdout (for now) // on the server-instance, and a response conforming to the http.Handler interface // will be constructed and passed back to the router. if the JSON was parsed // closed upon exit of the method. if err := decoder.Decode(\u0026amp;l); err != nil { log.Println(\u0026quot;Library Create:\u0026quot;, err) respondWithError(w, http.StatusBadRequest, \u0026quot;libraryc: Invalid request payload\u0026quot;) return } defer r.Body.Close() // fill the model with the parsed content of the JSON body. this step looks // redundant, but can be thought of as a way to separate the incoming data // from the response. going forward from this point, 'l' is ignored and // all data transformation occurs on the 'library' variable. library := models.Library{ Name: l.Name, City: l.City, } // build a base urlString for the JSON Body self-referencing Href tag urlString := buildHrefStringFromCRUDReq(r, true) // call the Create method on the library model. each controller contains an // instance of the Service for it's respective entity. the Create method on // the service is called, passing a reference to the 'library' data structure. // recall that the Service for an entity provides the link to that entity's // model-layer by way of the entity's validator. lc.ls.Create(\u0026amp;library) will // result in a call the model Validator Create() method for the Library // entity, and in-turn, call to the enitity's model.Create() method where // the data will be passed to the ORM-layer. if the Create() call returns // an error, the problem will be logged to stdout (for now) on the server- // instance, and a response conforming to the http.Handler interface will be // constructed and passed back to the router. err := lc.ls.Create(\u0026amp;library) if err != nil { log.Println(\u0026quot;Library Create:\u0026quot;, err) respondWithError(w, http.StatusBadRequest, err.Error()) return } // if the call to the model-layer was successful, it indicates that a new // Library entity was created in the DBMS. the 'library' reference passsed // to the Create() method(s) in the model-layer will now contiain the new // Library's information. first, the ID for the new Library will be added // to the urlString and assigned to the library struct's Href member field. // Href is another injected field in the entity and fullfills the purpose // of providing a direct URI for the returned entity. finally the populated // 'library' struct is formatted as a JSON response and passed back to the // router along with an http status-code indicating success. library.Href = urlString + strconv.FormatUint(uint64(library.ID), 10) respondWithJSON(w, http.StatusCreated, library) }  The controllers folder also contains an \u0026lsquo;ext\u0026rsquo; sub-directory which is used to hold the interface definitions for controller extension-points as well as the associated empty implementation for each entity. See the \u0026lsquo;Extension Points\u0026rsquo; section of this document for more details.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/models/mo-content-d/",
	"title": "Entity Relations",
	"tags": [],
	"description": "",
	"content": " Modelling Entity Relationships Relationships between entities can be declared in the application model file via the addition of a \u0026lsquo;relations\u0026rsquo; block inside an entity\u0026rsquo;s declaration. Relationships are based on resource id\u0026rsquo;s by default, although it is possible to specify non-default key fields in the configuration, or implement complex joins directly by maintaining the entity\u0026rsquo;s controller and model. \u0026lsquo;relations\u0026rsquo; blocks look as follows:\n\u0026quot;relations\u0026quot;: [ { \u0026quot;relName\u0026quot;: \u0026quot;ToOwner\u0026quot;, \u0026quot;properties\u0026quot;: { \u0026quot;relType\u0026quot;: \u0026quot;hasOne\u0026quot;, \u0026quot;toEntity\u0026quot;: \u0026quot;Owner\u0026quot; } } ]  The sample relations block illustrates the declaration of a HasOne relationship between Car and Owner making use of default-keys.\nhasOne Relationship \u0026lsquo;hasOne\u0026rsquo; relationships establish a one-to-one relationship between two model entities. As an example, let\u0026rsquo;s posit that a Car can have one Owner. If the Car and Owner were modelled as entities, we could declare a \u0026lsquo;hasOne\u0026rsquo; (1:1) relationship between them. The relation would be added to the \u0026lsquo;relations\u0026rsquo; block inside the Car entity definition (as shown above).\nA break-down of the relations block fields is as follows:\n{ \u0026quot;relations\u0026quot;: [ The 'entities' block contains an array of relations belonging to the containing entity definition. Each relation is defined from the perspective of the containing entity having a relationship of the specified type (in this case hasOne), with the entity referenced in the declaration. A Car has one Owner - in our example at least. { \u0026quot;relName\u0026quot;: \u0026quot;Owner\u0026quot; Field 'relName' refers to the name the relationship will be known by inside the application and in the end-point definition in the mux routes. It must be capitalized and written in CamelCase. Any name may be chosen for this field, but keep in mind this name will be exposed to the service consumer via the URI, so something respecting the relationship enities and cardinality is best. For the example, we have chosen a relName of 'ToOwner' to demonstrate the difference between the toEntity and relName fields. 'relName' is a mandatory field in a relations declaration. \u0026quot;properties\u0026quot;: { The 'properties' block contains the details of the relationship. \u0026quot;relType\u0026quot;: Field 'relType' is used to indicate what sort of relationship is being declared between the containing (from) entity and the toEntity. Valid values are {hasOne, hasMany and belongsTo}. This is a mandatory field. \u0026quot;toEntity\u0026quot;: Field 'toEntity' is used to specify the target entity in the relationship. The toEnity must be capitalized and provided in CamelCase that matches that used in the toEntity's declaration. The toEntity need not appear prior to the containing entity in the model file or files. This is a mandatory field. } } ] }  hasMany Relationship \u0026lsquo;hasMany\u0026rsquo; relationships establish a one-to-many relationship between two model entities. As an example, let\u0026rsquo;s posit that a Library can have many Books. If Library and Book were modelled as entities, we could declare a \u0026lsquo;hasMany\u0026rsquo; (1:N) relationship between them. The relation would be added to the \u0026lsquo;relations\u0026rsquo; block inside the Library entity definition:\n{ \u0026quot;entities\u0026quot;: [ { \u0026quot;typeName\u0026quot;: \u0026quot;Library\u0026quot;, \u0026quot;properties\u0026quot;: { \u0026quot;Name\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: true, \u0026quot;unique\u0026quot;: false, \u0026quot;index\u0026quot;: \u0026quot;nonUnique\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,like\u0026quot; }, \u0026quot;City\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: true, \u0026quot;unique\u0026quot;: false, \u0026quot;index\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,lt,gt\u0026quot; } }, \u0026quot;compositeIndexes\u0026quot;: [ {\u0026quot;index\u0026quot;: \u0026quot;name, city\u0026quot;} ], \u0026quot;relations\u0026quot;: [ { \u0026quot;relName\u0026quot;: \u0026quot;ToBooks\u0026quot;, \u0026quot;properties\u0026quot;: { \u0026quot;relType\u0026quot;: \u0026quot;hasMany\u0026quot;, \u0026quot;toEntity\u0026quot;: \u0026quot;Book\u0026quot; } } ] }, { \u0026quot;typeName\u0026quot;: \u0026quot;Book\u0026quot;, \u0026quot;properties\u0026quot;: { \u0026quot;Title\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: true, \u0026quot;index\u0026quot;: \u0026quot;nonUnique\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,like\u0026quot; }, \u0026quot;Hardcover\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;bool\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: true, \u0026quot;index\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,ne\u0026quot; }, \u0026quot;Copies\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;uint64\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: true, \u0026quot;index\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,lt,gt\u0026quot; }, \u0026quot;LibraryID\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;uint64\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: true, \u0026quot;index\u0026quot;: \u0026quot;nonUnique\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,like\u0026quot; } } } ] }  belongsTo Relationship \u0026lsquo;belongsTo\u0026rsquo; relationships are used to form the inverse of the \u0026lsquo;hasOne\u0026rsquo; and \u0026lsquo;hasMany\u0026rsquo; relations. Consider the Library \u0026lsquo;hasMany\u0026rsquo; Books example; A Library has many books, but we can also posit that \u0026lsquo;a Book belongs to a Library\u0026rsquo;; this is an example of a \u0026lsquo;belongsTo\u0026rsquo; relationship. The JSON below extends the Library -\u0026gt; Book example by adding the \u0026lsquo;belongsTo\u0026rsquo; relationship to the Book entity definition:\n{ \u0026quot;entities\u0026quot;: [ { \u0026quot;typeName\u0026quot;: \u0026quot;Library\u0026quot;, \u0026quot;properties\u0026quot;: { \u0026quot;Name\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: true, \u0026quot;unique\u0026quot;: false, \u0026quot;index\u0026quot;: \u0026quot;nonUnique\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,like\u0026quot; }, \u0026quot;City\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: true, \u0026quot;unique\u0026quot;: false, \u0026quot;index\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,lt,gt\u0026quot; } }, \u0026quot;compositeIndexes\u0026quot;: [ {\u0026quot;index\u0026quot;: \u0026quot;name, city\u0026quot;} ], \u0026quot;relations\u0026quot;: [ { \u0026quot;relName\u0026quot;: \u0026quot;ToBooks\u0026quot;, \u0026quot;properties\u0026quot;: { \u0026quot;relType\u0026quot;: \u0026quot;hasMany\u0026quot;, \u0026quot;toEntity\u0026quot;: \u0026quot;Book\u0026quot; } } ] }, { \u0026quot;typeName\u0026quot;: \u0026quot;Book\u0026quot;, \u0026quot;properties\u0026quot;: { \u0026quot;Title\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: true, \u0026quot;index\u0026quot;: \u0026quot;nonUnique\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,like\u0026quot; }, \u0026quot;Hardcover\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;bool\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: true, \u0026quot;index\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,ne\u0026quot; }, \u0026quot;Copies\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;uint64\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: true, \u0026quot;index\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,lt,gt\u0026quot; }, \u0026quot;LibraryID\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;uint64\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: true, \u0026quot;index\u0026quot;: \u0026quot;nonUnique\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,like\u0026quot; } }, \u0026quot;relations\u0026quot;: [ { \u0026quot;relName\u0026quot;: \u0026quot;ToLibrary\u0026quot;, \u0026quot;properties\u0026quot;: { \u0026quot;relType\u0026quot;: \u0026quot;belongsTo\u0026quot;, \u0026quot;toEntity\u0026quot;: \u0026quot;Library\u0026quot; } } ] } ] }  By relying on the default key determinations for the \u0026lsquo;belongsTo\u0026rsquo; relationship, the generator determines that the Book.LibraryID field should be matched against field Library.ID. If alternate keys are desired, they can be specified in the \u0026lsquo;refKey\u0026rsquo; and \u0026lsquo;foreignKey\u0026rsquo; property fields in the \u0026lsquo;belongsTo\u0026rsquo; relation declaration.\nWhat if more complex relationships are required? At the moment the generator only supports \u0026lsquo;hasOne\u0026rsquo;, \u0026lsquo;hasMany\u0026rsquo; and \u0026lsquo;belongsTo\u0026rsquo; relations, as in practice these tend to be the most widely used. The generated code can be extended to accomodate additional relationships and joins if need be. There is a tentative plan to support more complex relations in the generator in the future. Most of the supporting code is in place, but the controller_rel templates would need to be enhanced to support it. In the meantime, a combination of foreign-feys and static filters can be employed as an alternative to formally defined relationships in cases where the entity-id model is not sufficient.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/overview/ov-content-e/",
	"title": "Jiffy Development Steps",
	"tags": [],
	"description": "",
	"content": " Jiffy Pre-Generation Workflow Jiffy is intended to generate a clean, straight-forward and secure application services platform just like the one you would write by hand. Jiffy originally started as a few go templates I used to generate boiler-plate code that I do not like to type. Generation is a lot nicer than cut-and-paste. There are places in the generated code where things could be more elegant, but the code is intended to be easy to work on even if one is not familliar with it. File and folder names are somewhat subjective; I have tried to be descriptive and organized.\nDesign Steps  You are building a back-end of some sort where you need to reliably read and write data. Before you start building the \u0026lsquo;real\u0026rsquo; Jiffy model of your application, try some of the demo models to get a feel for what Jiffy is and what it isn\u0026rsquo;t. It is a lot easier to design if you know what the platform provides and what it does not.\n Start messing around with entity ideas. What is the best way to represent your data? Transfering your ideas into a few rough diagrams often changes your understanding of what you are modelling.\n Consider the relationships you would like to have between your entities. Does your model still hold up?\n Add some detail to your proposed entities in terms of fields. Remember that Jiffy will insert a primary-key (id), as well as a self-referencing entity href into the model for you. This is important when you are considering relationships, as Jiffy applications have some expectations regarding the name of the referencing field. See the Relations section of this documentation set for details.\n Once you are comfortable with the entities and the fields that they will contain, it is time to create the model in the Jiffy model file format.\n Jiffy model files are simple JSON and at the moment need to be coded up by hand. Taking a copy of one of the sample model-files is the best way to start. Short of creating a graphical model file generator, maintaining the models via direct file maintenance is the most direct and transparent way to edit them. Remember that you do not have to put your entire model in one file. Jiffy is quite happy to accept any number of model files for your project with the entities defined in any order. The generator will sort it all out.\n Check your model files as best as possible before feeding them into Jiffy. If you get an error, don\u0026rsquo;t worry; I get them all the time too. Look at the error message, then check the model-file for problems. If you can\u0026rsquo;t see anything wrong, log an issue and I will take a look. Usual suspects for errors are missing double-quotes on field-names or string-values, missing closing parentheses on a list, missing brace on struct or sub-struct, putting quotes on a bool value, putting quotes on an int or dec value etc.\n Again, don\u0026rsquo;t worry too much about formal inter-entity rules in the beginning. The idea is to get something up and running fast so you can try out the services. You can generate your application many times over without touching anything but the model-file / model-files. Generation is fast.\n Generate a version of your application and start it up. Try it out with a tool like Postman. See the Quickstart for an overview of application generation through to application testing, or go to the formal section dealing with each of the appliation creation steps.\n It is not (typically) neccessary to do early development testing via https. If this is not the case for you, see the testing with https section in this document set. Step-by-step instructions are given to create and install self-signed certificates that will permit you to test locally with https.\n As you test your application, you will probably see some fields missing, some fields that you don\u0026rsquo;t care for, and maybe the need for an additional entity. Update your model files and generate the application again. Try it out. Repeat.\n As your model becomes more refined, consider formally adding relationships. Generate, test, repeat.\n Consider foreign-keys. Generate, test, repeat.\n Consider start-values for id. Not everybody is okay to start at 1, particularly if you are planning on migrating existing data into your application. Generate and test.\n Consider static-queries and add the selection options to each field that can be queried. Generate, test, repeat. See the static query section for details.\n Consider indices and add indexes to the model definitions where needed. Generate, test, repeat.\n Access restrictions can be assigned at the end-point-level, and this is built into the generated application. Don\u0026rsquo;t worry about testing authorization and authentication for now.\n  Development  When you are satisfied with your model, generate a version of the application and place it under source-code control.\n Implement extension-points in the controller and model go source as per your requirements. Implemented extension-points will not be over-written should you need to regenerate the application. Test often.\n Implement normalization and validation at the field-level in the generated entity model go source file. This part is slightly contentious, as field normalization and validiation is performed directly in the generated code, rather than off to the side in extension-points. We suggest that if you are worried about over-writing your normalization and validation code with an accidental regeneration, you create a model_normalization package for each model and implement field-level normalizations and checks there. Of course, you are free to ignore the provided field-level normalization and validation methods and perform all checks in one of the model extension-points. Its up to you, and it will make more sense once you take a look through one of the generated files.\n When you are happy with the way things are working, think about user access. Sketch out user-groups and assign end-points to them until you have something that you like. Use Postman to create UserGroups and assign Auths to them, then create new users and allocate the relevant UserGroups to their ID. That is all you need to do; the Jiffy middleware will take care of the rest. See the Authentication and Authorization section for a detailed discussion of how users are authenticated and authorized.\n  Deployment Jiffy generated applications can be deployed in any number of ways. For example:\n On your laptop On a server under your desk On a blade running the os of your choice On a VM (xen etc.) Docker image / Droplet / Cloud Foundry etc. Across a collection of the above  At the software level, the Jiffy generated application can be deployed as:\n A single environment hosting the DBMS and application A single application instance talking to a database on your SAN Multiple application instances talking to a database on your SAN  Considerations for deployment  SSL certificates Do you need to support JWT\u0026rsquo;s from other SSO providers? If so, you will need their public-keys. JWT expiration policy You have tested your user-access revocation? Jiffy makes provisions for the revocation of user-access based on the user master. If a user is deleted or marked as inactive, even a valid JWT for that user will not permit access. Data migration; have you run real test migrations with the key relationships etc. in place? If you disabled certain database features for migration, have you turned them back on again? Looking at you foreign-keys\u0026hellip; User access; users have been assigned to Groups and the create/update/delete end-points are locked down in accordance with your use-cases? Do you need a reverse-proxy / is there a need to route traffic based on expected load? Service activations; is there a need to route traffic based on expected load? If you need to scale horizontally or vertically do you have a plan?  "
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/level-two/",
	"title": "Let&#39;s Test Something",
	"tags": [],
	"description": "",
	"content": "We have a running application, but what can we do with it? If you clicked on the http://127.0.0.1:8080 link at the end of the preceding section, you didn\u0026rsquo;t get a very good looking response\u0026hellip;\nJiffy services are best tested using a RESTful test utility. If you have a tool that works for you, use that to follow along. If you don\u0026rsquo;t have a test utility, Google\u0026rsquo;s Postman is a great choice and that is what we are going to use for the rest of the quick-start.\nLet\u0026rsquo;s make a quick list of things that we are going to do in order to test our new Person service.\n Login Create a new Person entity Create another new Person entity Read each Person by their key Read a list of Person entities Update a Person entity Create yet another new Person entity See what options we can add to an entity request Delete an entity  "
},
{
	"uri": "https://1414c.github.io/jiffy/generation/gn-content-e/",
	"title": "Generated &#39;models&#39; Folder",
	"tags": [],
	"description": "",
	"content": " The \u0026lsquo;models\u0026rsquo; Folder FirstApp ├── appobj │ ├── appconf.go │ └── appobj.go . . . ├── models │ ├── authm.go │ ├── errors.go │ ├── group_authm.go │ ├── modelfuncs.go │ ├── personm_ext.go │ ├── personm.go │ ├── servicesm.go │ ├── usr_groupm.go │ ├── usrm.go │ └── ext │ └── model_ext_interfaces.go ├── util │ └── strings.go ├── .dev.config.json ├── .prd.config.json ├── main_test.go └── main.go  A model is created for each entity that has been modelled in the .json files, as well as well as the static models used to support users and authorizations.\nModels define an entity\u0026rsquo;s structure and member field characteristics such as type, required/not-required, db-type etc. Each model has a corresponding controller that examines the request, parses the incoming JSON data into the model structure, and then calls the appropriate method in the entity-model based on the end-point / http method. The model provides a validator, which can be used to perform detailed checks and normalizations on the entity data prior to making the call to the ORM.\nEmpty model validations are generated for each entity field, and are designed to be extended by the application developer. Validation methods are generated for each entity field and added to the model\u0026rsquo;s entity validator. For example, the model source file for entity \u0026lsquo;Library\u0026rsquo; (./models/librarym.go), contains a \u0026lsquo;libraryValidator\u0026rsquo; type. Validation methods for each of the library entitys fields are attached to this type.\nThe validator type also contains methods matching the public interface (LibraryDB) of the model\u0026rsquo;s service definition. The model\u0026rsquo;s service declaration includes a validator member, and due to the manner of the declaration, it is the validator that is passed back to the caller (controller) when model access is needed.\n// newLibraryValidator returns a new libraryValidator func newLibraryValidator(ldb LibraryDB) *libraryValidator { return \u0026amp;libraryValidator{ LibraryDB: ldb, } } // NewLibraryService declaration func NewLibraryService(handle sqac.PublicDB) LibraryService { ls := \u0026amp;librarySqac{handle} lv := newLibraryValidator(ls) // *db return \u0026amp;libraryService{ LibraryDB: lv, } }  In the NewLibraryService function, see that two members are declared:\n ls contains an implementation of the generated LibraryDB interface which is used to call the ORM layer following successful execution of the model\u0026rsquo;s validations lv contains an implementation of the generated LibraryDB interface, as well as the set of empty generated field validation methods  Using the creation of a new Library entity as an example, the controller will parse the JSON body of the incoming request into a Library entity struct. The controller will then call the entity\u0026rsquo;s model.Create method. The \u0026lsquo;libraryValidator.Create\u0026rsquo; method (on lv) will execute the implemented field validations, then call the service\u0026rsquo;s model.Create() method (on ls)which will in-turn make the required call to the ORM.\n// Create validates and normalizes data used in the library creation. // Create then calls the creation code contained in LibraryService. func (lv *libraryValidator) Create(library *Library) error { // perform normalization and validation -- comment out checks that are not required // note that the check calls are generated as a straight enumeration of the entity // structure. It may be neccessary to adjust the calling order depending on the // relationships between the fields in the entity structure. err := runLibraryValFuncs(library, lv.normvalName, lv.normvalCity, ) if err != nil { return err } // use method-chaining to call the library service Create method return lv.LibraryDB.Create(library) }  The last line of the method is the most interesting, as it demonstrates something known as method-chaining which allows the call to implicitly access the \u0026lsquo;ls\u0026rsquo; methods. Look carefully at the code in this area so you understand what is happening, and perhaps lookup \u0026lsquo;method-chaining\u0026rsquo; as it pertains to golang.\nNote that at the moment, validations are intended to be coded directly in the body of the generated model code. This is in contrast with the extension-point technique implemented in the controller and at the sqacService level in the model file (see Extension Points in this document). The reasons for this are as follows:\n It is expected that no validations will be coded until the model has been stabilized. It is generally desirable to get an application working (or mostly working), then start worrying about validations. Extension points exist as a convenience in the case where data needs pre/post processing. For most entities, some sort of validation will be required on the majority of fields. We treat the validations as first-class citizens in the application rather than extension-points. By treating validations as first-class citizens we do not need to use type assertion and reflection in the validation layer when performing the checks. If there is a concern regarding the over-writing of coded validations due to application regeneration, it is simple for an application developer to implement their own sub-package with methods or functions containing the check code. The Jiffy application will not over-write files that it is not responsible for during a regeneration of an application.  By default, a CRUD interface is generated for each entity. Using the Library example, the generated code for the CRUD end-points look as follows:\n// ====================== Library protected routes for standard CRUD access ====================== a.router.HandleFunc(\u0026quot;/librarys\u0026quot;, requireUserMw.ApplyFn(a.libraryC.GetLibrarys)).Methods(\u0026quot;GET\u0026quot;).Name(\u0026quot;library.GET_SET\u0026quot;) a.router.HandleFunc(\u0026quot;/library\u0026quot;, requireUserMw.ApplyFn(a.libraryC.Create)).Methods(\u0026quot;POST\u0026quot;).Name(\u0026quot;library.CREATE\u0026quot;) a.router.HandleFunc(\u0026quot;/library/{id:[0-9]+}\u0026quot;, requireUserMw.ApplyFn(a.libraryC.Get)).Methods(\u0026quot;GET\u0026quot;).Name(\u0026quot;library.GET_ID\u0026quot;) a.router.HandleFunc(\u0026quot;/library/{id:[0-9]+}\u0026quot;, requireUserMw.ApplyFn(a.libraryC.Update)).Methods(\u0026quot;PUT\u0026quot;).Name(\u0026quot;library.UPDATE\u0026quot;) a.router.HandleFunc(\u0026quot;/library/{id:[0-9]+}\u0026quot;, requireUserMw.ApplyFn(a.libraryC.Delete)).Methods(\u0026quot;DELETE\u0026quot;).Name(\u0026quot;library.DELETE\u0026quot;)  The generated go struct for the Library model looks as follows:\n// Library structure type Library struct { ID uint64 `json:\u0026quot;id\u0026quot; db:\u0026quot;id\u0026quot; sqac:\u0026quot;primary_key:inc\u0026quot;` Href string `json:\u0026quot;href\u0026quot; db:\u0026quot;href\u0026quot; sqac:\u0026quot;-\u0026quot;` Name string `json:\u0026quot;name\u0026quot; db:\u0026quot;name\u0026quot; sqac:\u0026quot;nullable:false;index:non-unique;index:idx_library_name_city\u0026quot;` City string `json:\u0026quot;city\u0026quot; db:\u0026quot;city\u0026quot; sqac:\u0026quot;nullable:false;index:idx_library_name_city\u0026quot;` }  The model structure and tags are explained:\n   Field Name Description     ID This is the generated key for the entity. The sqac tag \u0026ldquo;primary_key:inc\u0026rdquo; instructs the ORM that this field is to be created as an auto-incrementing column in the backend DBMS.   Href Each entity has an Href field injected into its structure when the application is generated. The Href value provides a direct link to read, update or delete the represented entity. This can be useful if the entity was returned as part of a list, or via a relation-based request. Changes to entities must be carried out via the direct links rather than through relation-type requests. Enforcement of this precludes the requirement of coding / executing additional checks during updates to makes sure that the relationship path is valid. Authorization for end-point access is also simplified via this model. Sqac tag \u0026ldquo;-\u0026rdquo; indicates that this field is not persisted on the database and is not included in the table schema.   Name Name is a field from the model file, and has the following attributes in the backend DBMS based on the sqac tag-values: Not nullable, has a non-unique btree index, is part of a composite (non-unique) index consisting of the \u0026lsquo;name\u0026rsquo; and \u0026lsquo;city\u0026rsquo; table columns.   City City is a field from the model file, and has the following attributes in the backend DBMS based on the sqac tag-values: Not nullable, is part of a composite (non-unique) index consisting of the \u0026lsquo;name\u0026rsquo; and \u0026lsquo;city\u0026rsquo; table columns.    For a more complete explanation of the Sqac ORM tags and operation, see the README.md of the sqac library at: https://github.com/1414C/sqac\nThe models folder also contains an \u0026lsquo;ext\u0026rsquo; sub-directory which is used to hold the interface definitions for model extension-points. See the \u0026lsquo;Extension Points\u0026rsquo; section of this document for more details.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/level-two/l2-content-a/",
	"title": "Login",
	"tags": [],
	"description": "",
	"content": "Launch Postman and specify a target URL of: http://127.0.0.1:8080/usr/login making sure to select the http POST method. Maintain the request body to provide a user-id and password as shown in the following JSON snippet. Typically the user-id for a jiffy application is an email address, but we make an exception for the default administration user.\n{ \u0026quot;email\u0026quot;: \u0026quot;admin\u0026quot;, \u0026quot;password\u0026quot;: \u0026quot;initpass\u0026quot; }  \nWhen you have finshed and your Postman (or other test utility) looks like the following image, click the \u0026lsquo;Send\u0026rsquo; button to post your login request to the running application.  If all goes well, you will get a http response code of 200 (status ok), and a block of JSON with a single \u0026lsquo;token\u0026rsquo; tag containing a jumble of letters and numbers. This is the JWT that will be used to validate our authorization to access the Person entity\u0026rsquo;s service end-points. If you want to read more about JWT\u0026rsquo;s, jwt.io is a good place to start, or you can refer to the Authentication and Authorization sections of this document set. "
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/level-two/l2-content-b/",
	"title": "Create a Person",
	"tags": [],
	"description": "",
	"content": "Now that we have successfully logged into the application and received our first JWT, it is time to create a new Person entity. Start by copying the content of the \u0026lsquo;token\u0026rsquo; tag from the login response body to the clipboard. This JWT must henceforth be included in the http header of every subsequent request.\nCreate a new tab in Postman and specify a target URL of http://127.0.0.1:8080/person with the http POST method. Next, add the following key-value pairs to the http header:\n Content-Type : application\\json Authorization : Bearer *paste-your-JWT-here*  When you have finished maintaining the http header-values, click on \u0026lsquo;Body\u0026rsquo; and maintain it using the \u0026lsquo;raw\u0026rsquo; setting. This will allow you to paste the following JSON code snippet into the request\u0026rsquo;s body:\n{ \u0026quot;name\u0026quot;: \u0026quot;Steve Dallas\u0026quot;, \u0026quot;age\u0026quot;: 46, \u0026quot;weight\u0026quot;: 185, \u0026quot;valid_license\u0026quot;: true, \u0026quot;license_class\u0026quot;: \u0026quot;A\u0026quot; }  \nWhen you have finished, the test session should look as follows and it is time to create our first Person entity. Click \u0026lsquo;Send\u0026rsquo; to post the new entity to the application.\n\nCongratulations! You have created your first Person entity!\nThe router matched the request URL to a route (service end-point), the middleware layer in the matched route examined the JWT, verified it was okay to proceed and then passed the raw JSON from the request body to the Person entity\u0026rsquo;s controller. The controller unmarshalled the JSON into a Person struct and then passed the result to the Create method in the model/validation layer. Validation of the Person struct\u0026rsquo;s content occured, and then a call was made to the underlying ORM to create the entity on the database.\nThe ORM-layer returned the new entity to the application\u0026rsquo;s model-layer, where it was checked and passed back to the controller layer, whereupon it was serialized (struct content becomes JSON) and written to the the response-writer.\nThis is a high-level view of what transpired, but the general flow of things is accurate.\nNotice that the entity passed back to us seems to have a couple of extra fields? All entities created via a jiffy model file are injected with a primary-key of \u0026lsquo;id\u0026rsquo; as well as a non-persistent \u0026lsquo;href\u0026rsquo; field. In this example, our entity\u0026rsquo;s \u0026lsquo;id\u0026rsquo; field was specified to be auto-incrementing with a starting value of 10000000. See the sqac-tag section in the documentation for details regarding key options.\nHref is included in each entity\u0026rsquo;s GET responses, and acts as a self-reference providing the entity\u0026rsquo;s direct access URI to the consumer.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/level-two/l2-content-c/",
	"title": "Create Another Person",
	"tags": [],
	"description": "",
	"content": "Let\u0026rsquo;s change a few things in our request-body and create another Person entity. Edit the JSON body in the request section of your Postman session and click \u0026lsquo;Send\u0026rsquo; when you are ready.\n\nAnother Person entity has been created.\n\nCreate one more Person entity so we have three (or more) in total.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/level-two/l2-content-d/",
	"title": "Get Some Persons",
	"tags": [],
	"description": "",
	"content": "So far we have created two Person entities. We have observed that upon successful creation of an entity, a JSON representation of that entity is passed back to us via the response-writer. Let\u0026rsquo;s now look at how we can get a list of all of our Person entities.\nCreate a new tab in Postman and specify a target URL of http://127.0.0.1:8080/persons making sure to select the http GET method. Next, add the following key-value pair to the http header:\n Authorization : Bearer *paste-your-JWT-here*  When you have finished, the test session should look as follows and it is time to read some Person entities from the database. Click \u0026lsquo;Send\u0026rsquo; to issue our read request to the application.\n\nWe just read the complete list of Person entities. Adding an \u0026rsquo;s\u0026rsquo; to the entity name and issuing the request with a GET http verb tells a jiffy application to read all of the Person entities. In some cases this looks odd, but it makes it quite easy to consume the services. Notice that the \u0026lsquo;href\u0026rsquo; field of each Person entity provides a direct link to the entity that it is a part of.\n\n"
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/level-two/l2-content-e/",
	"title": "Get a Person",
	"tags": [],
	"description": "",
	"content": "What if we need to read a single Person, or isolate a Person entity from a list of entities? Let\u0026rsquo;s try reading a Person entity using its \u0026lsquo;id\u0026rsquo; key.\nCreate a new tab in Postman and specify a target URL of http://127.0.0.1:8080/person/10000001 making sure to select the http GET method. Next, add the following key-value pair to the http header:\n Authorization : Bearer *paste-your-JWT-here*  When you have finished, the test session should look as follows and it is time to read Person 10000001 from the database. Click \u0026lsquo;Send\u0026rsquo; to issue our read request to the application.\n\nWe just read the Person entity with \u0026lsquo;id\u0026rsquo; key 10000001. While this is not a very human-friendly way to search for a Person, it is a simple way to isolate and reference an entity for reading, updating or deletion.\n\n"
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/level-two/l2-content-f/",
	"title": "Update a Person",
	"tags": [],
	"description": "",
	"content": "If you have been following along, we have created Person entities, read Person entities both in bulk and by \u0026lsquo;id\u0026rsquo; key. We are now going to take a look at updating an existing entity.\nRead Person entity 10000001 from the database as shown in the Get a Person example.\nOnce you have successfully read Person entity 10000001 into your Postman session, copy the content of the response body to your clipboard. We are going to reuse our GET Person Postman tab to perform an update, so change the http verb from GET to PUT. Changing the http verb to PUT will allow us to maintain the request-body in our Postman tab. Next, add the following key-value pair to the http header:\n Content-Type : application\\json  Now paste the GET Person response-body into the request-body of our new PUT request, then edit it so that Opus\u0026rsquo;s full name is given. Strictly speaking, you do not need to include the \u0026lsquo;id\u0026rsquo; or \u0026lsquo;href\u0026rsquo; fields in an update, but it does not hurt anything to do so.\n{ \u0026quot;id\u0026quot;: 10000001, \u0026quot;href\u0026quot;: \u0026quot;http://127.0.0.1:8080/person/10000001\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Opus the Penguin\u0026quot;, \u0026quot;age\u0026quot;: 8, \u0026quot;weight\u0026quot;: 385, \u0026quot;valid_license\u0026quot;: false }  \nWhen you have finished, you should have something that looks as follows. Click \u0026lsquo;Send\u0026rsquo; to issue the PUT request to the application.\n\nThe PUT request should update the entity using the \u0026lsquo;id\u0026rsquo; key as its update criteria, and then return a JSON representation of the updated entity. This is a little different than other approaches, where the result of an update is measured simply by the http response code. If you don\u0026rsquo;t like the way this works, it is very easy to update the generated source code to omit the response body following a PUT.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/level-two/l2-content-g/",
	"title": "Get Persons With Restrictions",
	"tags": [],
	"description": "",
	"content": "We have seen how to Create, Get, and Update a Person entity, but before we get around to the Delete operation, let\u0026rsquo;s take a quick look at some other simple things we can do with Get entity lists.\n  Get a count of Person entities in the database   http://127.0.0.1:8080/persons/$count .\n    Get all Person entities in the database ordered-by age   http://127.0.0.1:8080/persons$orderby=age .\n \n  Get all Person entities in the database ordered-by age descending   http://127.0.0.1:8080/persons$orderby=age$desc .\n \n  Get all Person entities in the database ordered-by age descending with a selection offset of 1   http://127.0.0.1:8080/persons/$orderby=age$desc$offset=1 .\n \n  Get all Person entities in the database ordered-by age descending with a limit of 2   http://127.0.0.1:8080/persons/$orderby=age$desc$limit=2 .\n \n  Get all Person entities in the database with name like %qui%   http://127.0.0.1:8080/persons/name(LIKE 'qui') .\n \n  Get all Person entities in the database with age equal to 46   http://127.0.0.1:8080/persons/$age(EQ 46) .\n \n"
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/level-two/l2-content-h/",
	"title": "Delete a Person",
	"tags": [],
	"description": "",
	"content": "Time to delete one of our Person entities. Create a new tab in Postman and specify a target URL of http://127.0.0.1:8080/person/10000000 with the http DELETE method. Next, add the following key-value pairs to the http header:\n Content-Type : application\\json Authorization : Bearer *paste-your-JWT-here*  When you have something that looks as follows, click the \u0026lsquo;Send\u0026rsquo; button to issue the delete request to the application.\nIf the delete request was successful, you will see a http response-code of 202 (Accepted). Try to read the entity by converting your delete request into a get request and verify that Person entity 10000000 has truly been deleted.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/level-two/l2-content-i/",
	"title": "Next Steps",
	"tags": [],
	"description": "",
	"content": "That is a quick overview of the sort of things you can do with an application generated by Jiffy. There is a lot more to see however!\nGood places to start would be in the Jiffy Overview and the Model File section.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/",
	"title": "",
	"tags": [],
	"description": "",
	"content": " Jiffy RESTful Services Generator Jiffy is a model-based RESTful application services generator written in Go. Jiffy processes model files to generate Go source code for a complete backend services application. It was originally developed as an experiment to offer an alternative avenue when developing native applications for SAP Hana. The Jiffy application allows a developer to treat the data persistence layer as an abstraction, thereby removing the need to make use of CDS and the SAP XS(A) libraries.\nWhile this is not for everybody, it does reduce the mental cost of entry and allows deployment of a web-based application on SAP Hana with virtually no prior Hana knowledge. Jiffy also works nicely with other databases.\nMain Features  generated applications can be connected to Postgres, MSSQL, SAP Hana, SQLite or MariaDB with no source-code changes no database specific code is compiled into the binary bcrypt salt/pepper based authentication scheme session management and end-point authorizations are provided via jwt built-in support for the creation of jwt signing-keys service end-points are secured by way of jwt claims in the route handler middleware service end-point security is generated by default, along with corresponding authorization objects uses JSON model file(s) for Entity, Index, Relationship and Foreign-Key definitions generates a set of CRUD-type RESTful services for each entity in the model file(s) built-in support for https getSet type end-points support /$count, $limit=n, $offset=n, $orderby=field_name ($asc|$desc) generates end-points for hasOne, hasMany and belongsTo entity relationships generates static query end-points each entity\u0026rsquo;s corresponding service can be enabled and disabled on a per process basis generated models support persistent and non-persistent fields generated apps create and alter backend database artifacts based on model definitions baked in normalization and validation in the model-layer generates a comprehensive set of working tests via go test generated code is easily extended either via direct editing, or through an extension-point concept is designed to be deployed across multiple VM\u0026rsquo;s or containers by way of a leader-election and failure detection subsystem utilizes an internally replicated cache for user, user-group and authorization artifacts entity caching can be easily extensible via enhancement-points in the controller or model layers (redis / memcached for example)  "
},
{
	"uri": "https://1414c.github.io/jiffy/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://1414c.github.io/jiffy/credits/",
	"title": "Credits",
	"tags": [],
	"description": "",
	"content": " Contributors Thanks to them  for making Open Source Software a better place !\nPackages and libraries  sqlx jwt-go go-sql-driver/mysql lib/pq go-sqlite3 go-mssqldb go-hdb  Tooling  Hugo Hugo Learn Theme  "
},
{
	"uri": "https://1414c.github.io/jiffy/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]