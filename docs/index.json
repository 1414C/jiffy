[
{
	"uri": "https://1414c.github.io/jiffy/getting-started/gs-content-a/",
	"title": "Go Environment",
	"tags": [],
	"description": "",
	"content": "If you already have Go installed and know that your installation is working, you should skip to the next section. If you need to get Go installed on your machine, keep reading.\nGo is easy to setup and can be installed from source or binary package, both which are available at golang.org.\n Go binary installation instructions Go build-from-source installation instructions  "
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/",
	"title": "Getting Started",
	"tags": [],
	"description": "",
	"content": " Getting Started Initial Setup Before we get start generating services, there are few things to get out of the way. First we need to make sure that the Go environment is setup, then we need to get jiffy installed.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/overview/",
	"title": "Jiffy Overview",
	"tags": [],
	"description": "",
	"content": " Overview and Features Jiffy "
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/gs-content-b/",
	"title": "Installing Jiffy",
	"tags": [],
	"description": "",
	"content": "The easiest way to install Jiffy is to use go get on the command-line to pull the latest version from github, as shown below:\n$ go get -u github.com/1414C/jiffy  This will pull the jiffy github repository into your $GOPATH/src/github.com folder, as well as any dependencies referenced by the jiffy source code. The -u flag is included to instruct go get to check for and pull updates to jiffy packages and their dependencies. This is the least sophisticated way of managing dependencies in go.\nOnce the jiffy source code and dependencies have been installed into your $GOPATH, you can use go build to compile a binary from the jiffy sources. The easiest way to do this is to open a terminal window, switch to $GOPATH/src/github.com/1414C/jiffy and run go build as shown below.\n$ go build -v  This will result in the creation of a binary file called \u0026lsquo;jiffy\u0026rsquo;. You may move the \u0026lsquo;jiffy\u0026rsquo; binary anywhere in your $PATH, but convention would have you install it in /usr/local/bin. Once you have moved the \u0026lsquo;jiffy\u0026rsquo; binary to its new home, open a new terminal window and use the which command to ensure that you can access the binary.\n$ which jiffy -a  If which cannot find the jiffy binary (or finds the wrong one!), you need to make sure that your $PATH is set correctly.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/overview/ov-content-a/",
	"title": "What is Jiffy?",
	"tags": [],
	"description": "",
	"content": " What does Jiffy do? Jiffy is a model-based RESTful application services generator written in go. It was developed as an experiment to offer an alternative avenue when developing native applications for SAP Hana.\nJiffy allows a developer to generate a robust go-based application that treats the data persistence layer in a generic manner. This allows the generated application to connect to number of different database systems (outlined below), without any code changes.\nWhile this is not for everybody, it does reduce the mental cost of entry to developing and deploying appications on SAP Hana, as the backend application developer can focus on the application rather than Hana CDS and the Hana XS/XSA libs. Generated applications are by no means only targeted at SAP Hana; Postgres, MySQL, MSSQL and SQLite are also supported.\nWhy write in Go?  Go has a good standard library, thereby keeping dependencies on public packages to a minimum Go offers concurrency via lightweight threads known as goroutines  no blocking in the i/o layer during compute intensive tasks no lost callbacks or broken promises goroutines will use all available cores to handle incoming requests  Go offers type-safety Go is a small language Go projects compile to a static single binary which simplifies deployments Go cross-compiles to virtually any platform and architecture; write and test on a chromebook - deploy to amd64/ppc64/arm64/s390  What does a Jiffy application provide out of the box? Jiffy consumes simple JSON model-files and uses them to generate a working, secure and extensible application server codebase. Generated applications need no additional coding to run, although we suggest that you may wish to implement some validations and do a bit of testing before you roll things out.\nHere are some of the features that are automatically included in a generated Jiffy application:\n generated applications can be connected to Postgres, MSSQL, SAP Hana, SQLite or MariaDB no database specific code is compiled into the binary; an app can be pointed from SQLite to SAP Hana with no code changes login / authorization management via jwt built-in support for the creation of signing-keys for jwt (RS256, RS384, RS512, ES256, ES384, ES521) supports JWT\u0026rsquo;s created by other SSO auth providers (RS256, RS384, RS512, ES256, ES384, ES521) bcrypt salt/pepper based authentication scheme where passwords are never stored in the db JSON configuration (model) file(s) for Entity, Index, Foreign-Key and Relationship definitions models support persistent and non-persistent fields generated apps create and alter database artifacts based on the model file (tables, indices, sequences etc.) supports single and composite index declarations via the model file built-in support for https built-in normalization and validation in the model-layer each entity\u0026rsquo;s correspsonding service can be enabled and disabled on a per-app-server basis based on config generates a working set of CRUD-type RESTful services for each entity in the model file get-set type end-points support /$count, $limit=n, $offset=n, $orderby=field_name ($asc|$desc) supports and generates working end-points for hasOne, hasMany and belongsTo entity relationships generates static query end-points end-points are secured by way of scope inspection (jwt claims) in the route handler middleware end-point security is generated by default via a auths -\u0026gt; auth-groups -\u0026gt; user arrangement generates a comprehensive set of working tests (go test) generated code is easily extended either via direct editing, or through an extension-point concept in the model and controller-layers a leader-election-based group-membership service exists between running instances of the application to facilite internal caching of user information  How does Jiffy interface to the underlying database? Jiffy sits on top of a thin ORM that was written to talk to the SAP Hana in-memory db. The ORM code is very simple, and can easily be extended to accomodate databases that have not been mentioned here.\nORM\u0026rsquo;s sound like a bad idea to a lot of people (me included). If you look at the generated code and don\u0026rsquo;t like what you see, the ORM handle exposes the standard go/sql and the awesome jmoiron/sqlx libraries to you directly. This will effectively allow you to make use of the generated applcation, but code the SQL against the database using the standard go/sql package.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/gs-content-c/",
	"title": "Let&#39;s Build Something",
	"tags": [],
	"description": "",
	"content": "Now that Jiffy is installed, we will build a simple service to test it out.\nJiffy\u0026rsquo;s source tree comes with a number of sample model files that you can use to get the hang of things. We are going to use a simple model file that contains an entity named \u0026lsquo;Person\u0026rsquo;. The model file can be found in the Jiffy source tree, or pulled directly from the Jiffy github repository.\n $GOPATH/src/github.com/1414C/jiffy/support/testing_models/simpleSingleEntityModel.json jiffy repository  For now we are not going to worry about the content of the model file, but we will look at the structure of our new \u0026lsquo;Person\u0026rsquo; entity briefly.\n// Person structure type Person struct { ID uint64 `json:\u0026quot;id\u0026quot; sqac:\u0026quot;primary_key:inc;start:10000000\u0026quot;` Href string `json:\u0026quot;href\u0026quot; sqac:\u0026quot;-\u0026quot;` Name *string `json:\u0026quot;name,omitempty\u0026quot; sqac:\u0026quot;nullable:true;index:non-unique\u0026quot;` Age *uint `json:\u0026quot;age,omitempty\u0026quot; sqac:\u0026quot;nullable:true\u0026quot;` Weight *float64 `json:\u0026quot;weight,omitempty\u0026quot; sqac:\u0026quot;nullable:true\u0026quot;` ValidLicense *bool `json:\u0026quot;valid_license,omitempty\u0026quot; sqac:\u0026quot;nullable:true;index:non-unique\u0026quot;` }  We can see that jiffy will create a Person model with a small set of fields, each with a number of attributes. For the moment, we will concern ourselves only with the field names and types, as we will need to use this information to construct some tests for the new service.\n\u0026lsquo;sqac\u0026rsquo; tags are used to pass information to jiffy\u0026rsquo;s ORM layer.\n \nCreate a new target directory for your project under $GOPATH/src.\n$ cd $GOPATH/src $ mkdir jiffy_tests  \nExecute the jiffy binary, specifying the model file to use, as well as the target directory/project name.\n$ jiffy -m $GOPATH/src/github.com/1414C/jiffy/support/testing_models/simpleSingleEntityModel.json -p /jiffy_tests/first_app  -m tells jiffy which model file should be used to construct the new service.\n-p tells jiffy where to write the generated application code.\nNote that the location of the folder specified by the -p flag is deemed to be relative to $GOPATH/src.\n \nIf everything has gone according to plan, a new application has been generated and should be ready to run. Let\u0026rsquo;s take a look at what jiffy generated for us!\n$ cd $GOPATH/src/jiffy_tests/first_app $ ls -l  This should result in a list of the files and folders comprising our new application.\ndrwxr-xr-x 12 stevem staff 384 5 Feb 21:44 . drwxr-xr-x 10 stevem staff 320 5 Feb 21:44 .. -rwxr-xr-x 1 stevem staff 588 5 Feb 21:44 .dev.config.json -rwxr-xr-x 1 stevem staff 611 5 Feb 21:44 .prd.config.json drwxr-xr-x 4 stevem staff 128 5 Feb 21:44 appobj drwxr-xr-x 10 stevem staff 320 5 Feb 21:44 controllers drwxr-xr-x 4 stevem staff 128 5 Feb 21:44 jwtkeys -rwxr-xr-x 1 stevem staff 839 5 Feb 21:44 main.go -rwxr-xr-x 1 stevem staff 18421 5 Feb 21:44 main_test.go drwxr-xr-x 3 stevem staff 96 5 Feb 21:44 middleware drwxr-xr-x 12 stevem staff 384 5 Feb 21:44 models drwxr-xr-x 3 stevem staff 96 5 Feb 21:44 util $  Jiffy generates two sample configuration files each time it is executed. We are going to run our application with development environment settings, so lets take a quick look at .dev.config.json to make sure there are no horrible surprises.\n{ \u0026quot;port\u0026quot;: 8080, \u0026quot;env\u0026quot;: \u0026quot;dev\u0026quot;, \u0026quot;pepper\u0026quot;: \u0026quot;secret-pepper-key\u0026quot;, \u0026quot;database\u0026quot;: { \u0026quot;db_dialect\u0026quot;: \u0026quot;sqlite\u0026quot;, \u0026quot;host\u0026quot;: \u0026quot;127.0.0.1\u0026quot;, \u0026quot;port\u0026quot;: 0, \u0026quot;usr\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;password\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;testdb.sqlite\u0026quot; }, \u0026quot;cert_file\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;key_file\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;jwt_priv_key_file\u0026quot;: \u0026quot;jwtkeys/private.pem\u0026quot;, \u0026quot;jwt_pub_key_file\u0026quot;: \u0026quot;jwtkeys/public.pem\u0026quot;, \u0026quot;service_activations\u0026quot;: [ { \u0026quot;service_name\u0026quot;: \u0026quot;Person\u0026quot;, \u0026quot;service_active\u0026quot;: true } ] }  Jiffy decides by default to run against a sqlite database and generates what should be a suitable configuration file for most systems. Again, we are not going to worry too much about what is in the configuration file at this point, but know that database file \u0026lsquo;testdb.sqlite\u0026rsquo; will be created in the generated application\u0026rsquo;s root folder.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/overview/ov-content-b/",
	"title": "Jiffy Application Overview",
	"tags": [],
	"description": "",
	"content": " What does a generated Jiffy application look like? Generated Jiffy applications can be pointed at the DBMS of your choice without the need to recompile the binary (architecture differences not withstanding). This means that a developer can build a model, fully test it locally using SQLite and then redirect the appplication to a formal testing environment running SAP Hana, or any of the other supported database systems.\nApplications are generated based on model files which are encoded as simple JSON. The concepts of entity and resource-id form the cornerstones upon which the model, application and RESTful end-points are built.\nEntities can be thought of anything that needs to be modelled; Order, Customer, Invoice, Truck, \u0026hellip;, \u0026hellip; Each entity is mandated to have an ID field, which is analagous to a primary-key or row-id in the backend database. ID is used as the primary resource identifier for an entity, and is setup by default as an auto-incrementing column in the database. ID is implemented as go-type uint64 and is inserted into the model entity definition during application generation.\nSimple CRUD Access Accessing an entity via the generated CRUD interface is very simple. For example, a customer entity could be defined in the model and then accessed via the application as follows:\n Create a customer entity:\n https://servername:port/customer + {JSON body}  Update a customer entity:\n https://servername:port/customer/:id + {JSON body}  Read a customer entity:\n https://servername:port/customer/:id  Delete a customer entity:\n https://servername:port/customer/:id  Read all customer entities:\n https://servername:port/customers   Filters and Relationships Additional routes can also be generated based on the model file, including custom filters for GET operations, static end-points for common GET operations, HasOne, HasMany and BelongsTo relationships:\n Use a filter to Get customers where the last name is \u0026lsquo;Smith\u0026rsquo;:\n https://servername:port/customers/?last_name=Smith  Use a generated static end-point to Get customers where credit score is less than 4:\n https://servername:port/customers/credit_score(LT 4)  Use a generated relationship to retrieve all orders for a specific customer (10023):\n https://servername:port/customer/10023/orders  Use a generated relationship to retrieve a specific order (99000022) for the specified customer (10023):\n https://servername:port/customer/10023/order/99000022  Use a generated belongsTo relationship to retrieve the customer for a specific order (990000222):\n https://servername:port/order/99000022/customer   Commands A set of commands can be appended to an operation\u0026rsquo;s URL to perform some common activities. The commands can be appended to the URL in any order.\n Get a count of all customer entities:\n https://servername:port/customer/$count  Limit the number of returned customer entities to 3. The default ordering for this example would be ascending based on the entity ID field.\n https://servername:port/customer/$limit=3  Offset the database selection by 2 records, top-down, using the default order; (ascending based on the entity ID field):\n https://servername:port/customer/$offset=2  Select records in descending order based on the entity ID field:\n https://servername:port/customer/$desc  Select records in descending order using the customer name field as the order-by criteria:\n https://servername:port/customer/$orderby=name$desc  Limit the number of selected records to 3 and select in descending order based on the entity ID field:\n https://servername:port/customer/$limit=3/$desc  Limit the number of selected records to 3 and select in ascending order using the customer name field as the order-by criteria:\n https://servername:port/customer/$limit=3;$orderby=name$asc  Limit the number of selected records to 3 with an offset of 2 and select the records in ascending order using the customer name field as the sort criteria:\n https://servername:port/customer/$limit=3$offset=2$orderby=name$asc  Limit the return of a static filter end-point to 3 records:\n https://servername:port/customers/credit_score(LT4)/$limit=3   More details regarding application modlelling are contained in later sections of this documentation.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/overview/ov-content-c/",
	"title": "Jiffy Application Structure",
	"tags": [],
	"description": "",
	"content": " Jiffy Application File Structure This is what Jiffy generates when provided with a model-file describing a simple \u0026lsquo;Person\u0026rsquo; entity. The structure and files look more or less standard if you are used to looking at such things. Explanations of each folder and its content are discussed thoughout the documentation.\nFirstApp ├── appobj │ ├── appconf.go │ └── appobj.go ├── controllers │ ├── authc.go │ ├── controllerfuncs.go │ ├── groupauthc.go │ ├── person_relationsc.go │ ├── personc.go │ ├── usrc.go │ ├── usr_groupc.go │ └── ext │ ├── extc_interfaces.go │ └── personc_ext.go ├── group │ ├── gmcl │ │ ├── gmclient.go │ ├── gmcom │ │ ├── gmcache.go │ │ ├── gmclsrv.go │ │ ├── gmerrors.go │ │ └── gmomap.go │ └── gmsrv │ ├── gmprocessors.go │ ├── gmprotocol_senders.go │ ├── gmserver.go │ └── gmtxrx.go ├── jwtkeys │ ├── private.pem │ └── public.pem ├── middleware │ └── requireuser.go ├── models │ ├── authm.go │ ├── errors.go │ ├── group_authm.go │ ├── modelfuncs.go │ ├── personm_ext.go │ ├── personm.go │ ├── servicesm.go │ ├── usr_groupm.go │ ├── usrm.go │ └── ext │ └── model_ext_interfaces.go ├── util │ └── strings.go ├── .dev.config.json ├── .prd.config.json ├── main_test.go └── main.go  Jiffy Application Services Jiffy approaches the API from a services perspective. Each entity has a corresponding service that can be started when the application initializes. The Usr, UsrGroup, Auth and GroupAuth services are always generated by default when creating a Jiffy application. Additional services are generated based on the model files created based on the business scenario.\ngraph LR; A[Hard edge] --|Link text| B(Round edge) B -- C{Decision} C --|One| D[Result one] C --|Two| E[Result two]  \ngraph LR; A[Hard edge] --|Link text| B(Round edge) B -- C{Decision} C --|One| D[Result one] C --|Two| E[Result two]  \ngraph TD A[Christmas] --|Get money| B(Go shopping) B -- C{Let me think} C --|One| D[Laptop] C --|Two| E[iPhone] C --|Three| F[Car]  \n"
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/gs-content-d/",
	"title": "Let&#39;s Run Something",
	"tags": [],
	"description": "",
	"content": "Let\u0026rsquo;s execute our first application!\n$ cd $GOPATH/src/jiffy_tests/first_app $ go run main.go -dev -rs  Executing with the -dev and -rs flags instructs our new application to initialize itself using the development settings file, and forces a rebuild of the \u0026lsquo;Super\u0026rsquo; authorization-group. Consequently, you will see some warning and info messages scroll up the screen which is perfectly normal.\n2018/02/05 22:29:26 package sqac init is running 2018/02/05 22:29:26 successfully loaded the config file... 2018/02/05 22:29:26 JWTPrivKeyFile: jwtkeys/private.pem 2018/02/05 22:29:26 JWTPubKeyFile: jwtkeys/public.pem 2018/02/05 22:29:26 warning: auth usr.GET_SET not found in the db Auth master data 2018/02/05 22:29:26 warning: auth usr.CREATE not found in the db Auth master data 2018/02/05 22:29:26 warning: auth usr.GET_ID not found in the db Auth master data ... ... 2018/02/05 22:29:26 info: creating auth usr.GET_SET in the db Auth master data 2018/02/05 22:29:26 warning: new auth usr.GET_SET must be added to at least one group 2018/02/05 22:29:26 info: creating auth usr.CREATE in the db Auth master data 2018/02/05 22:29:26 warning: new auth usr.CREATE must be added to at least one group ... ... 2018/02/05 22:29:26 warning: new auth person.STATICFLTR_ByValidLicense must be added to at least one group 2018/02/05 22:29:26 info: creating auth person.STATICFLTR_CMD_ByValidLicense in the db Auth master data 2018/02/05 22:29:26 warning: new auth person.STATICFLTR_CMD_ByValidLicense must be added to at least one group 2018/02/05 22:29:26 The Super UsrGroup has been initialized with 42 Auth objects. 2018/02/05 22:29:26 re-initializing local middleware to accomodate Super group changes. 2018/02/05 22:29:27 admin user created with ID: 1 and initial password of initpass Development settings selected... Starting http server on port... 8080  You should see a message indicating that the application is running. During the startup, the application executed a number of steps.\n Loaded the development configuration file. Initialized a handle to the underlying ORM. Checked for and loaded the public and private keys for JWT support. Checked for and created the user, auth, and usergroup tables in the database. Checked for and created the person table in the database based on the Person model. Checked for and created authorizations in the database for each service end-point. Checked for and created the Super user-group in the database. Assigned all authorizations to the Super user-group. Created the \u0026lsquo;admin\u0026rsquo; user and assigned it to the \u0026lsquo;Super\u0026rsquo; user-group. Initialized the authorization cache in the router. Started the router.  Congratulations! Your first application is now open for business at http://127.0.0.1:8080\n"
},
{
	"uri": "https://1414c.github.io/jiffy/overview/ov-content-d/",
	"title": "Jiffy Application Architecture",
	"tags": [],
	"description": "",
	"content": " Jiffy Application Architecture Jiffy approaches the API from a services perspective. Each entity has a corresponding service that can be started when the application initializes. The Usr, UsrGroup, Auth and GroupAuth services are always generated by default when creating a Jiffy application. Additional services are generated based on the content of your project\u0026rsquo;s model files.\nGenerated application services can be broken down into five high-level areas: \ngraph TD; subgraph A(End-Points)--B(Middleware) B--C(Controllers) C--D(Models) D--E(Database) end  \n End-Points expose the service APIs to the consumer such as a web-app or another server. End-points may be customized by way of the application model files. Middleware provides user authentication / authorization services and is tightly-coupled to the end-point definitions. The middleware offers comprehensive services such as authorization via JWT claims inspection, as well as some caching of user and group authorization details. This is an area of active development. Controllers are the entry point into the application proper, and are called after a request has been granted access to the end-point by the middleware. It is here that the body of the request is unmarshalled and mapped into the correct go model structure. Extension-points conforming to standard Jiffy interfaces are provided in the controllers for post-generation enhancements. Models are where the entity data from the request is checked, normalized and prepared for submission to the database. Extension-points conforming to standard Jiffy interfaces are provided in the models for post-generation enhancements. Database refers to the backend DBMS that is being used to house the entity data. Jiffy generated applications can connect to PostgreSQL, MariaDB/MySQL, MSSQL, SAP HanaDB or SQLite. It is easy to extend the database support to other relational platforms provided that there is an existing go sql driver for the database in question. It is possible to override the generated Jiffy call to the database and \u0026lsquo;roll-your-own\u0026rsquo; should the need arise.  "
},
{
	"uri": "https://1414c.github.io/jiffy/overview/ov-content-e/",
	"title": "Jiffy Development Steps",
	"tags": [],
	"description": "",
	"content": " Jiffy Pre-Generation Workflow Jiffy is intended to generate a clean, straight-forward and secure application services platform just like the one you would write by hand. Jiffy originally started as a few go templates I used to generate boiler-plate code that I do not like to type. Generation is a lot nicer than cut-and-paste. There are places in the generated code where things could be more elegant, but the code is intended to be easy to work on even if one is not familliar with it. File and folder names are somewhat subjective; I have tried to be descriptive and organized.\nDesign Steps  You are building a back-end of some sort where you need to reliably read and write data. Before you start messing around with a real Jiffy model of your application, try some of demo models to get a feel for what Jiffy is and what it isn\u0026rsquo;t. Its a lot easier to design if you know what the platform provides, and what it does not.\n Start messing around with entity ideas. What is the best way to represent your data? Transfering your ideas into a few rough diagrams often changes your understanding of what you are modelling.\n Consider the relationships you would like to have between your entities. Does your model still hold up?\n Add some detail to your proposed entities in terms of fields. Remember that Jiffy will insert a primary-key (id), as well as a self-referencing entity href into the model for you. This is important when you are considering relationships, as Jiffy applications have some expectations regarding the name of the referencing field. See the Relations section of this documentation set for details.\n Once you are comfortable with the entities and the fields that they will contain it is time to create the model in the Jiffy model file format.\n Jiffy model files are simple JSON and at the moment need to be coded up by hand. Taking a copy of one of the sample model-files is the best way to start. Short of creating a graphical model file generator, maintaining the models via direct file maintenance is the most direct and transparent way to edit them. Remember that you do not have to put your entire model in one file. Jiffy is quite happy to accept any number of model files for your project with the entities defined in any order. The generator will sort it all out.\n Check your model files as best as possible before feeding them into Jiffy. If you get an error, don\u0026rsquo;t worry; I get them all the time too. Look at the error message, then check the model-file for problems. If you can\u0026rsquo;t see anything wrong, log an issue and I will take a look. Usual suspects for errors are missing double-quotes on field-names or string-values, missing closing parentheses on a list, missing brace on struct or sub-struct, putting quotes on a bool value, putting quotes on an int or dec value etc.\n Again, don\u0026rsquo;t worry too much about formal inter-entity rules in the beginning. The idea is to get something up and running fast so you can try out the services. You can generate your application many times over without touching anything but the model-file / model-files. Generation is fast - less than 2 seconds for most models.\n Generate a version of your application and start it up. Try it out with a tool like Postman. See the Quickstart for an overview of application generation through to application testing, or go to the formal section dealing with each of the appliation creation steps.\n It is not (typically) neccessary to do early development testing via https. If this is not the case for you, see the testing with https section in this document set. Step-by-step instructions are given to create and install self-signed certificates that will permit you to test locally with https.\n As you test your application, you will probably see some fields missing, some fields that you don\u0026rsquo;t care for, and maybe the need for an additional entity. Update your model files and generate the application again. Try it out. Repeat.\n As your model becomes more refined, consider formally adding relationships. Generate, test, repeat.\n Consider foreign-keys. Generate, test, repeat.\n Consider start-values for id. Not everybody is okay to start at 1, particularly if you are planning on migrating existing data into your application. Generate and test.\n Consider static-queries and add the selection options to each field that can be queried. Generate, test, repeat. See the static query section for details.\n Consider indices and add indexes to the model definitions where needed. Generate, test, repeat.\n Access restrictions can be assigned at the end-point-level, and this is built into the generated application. Don\u0026rsquo;t worry about testing authorization and authentication for now.\n  Development  When you are satisfied with your model, generate a version of the application and place it under source-code control.\n Implement extension-points in the controller and model go source as per your requirements. Implemented extension-points will not be over-written should you need to regenerate the application. Test often.\n Implement normalization and validation at the field-level in the generated entity model go source file. This part is slightly contentious, as field normalization and validiation is performed directly in the generated code, rather than off to the side in extension-points. We suggest that if you are worried about over-writing your normalization and validation code with an accidental regeneration, you create a model_normalization package for each model and implement field-level normalizations and checks there. Of course, you are free to ignore the provided field-level normalization and validation methods and perform all checks in one of the model extension-points. Its up to you, and it will make more sense once you take a look through one of the generated files.\n When you are happy with the way things are working, think about user access. Sketch out user-groups and assign end-points to them until you have something that you like. Use Postman to create UserGroups and assign Auths to them, then create new users and allocate the relevant UserGroups to their ID. That is all you need to do; the Jiffy middleware will take care of the rest. See the Authentication and Authorization section for a detailed discussion of how users are authenticated and authorized.\n  Deployment Jiffy generated applications can be deployed in any number of ways. For example:\n On your laptop On a server under your desk On a blade running the os of your choice On a VM (xen etc.) Docker image / Droplet / Cloud Foundry etc. Across a collection of the above  At the software level, the Jiffy generated application can be deployed as:\n A single application server talking to a database on your SAN Multiple application servers talking to a database on your SAN Application server and Database server on the same box/image etc.  Considerations for deployment  SSL certificates Do you need to support JWT\u0026rsquo;s from other SSO providers? If so, you will need their public-keys. JWT expiration policy You have tested your user-access revocation? Jiffy makes provisions for the revocation of user-access based on the user master. If a user is deleted or marked as inactive, even a valid JWT for that user will not permit access. Data migration; have you run real test migrations with the key relationships etc. in place? If you disabled certain database features for migration, have you turned them back on again? Looking at you foreign-keys\u0026hellip; User access; users have been assigned to Groups and the create/update/delete end-points are locked down in accordance with your use-cases? Do you need a reverse-proxy / is there a need to route traffic based on expected load? Service activations; is there a need to route traffic based on expected load? If you need to scale horizontally or vertically do you have a plan?  "
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/level-two/",
	"title": "Let&#39;s Test Something",
	"tags": [],
	"description": "",
	"content": "We have a running application, but what can we do with it? If you clicked on the http://127.0.0.1:8080 link at the end of the preceding section, you didn\u0026rsquo;t get a very good looking response\u0026hellip;\nJiffy services are best tested using a RESTful test utility. If you have a tool that works for you, use that to follow along. If you don\u0026rsquo;t have a test utility, Google\u0026rsquo;s Postman is a great choice and that is what we are going to use for the rest of the quick-start.\nLet\u0026rsquo;s make a quick list of things that we are going to do in order to test our new Person service.\n Login Create a new Person entity Create another new Person entity Read each Person by their key Read a list of Person entities Update a Person entity Create yet another new Person entity See what options we can add to an entity request Delete an entity  "
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/level-two/l2-content-a/",
	"title": "Login",
	"tags": [],
	"description": "",
	"content": "Launch Postman and specify a target URL of: http://127.0.0.1:8080/usr/login making sure to select the http POST method. Maintain the request body to provide a user-id and password as shown in the following JSON snippet. Typically the user-id for a jiffy application is an email address, but we make an exception for the default administration user.\n{ \u0026quot;email\u0026quot;: \u0026quot;admin\u0026quot;, \u0026quot;password\u0026quot;: \u0026quot;initpass\u0026quot; }  \nWhen you have finshed and your Postman (or other test utility) looks like the following image, click the \u0026lsquo;Send\u0026rsquo; button to post your login request to the running application.  If all goes well, you will get a http response code of 200 (status ok), and a block of JSON with a single \u0026lsquo;token\u0026rsquo; tag containing a jumble of letters and numbers. This is the JWT that will be used to validate our authorization to access the Person entity\u0026rsquo;s service end-points. If you want to read more about JWT\u0026rsquo;s, jwt.io is a good place to start. "
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/level-two/l2-content-b/",
	"title": "Create a Person",
	"tags": [],
	"description": "",
	"content": "Now that we have successfully logged into the application and received our first JWT, it is time to create a new Person entity. Start by copying the content of the \u0026lsquo;token\u0026rsquo; tag from the login response body to the clipboard. This JWT must henceforth be included in the http header of every subsequent request.\nCreate a new tab in Postman and specify a target URL of http://127.0.0.1:8080/person with the http POST method. Next, add the following key-value pairs to the http header:\n Content-Type : application\\json Authorization : Bearer *paste-your-JWT-here*  When you have finished maintaining the http header-values, click on \u0026lsquo;Body\u0026rsquo; and maintain it using the \u0026lsquo;raw\u0026rsquo; setting. This will allow you to paste the following JSON code snippet into the request\u0026rsquo;s body:\n{ \u0026quot;name\u0026quot;: \u0026quot;Steve Dallas\u0026quot;, \u0026quot;age\u0026quot;: 46, \u0026quot;weight\u0026quot;: 185, \u0026quot;valid_license\u0026quot;: true, \u0026quot;license_class\u0026quot;: \u0026quot;A\u0026quot; }  \nWhen you have finished, the test session should look as follows and it is time to create our first Person entity. Click \u0026lsquo;Send\u0026rsquo; to post the new entity to the application.\n\nCongratulations! You have created your first Person entity!\nThe router matched the request URL to a route (service end-point), the middleware layer in the matched route examined the JWT, verified it was okay to proceed and then passed the raw JSON from the request body to the Person entity\u0026rsquo;s controller. The controller unmarshalled the JSON into a Person struct and then passed the result to the Create method in the model/validation layer. Validation of the Person struct\u0026rsquo;s content occured, and then a call was made to the underlying ORM to create the entity on the database.\nThe ORM-layer returned the new entity to the application\u0026rsquo;s model-layer, where it was checked and passed back to the controller layer, whereupon it was serialized (struct content becomes JSON) and written to the the response-writer.\nThis is a high-level view of what transpired, but the general flow of things is accurate.\nNotice that the entity passed back to us seems to have a couple of extra fields? All entities created via a jiffy model file are injected with a primary-key of \u0026lsquo;id\u0026rsquo; as well as a non-persistent \u0026lsquo;href\u0026rsquo; field. In this example, our entity\u0026rsquo;s \u0026lsquo;id\u0026rsquo; field was specified to be auto-incrementing with a starting value of 10000000. See the sqac-tag section in the documentation for details regarding key options.\nHref is included in each entity\u0026rsquo;s GET responses, and acts as a self-reference providing the entity\u0026rsquo;s direct access URI to the consumer.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/level-two/l2-content-c/",
	"title": "Create Another Person",
	"tags": [],
	"description": "",
	"content": "Let\u0026rsquo;s change a few things in our request-body and create another Person entity. Edit the JSON body in the request section of your Postman session and click \u0026lsquo;Send\u0026rsquo; when you are ready.\n\nAnother Person entity has been created.\n\nCreate one more Person entity so we have three (or more) in total.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/level-two/l2-content-d/",
	"title": "Get Some Persons",
	"tags": [],
	"description": "",
	"content": "So far we have created two Person entities. We have observed that upon successful creation of an entity, a JSON representation of that entity is passed back to us via the response-writer. Let\u0026rsquo;s now look at how we can get a list of all of our Person entities.\nCreate a new tab in Postman and specify a target URL of http://127.0.0.1:8080/persons making sure to select the http GET method. Next, add the following key-value pair to the http header:\n Authorization : Bearer *paste-your-JWT-here*  When you have finished, the test session should look as follows and it is time to read some Person entities from the database. Click \u0026lsquo;Send\u0026rsquo; to issue our read request to the application.\n\nWe just read the complete list of Person entities. Adding an \u0026rsquo;s\u0026rsquo; to the entity name and issuing the request with a GET http verb tells a jiffy application to read all of the Person entities. In some cases this looks odd, but it makes it quite easy to consume the services. Notice that the \u0026lsquo;href\u0026rsquo; field of each Person entity provides a direct link to the entity that it is a part of.\n\n"
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/level-two/l2-content-e/",
	"title": "Get a Person",
	"tags": [],
	"description": "",
	"content": "What if we need to read a single Person, or isolate a Person entity from a list of entities? Let\u0026rsquo;s try reading a Person entity using its \u0026lsquo;id\u0026rsquo; key.\nCreate a new tab in Postman and specify a target URL of http://127.0.0.1:8080/person/10000001 making sure to select the http GET method. Next, add the following key-value pair to the http header:\n Authorization : Bearer *paste-your-JWT-here*  When you have finished, the test session should look as follows and it is time to read Person 10000001 from the database. Click \u0026lsquo;Send\u0026rsquo; to issue our read request to the application.\n\nWe just read the Person entity with \u0026lsquo;id\u0026rsquo; key 10000001. While this is not a very human-friendly way to search for a Person, it is a simple way to isolate and reference an entity for reading, updating or deletion.\n\n"
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/level-two/l2-content-f/",
	"title": "Update a Person",
	"tags": [],
	"description": "",
	"content": "If you have been following along, we have created Person entities, read Person entities both in bulk and by \u0026lsquo;id\u0026rsquo; key. We are now going to take a look at updating an existing entity.\nRead Person entity 10000001 from the database as shown in the Get a Person example.\nOnce you have successfully read Person entity 10000001 into your Postman session, copy the content of the response body to your clipboard. We are going to reuse our GET Person Postman tab to perform an update, so change the http verb from GET to PUT. Changing the http verb to PUT will allow us to maintain the request-body in our Postman tab. Next, add the following key-value pair to the http header:\n Content-Type : application\\json  Now paste the GET Person response-body into the request-body of our new PUT request, then edit it so that Opus\u0026rsquo;s full name is given, as well as his correct weight. Strictly speaking, you do not need to include the \u0026lsquo;id\u0026rsquo; or \u0026lsquo;href\u0026rsquo; fields in an update, but it does not hurt anything to do so.\n{ \u0026quot;id\u0026quot;: 10000001, \u0026quot;href\u0026quot;: \u0026quot;http://127.0.0.1:8080/person/10000001\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Opus the Penguin\u0026quot;, \u0026quot;age\u0026quot;: 8, \u0026quot;weight\u0026quot;: 385, \u0026quot;valid_license\u0026quot;: false }  \nWhen you have finished, you should have something that looks as follows. Click \u0026lsquo;Send\u0026rsquo; to issue the PUT request to the application.\n\nThe PUT request should update the entity using the \u0026lsquo;id\u0026rsquo; key as its update criteria, and then return a JSON representation of the updated entity. This is a little different than other approaches, where the result of an update is measured simply by the http response code. If you don\u0026rsquo;t like the way this works, it is very easy to update the generated source code to omit the response body following a PUT.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/level-two/l2-content-g/",
	"title": "Get Persons With Restrictions",
	"tags": [],
	"description": "",
	"content": "We have seen how to Create, Get, and Update a Person entity, but before we get around to the Delete operation, let\u0026rsquo;s take a quick look at some other simple things we can do with Get entity lists.\n  Get a count of Person entities in the database   http://127.0.0.1:8080/persons/$count .\n    Get all Person entities in the database ordered-by age   http://127.0.0.1:8080/persons$orderby=age .\n \n  Get all Person entities in the database ordered-by age descending   http://127.0.0.1:8080/persons$orderby=age$desc .\n \n  Get all Person entities in the database ordered-by age descending with a selection offset of 1   http://127.0.0.1:8080/persons/$orderby=age$desc$offset=1 .\n \n  Get all Person entities in the database ordered-by age descending with a limit of 2   http://127.0.0.1:8080/persons/$orderby=age$desc$limit=2 .\n \n  Get all Person entities in the database with name like %qui%   http://127.0.0.1:8080/persons/name(LIKE 'qui') .\n \n  Get all Person entities in the database with age equal to 46   http://127.0.0.1:8080/persons/$age(EQ 46) .\n \n"
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/level-two/l2-content-h/",
	"title": "Delete a Person",
	"tags": [],
	"description": "",
	"content": "Time to delete one of our Person entities. Create a new tab in Postman and specify a target URL of http://127.0.0.1:8080/person/10000000 with the http DELETE method. Next, add the following key-value pairs to the http header:\n Content-Type : application\\json Authorization : Bearer *paste-your-JWT-here*  When you have something that looks as follows, click the \u0026lsquo;Send\u0026rsquo; button to issue the delete request to the application.\nIf the delete request was successful, you will see a http response-code of 202 (Accepted). Try to read the entity by converting your delete request into a get request and verify that Person entity 10000000 has truly been deleted.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/level-two/l2-content-i/",
	"title": "Next Steps",
	"tags": [],
	"description": "",
	"content": "That is a quick overview of the sort of things you can do with an application generated by Jiffy. There is a lot more to see however!\nGood places to start would be in the Jiffy Overview and the Model File section.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/",
	"title": "",
	"tags": [],
	"description": "",
	"content": " Jiffy RESTful Services Generator Jiffy is a model-based RESTful application services generator written in go. It was developed as an experiment to offer an alternative avenue when developing native applications for SAP Hana. The jiffy application allows a developer to treat the data persistence layer as an abstraction, thereby removing the need to make use of CDS and the SAP XS libraries.\nWhile this is not for everybody, it does reduce the mental cost of entry and allows deployment of a web-based application on SAP Hana with virtually no prior Hana knowledge.\nMain Features  generated applications can be connected to Postgres, MSSQL, SAP Hana, SQLite or MariaDB with no source-code changes no database specific code is compiled into the binary bcrypt salt/pepper based authentication scheme session management and end-point authorizations via jwt built-in support for the creation of jwt signing-keys service end-points are secured by way of jwt claims in the route handler middleware service end-point security is generated by default JSON model file(s) for Entity, Index, Relationship and Foreign-Key definitions generates a set of CRUD-type RESTful services for each entity in the model file(s) built-in support for https getSet type end-points support /$count, $limit=n, $offset=n, $orderby=field_name ($asc|$desc) generates end-points for hasOne, hasMany and belongsTo entity relationships generates static query end-points each entity\u0026rsquo;s corresponding service can be enabled and disabled on a per app-server basis generated models support persistent and non-persistent fields generated apps create and alter backend database artifacts based on model definitions baked in normalization and validation in the model-layer generates a comprehensive set of working tests via go test generated code is easily extended either via direct editing, or through an extension-point concept is designed to be deployed across multiple VM\u0026rsquo;s or containers by way of a leader-election and failure detection subsystem utilizes an internal (replicated) cache for user, user-group and authorization artifacts entity caching can be easily extensible via enhancement-points in the controller or model layers (redis / memcached for example)  "
},
{
	"uri": "https://1414c.github.io/jiffy/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://1414c.github.io/jiffy/credits/",
	"title": "Credits",
	"tags": [],
	"description": "",
	"content": " Contributors Thanks to them  for making Open Source Software a better place !\nPackages and libraries  sqlx jwt-go go-sql-driver/mysql lib/pq go-sqlite3 go-mssqldb go-hdb  Tooling  Hugo Hugo Learn Theme  "
},
{
	"uri": "https://1414c.github.io/jiffy/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]