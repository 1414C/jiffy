[
{
	"uri": "https://1414c.github.io/jiffy/getting-started/gs-content-a/",
	"title": "Go Environment",
	"tags": [],
	"description": "",
	"content": "If you already have Go installed and know that your installation is working, you should skip to the next section. If you need to get Go installed on your machine, keep reading.\nGo is easy to setup and can be installed from source or binary package, both which are available at golang.org. Jiffy is presently built and tested using golang version 1.10, but it is best to use the latest stable 1.x release.\n Go binary installation instructions Go build-from-source installation instructions  "
},
{
	"uri": "https://1414c.github.io/jiffy/overview/",
	"title": "Jiffy Overview",
	"tags": [],
	"description": "",
	"content": " Overview and Features Jiffy "
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/",
	"title": "Getting Started",
	"tags": [],
	"description": "",
	"content": " Getting Started Initial Setup Before we get start generating services, there are few things to get out of the way. First we need to make sure that the Go environment is setup, then we need to get jiffy installed.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/installation/",
	"title": "Jiffy Installation",
	"tags": [],
	"description": "",
	"content": " Installation and Dependencies Jiffy "
},
{
	"uri": "https://1414c.github.io/jiffy/execution/",
	"title": "Jiffy Execution",
	"tags": [],
	"description": "",
	"content": " Execution Options Jiffy "
},
{
	"uri": "https://1414c.github.io/jiffy/models/",
	"title": "Model Maintenance",
	"tags": [],
	"description": "",
	"content": " Model Maintenance Jiffy "
},
{
	"uri": "https://1414c.github.io/jiffy/generation/",
	"title": "Generation Reference",
	"tags": [],
	"description": "",
	"content": " Application Generation Jiffy "
},
{
	"uri": "https://1414c.github.io/jiffy/extensionpoints/",
	"title": "Extension Points",
	"tags": [],
	"description": "",
	"content": " Extension Points Jiffy "
},
{
	"uri": "https://1414c.github.io/jiffy/accesscontrol/",
	"title": "Access Control",
	"tags": [],
	"description": "",
	"content": " Access Control Jiffy "
},
{
	"uri": "https://1414c.github.io/jiffy/interprocess/",
	"title": "Interprocess Communication",
	"tags": [],
	"description": "",
	"content": " Interprocess Communication Jiffy "
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/gs-content-b/",
	"title": "Installing Jiffy",
	"tags": [],
	"description": "",
	"content": "The easiest way to install Jiffy is to use go get on the command-line to pull the latest version from github, as shown below:\n$ go get -u github.com/1414C/jiffy  The \u0026lsquo;go get\u0026rsquo; command will pull the Jiffy github repository into your $GOPATH/src/github.com folder, as well as any dependencies referenced by the Jiffy source code. The -u flag is included to instruct go get to check for and pull updates to Jiffy packages and their dependencies. This is the least sophisticated way of managing dependencies in go. At the time of this writing \u0026lsquo;vgo\u0026rsquo; is not yet part of the official golang toolchain.\nOnce the Jiffy source code and dependencies have been installed into the $GOPATH, go build can be used to compile a binary from the Jiffy sources. The easiest way to do this is to open a terminal window, switch to $GOPATH/src/github.com/1414C/jiffy and run go build as shown below.\n$ go build -v  This will result in the creation of a binary file called \u0026lsquo;jiffy\u0026rsquo;. You may move the \u0026lsquo;jiffy\u0026rsquo; binary anywhere in your $PATH, but convention would have it installed in /usr/local/bin. Once the \u0026lsquo;jiffy\u0026rsquo; binary has been moved to its new home, open a new terminal window and use the which command to ensure that the binary is in the $PATH.\n$ which jiffy -a  If which cannot find the jiffy binary (or finds the wrong one!), make sure that the $PATH environment variable is set correctly. Alternatively, Jiffy can be run directly from the source via \u0026lsquo;go run main.go \u0026hellip; \u0026hellip;\u0026rsquo;.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/extensionpoints/ep-content-a/",
	"title": "Extension Point Overview",
	"tags": [],
	"description": "",
	"content": " Extension-Points (ext folders) The Jiffy application generates a working services application based on the provided model files. While the generated application should be runnable immediately following generation, there is often a need to perform validation and normalization of the incoming data. This is best coded in the model-layer within the generated validation methods, but sometimes this is not sufficient.\nThere may be a need to inspect the request details immediately once the request has been passed to the controller. There may be a need to perform crucial validations of the request-body in the controller layer prior to calling the model-layer (i.e. in advance of the validator). There may be a need to influence the value of an entity\u0026rsquo;s fields prior to returning the read or created entity back to the caller. For reasons such as these, so-called \u0026lsquo;extension-points\u0026rsquo; have been embedded in the model and controller layers of the code.\nEach extension-point offers the developer the ability to code their own method in a regeneration protected code-body in order to perform checks or data manipulations. Consider that regeneration of an application will overwrite the current controller and model files if the same target destination is used. If an application developer were to extend the controller or model directly in the generated code, their additions would be lost if the application were to be regenerated. By introducing the extension-point concept and separating the related code from the generated code the application developers enhancements are protected from being over-written by an inadvertent application regeneration.\nFirstApp ├── appobj │ ├── appconf.go │ └── appobj.go ├── controllers │ ├── authc.go │ ├── controllerfuncs.go │ ├── groupauthc.go │ ├── person_relationsc.go │ ├── personc.go │ ├── usrc.go │ ├── usr_groupc.go │ └── ext │ ├── extc_interfaces.go │ └── personc_ext.go . . . ├── models │ ├── authm.go │ ├── errors.go │ ├── group_authm.go │ ├── modelfuncs.go │ ├── personm_ext.go │ ├── personm.go │ ├── servicesm.go │ ├── usr_groupm.go │ ├── usrm.go │ └── ext │ └── model_ext_interfaces.go ├── util │ └── strings.go ├── .dev.config.json ├── .prd.config.json ├── main_test.go └── main.go  Extension-points are declared in the generated codebase as a specific set of controller and model interfaces. The interface declarations are contained in the ext sub-folders of the model and controller folders. The ext sub-folders also contain sample (empty) implementations of the interfaces are provided for each modeled entity.\nThe extension-point interfaces rely on the use of the empty interface{} in order to facilitate the passing of a pointer to the data structure being inspected/updated. Use of interface{} allows us to embrace the concept of a general extension-point API at the cost of strict typing. Additionally, the implementer must make use of reflection in order to assign a type to the value of the interface{} underlying data structure. As of this writing, the use of interface{} and reflection is the best way to implement a general extension-point API with golang.\nExtension-points are generated on a per-entity-basis controlled by the inclusion of the \u0026lsquo;ext_points\u0026rsquo; block in the entity\u0026rsquo;s model declaration. See the Annotated Simple Single Entity Model for an overview of the extension-point model elements.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/generation/gn-content-a/",
	"title": "Generation Overview",
	"tags": [],
	"description": "",
	"content": " Jiffy Application File Structure Running the Jiffy generator creates a set of files that comprise a basic working backend services application. Jiffy generates the following source code tree when provided with a model-file describing a simple \u0026lsquo;Person\u0026rsquo; entity.\nFirstApp ├── appobj │ ├── appconf.go │ └── appobj.go ├── controllers │ ├── authc.go │ ├── controllerfuncs.go │ ├── groupauthc.go │ ├── person_relationsc.go │ ├── personc.go │ ├── usrc.go │ ├── usr_groupc.go │ └── ext │ ├── extc_interfaces.go │ └── personc_ext.go ├── group │ ├── gmcl │ │ ├── gmclient.go │ ├── gmcom │ │ ├── gmcache.go │ │ ├── gmclsrv.go │ │ ├── gmerrors.go │ │ └── gmomap.go │ └── gmsrv │ ├── gmprocessors.go │ ├── gmprotocol_senders.go │ ├── gmserver.go │ └── gmtxrx.go ├── jwtkeys │ ├── ecdsa256 │ │ ├── ecdsa.priv.pem │ │ └── ecdsa.pub.pem │ ├── ecdsa384 │ │ ├── ecdsa384.prive.pem │ │ └── ecdsa384.pub.pem │ ├── ecdsa521 │ │ ├── ecdsa521.priv.pem │ │ └── ecdsa521.pub.pem │ ├── rsa256 │ │ ├── rsa.priv.pem │ │ └── rsa.pub.pem │ ├── rsa384 │ │ ├── rsa384.prive.pem │ │ └── rsa384.pub.pem │ └── rsa512 │ ├── rsa512.priv.pem │ └── rsa512.pub.pem ├── middleware │ └── requireuser.go ├── models │ ├── authm.go │ ├── errors.go │ ├── group_authm.go │ ├── modelfuncs.go │ ├── personm_ext.go │ ├── personm.go │ ├── servicesm.go │ ├── usr_groupm.go │ ├── usrm.go │ └── ext │ └── model_ext_interfaces.go ├── util │ └── strings.go ├── .dev.config.json ├── .prd.config.json ├── main_test.go └── main.go  Basic Application Flow Incoming requests are handled by a mux, which validates / authenticates the request, and then matches it to a route. The selected route passes the request to a controller specific to the entity-type, where the incoming information is mapped into a go struct matching the entity declaration. The controller then calls the appropriate model method for the http operation and entity-type combination, passing it the entity structure. The model handler passes the entity struct through a member-field validation layer, and then to the model\u0026rsquo;s interface to the underlying sqac ORM. The database request is handled by the ORM, and then the response is passed from the model back to the controller where it is marshaled into a JSON payload and sent back to the caller in the response-writer\u0026rsquo;s body.\nJiffy applications contain an embedded leader-based group-membership sub-system that is used for interprocess communication when the generated jiffy application is deployed as multiple processes.\n When a jiffy-application is deployed as more than one process, there is a need for changes to users, auths, groups and group/auth associations to be communicated to all running instances. These common application entities are cached locally on each running instance in order to avoid accessing the database unnecessarily. An internal subsystem was chosen in order to avoid dependencies on external solutions like redis/memcached/etcd etc. (see footnote). Changes to these objects are performed via standard jiffy-admin services that are present in every jiffy-application. When one of the standard admin objects is updated via an admin service, the object\u0026rsquo;s data is updated in the database. Following a successful database update, the jiffy-application must disseminate the updated object data to the local cache of the application server that processed the change, as well as every other application server in the group. Given that there is interprocess communication for the cache updates, the status of the group members must be tracked. The subsystem uses a SWIM (Scalable Weakly-Consistent Infection-Style Process-Membership) protocol to check and disseminate the statues of the group\u0026rsquo;s processes. A ping is sent from each process to every other known process in the group in random order once per ping-cycle. The ping message contains a piggybacked process-map containing the pinging process\u0026rsquo;s view of the world in terms of process status. Processes may have one of the following three statuses (ALIVE, SUSPECT, FAILED), as well as a status count indicating how many times the pinging process has noted that a process is in a particular state.  See the Group Membership section of this document for a detailed overview of the group-membership subsystem.\nThere are more elegant ways to express certain aspects of the generated application. The coding style has been deliberately kept as simple and straight-forward as possible in order to facilitate easier understanding and adjustment of the generated code.\n** Using something like etcd to replace the group-membership and app-server-level caching may make sense in Kubernetes-style deployments. In the future, jiffy may move to the etcd model for all deployments.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/tutorials/tt-content-a/",
	"title": "Hand Coding a Custom Join",
	"tags": [],
	"description": "",
	"content": " Manual Join Creation "
},
{
	"uri": "https://1414c.github.io/jiffy/models/mo-content-a/",
	"title": "Model Overview",
	"tags": [],
	"description": "",
	"content": " Model Files Model files contain the Entity, Index and Relation definitions that you wish to generate services for. Entity model definition consists of an array of JSON objects, with each object being limited to a flat hierarchy and basic go-data-types, (although this is easily extended). By default, the Jiffy generator expects a models.json file in the execution directory, but a correctly formatted JSON file can be loaded from any location by executing jiffy with the -m flag.\nIt is possible to use more than one model-file, as long as there is no duplication of entity definitions across the files. Model files may be loaded in any order, but the complete set of files must be loaded at the same time. As an example, it would be fine to create three model files; Library.json, Book.json, LibraryCard.json, but all three files should be complete and processed at the same time via the -mf flag in order to allow the correct generation of relationships etc.\nSample models.json files are installed with the application and can be found in the support/testing_models folder of the Jiffy source tree. The sample models are used as the basis for the following sections.\nMaking Changes to a Model Each time the Jiffy-generated application is started, a check is performed to see if it\u0026rsquo;s models match any database artifacts. For example, if the generated application contains a model called \u0026lsquo;Widget\u0026rsquo;, a check is performed to see if table \u0026lsquo;widget\u0026rsquo; exists in the database. If a table matching the model name is detected in the database, the application will attempt to process the model definition as an ALTER TABLE-type operation rather than CREATE TABLE. The application will add new model elements to the existing database table schema, but will not delete database artifacts if model elements are removed. During the development-cycle it is recommended to drop and recreate the database artifacts when making changes to the model. This can be done using the -dr flag option when executing your generated application. See the application startup sequence section of this document for details regarding database artifact creation and updates.\nSimple Single Entity Model The following JSON illustrates the definition of a simple single-entity model file. In this case, a model entity called \u0026lsquo;Person\u0026rsquo; will be created in the generated application, along with corresponding database table \u0026lsquo;person\u0026rsquo;. Table \u0026lsquo;person\u0026rsquo; will be created (if it does not already exist) when the application is started for the first time.\n{ \u0026quot;entities\u0026quot;: [ { \u0026quot;typeName\u0026quot;: \u0026quot;Person\u0026quot;, \u0026quot;id_properties\u0026quot;: { \u0026quot;start\u0026quot;: 10000000 }, \u0026quot;properties\u0026quot;: { \u0026quot;name\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: false, \u0026quot;unique\u0026quot;: false, \u0026quot;index\u0026quot;: \u0026quot;nonUnique\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,like\u0026quot; }, \u0026quot;age\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;uint\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: false, \u0026quot;unique\u0026quot;: false, \u0026quot;index\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,lt,gt\u0026quot; }, \u0026quot;weight\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;float64\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: false, \u0026quot;unique\u0026quot;: false, \u0026quot;index\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,lt,le,gt,ge\u0026quot; }, \u0026quot;validLicense\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;bool\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: false, \u0026quot;unique\u0026quot;: false, \u0026quot;index\u0026quot;: \u0026quot;nonUnique\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,ne\u0026quot; } }, \u0026quot;ext_points\u0026quot;: { \u0026quot;gen_controller\u0026quot;: true, \u0026quot;gen_model\u0026quot;: true } } ] }  The sample model file can be downloaded from the following location: simpleSingleEntityModel.json. \nAnnotated Simple Single Entity Model { \u0026quot;entities\u0026quot;: [ The 'entities' block contains an array of entities belonging to the application model. Each entity relates directly to a database table (or view). Entities contain information that the application generator uses to create and update database artifacts such as tables, indexes, sequences and foreign-keys, as well as information informing the application runtime of the member field properties. This is a mandatory model element. { \u0026quot;typeName\u0026quot;: \u0026quot;Person\u0026quot; Field 'typeName' refers to the name of an entity. It should be capitalized and written in CamelCase. An Entity given a typeName of \u0026quot;Person\u0026quot; will result in an internal model object of type Person and a database table called 'person'. This is a mandatory model element. \u0026quot;id_properties\u0026quot;: { The 'id_properties' block contains a single entry for now, and is used to provide guidance to the application generator regarding the setup of the entity's ID field. This is an optional model element. \u0026quot;start\u0026quot;: 10000000, Field 'start' can be used to provide a starting point for an entity's ID field. This is a mandatory model element if the 'id_properties' block has been included in the model. }, \u0026quot;properties\u0026quot;: { The 'properties' block contains 1:n entity member field definitions. Member fields should be defined in camelCase and can start with a lower or upper-case character. In the context of the \u0026quot;entity\u0026quot; with a 'typeName' of 'Person', 'properties' refer to the data fields of the generated \u0026quot;Person\u0026quot; model structure. 'properties' are a collection of free-form name-tags, each with a child-block containing the 'property' attributes. This is a mandatory model element. The \u0026quot;name\u0026quot; property block is described below: \u0026quot;name\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, Field 'type' in a 'properties'-\u0026gt;'name' JSON-block refers to the go data-type associated with the current 'property'. 'type' is a mandatory field in an \u0026quot;entity\u0026quot; 'property' block. \u0026quot;dbtype\u0026quot;: \u0026quot;varchar(100)\u0026quot;, Field 'dbtype' can be used to specify a native db-field-type for the property. This feature can be useful if for example, the developer is confident that a string will never exceed 100 characters in length. Care should be taken to ensure that the specified DB-Type is consistent with the go-type that will be generated in the application's model.\u0026lt;Entity\u0026gt; defintion. Consider also that making use of this field to some extent limits the backend portability of the generated code. For example, not all database systems have a TINYINT data-type, so specifying a 'db_type' of TINYINT could be problematic if multiple database systems are being used for testing. This is an optional field. \u0026quot;no_db\u0026quot;: Field 'no_db' can be used to instruct the generator to create the field as a member in the enitity struture, but to prevent the field from being persisted in the backend database. Non-persisted fields are not created in the database table schemas, and values passed into the application are wiped from their respective internal structures following use. 'no_db' fields can also be used to pass calculated values back to the caller. \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, Field 'format' is not currently used, but is intended to deal with field conversion from strings / floats to timestamp formats etc. This is an optional field. \u0026quot;required\u0026quot;: false, Field 'required' is used to instruct the generator to set a 'NOT NULL' database constraint on the column related to the property. Allowed values include {true, false}. This is a mandatory field. \u0026quot;unique\u0026quot;: false, Field 'unique' is used to instruct the database not to accept duplicate values in the database column related to the property. Setting this field to true will cause a 'UNIQUE' constraint to be applied to the related database column. Allowed values include {true, false}. This is a mandatory field. \u0026quot;index\u0026quot;: \u0026quot;nonUnique\u0026quot;, Field 'index' is used to instruct the database to create an index on the db table-column related to the property. See the 'indexes' element in the type definition for the creation of compound indices. Allowed values include {\u0026quot;unique\u0026quot;, \u0026quot;nonUnique\u0026quot;, \u0026quot;\u0026quot;}. This is an optional field. \u0026quot;selectable\u0026quot;: \u0026quot;eq,like\u0026quot; Field 'selectable' can be used to instruct the code-generator to create simple REST query accessor routes for the current 'property'. The generator creates routes to permit GET operations that can be called based on the entity 'typeName' and 'property' values. Allowed values include {\u0026quot;EQ\u0026quot;, \u0026quot;eq\u0026quot;, \u0026quot;LT\u0026quot;, \u0026quot;lt\u0026quot;, \u0026quot;GT\u0026quot;, \u0026quot;gt\u0026quot;, \u0026quot;GE\u0026quot;, \u0026quot;ge\u0026quot;, \u0026quot;LIKE\u0026quot;, \u0026quot;like\u0026quot;, \u0026quot;NE\u0026quot;, \u0026quot;ne\u0026quot;, \u0026quot;\u0026quot;} Additional restrictions are imposed based on the 'type' field value. For example, a bool type need not support LT or GT operators. Sample routes for Person-\u0026gt;Name selection with \u0026quot;eq,like\u0026quot; are shown: https://localhost:\u0026lt;port\u0026gt;/persons/name(EQ '\u0026lt;sel_string\u0026gt;') https://localhost:\u0026lt;port\u0026gt;/persons/name(LIKE '\u0026lt;sel_string\u0026gt;') Note that this is not the same as filtering insofar as setting the selectable options results in the creation of parameterized static routes in the application mux. }, \u0026quot;age\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;uint\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: false, \u0026quot;unique\u0026quot;: false, \u0026quot;index\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,lt,le,gt,ge,ne\u0026quot; }, ... ... }, \u0026quot;ext_points\u0026quot;: { The 'ext_points' block contains two elements which Jiffy uses to determine whether or not to create extension-points in the entity. This is an optional block. \u0026quot;gen_controller\u0026quot;: true, Element 'gen_controller' is used by Jiffy to determine whether or not to insert extension-points into the entity's controller. Setting the value of this element to 'true' will cause Jiffy to insert extension-points into the entity's controller and generate an empty implementation of the extension-point interface for the entity in the ./controllers/ext folder. A generated controller extension-point implementation for entity 'Person' would take the form of: 'personc_ext.go'. This is an optional element. \u0026quot;gen_model\u0026quot;: true Element 'gen_model' is used by Jiffy to determine whether or not to insert extension-points into the entity's model file. Setting the value of this element to 'true' will cause Jiffy to insert extension-points into the entity's model file and generate an empty implementation of the extension-point interface for the entity in the ./models folder. A generated model extension-point implementation for entity 'Person' would take the form of: 'personm_ext.go'. This is an optional element. } }, { ... next entity definition } ] }  Entity ID The ID field is visibly absent from the preceding entity declarations. The original intent was to support any name for the primary key / resource identifier of an entity. While it is possible to do this, ID uint values are the universal \u0026lsquo;standard non-standard\u0026rsquo; way of representing object identifiers in systems. As a result, ID is injected into the model definition of every entity as a uint64 field and is marked as the primary-key in the database table. By default, the ID is created as an auto-incrementing column in the DBMS, but this functionality can be suppressed (future - the ORM supports this, but Jiffy has yet to be updated). The ability to allow a specific starting point for the ID key range is supported via the entity header-level \u0026ldquo;start\u0026rdquo; value.\nIf the ID field really needs to be known as CustomerNumber for example, the generated code can be edited in a few locations to support the change. It is worth mentioning that the number of edits required to rename \u0026lsquo;ID\u0026rsquo; increases in direct relation to the number and complexity of entity relations (both to and from).\nAs an alternative to renaming ID, it is also conceivable that it can be ignored. Ignoring the ID means that the generated CRUD controller/model/routes are not as useful as they could be, but they offer a great starting point for your own coding. Entities can be defined with column constraints that mimic those of DBMS primary / complex keys, then the generated CRUD artifacts based on ID can be ignored, copied then ignored, or modified to accommodate the modeled entities.\nIt is also possible to go completely custom and write your own models and controllers from scratch using a generated model as a reference template. In addition to exposing a generic internal CRUD interface to the backend, the more interesting go/sql calls are exposed internally along with some lightly wrapped and super useful calls from jmoirons widely used sqlx package. Although Jiffy eschews non-standard lib packages wherever possible, sqlx is really great.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/execution/ex-content-a/",
	"title": "Running Jiffy",
	"tags": [],
	"description": "",
	"content": " Execution In order to run the Jiffy application generator, ensure the following:\n Make sure go has been installed in the test environment. See http://www.golang.org for installation files and instructions.\n Make sure that the Jiffy source code and dependencies have been installed.\n One of the supported databases is available, either locally or over the network.\n Jiffy can be started in two ways:\n From $GOPATH/src/github.com/1414C/jiffy you may execute the application directly from the Jiffy source code as follows.   $ go run main.go   A binary can also be built from $GOPATH/src/github.com/1414C/jiffy by typing the following.  $ cd $GOPATH/src/github.com/1414C/jiffy $ go build . $ ./jiffy  See the Jiffy Installation section for detailed installation instructions.\n  "
},
{
	"uri": "https://1414c.github.io/jiffy/installation/in-content-a/",
	"title": "Jiffy Dependencies",
	"tags": [],
	"description": "",
	"content": " What does Jiffy need to run? Wherever possible and reasonable, Jiffy relies on packages found in the Go standard library. As of this writing, Go version 1.10 is required in order to build the Jiffy binary. Jiffy requires a running database from the following list of supported databases:\nSupported Databases  PostgreSQL tested with version 10+ SAP HanaDB tested with HDB 2.0 MSSQL tested with MSSQL 2017 MySQL SQLite3 Firebird (future) DB2 (future)  Database Drivers The following golang database drivers are required, even if you are only planning to make use of one of the DBMS\u0026rsquo;s in the supported list. This is due to the fact that Jiffy attempts to connect to your test database during the code generation process and there is no guarantee what that database may be. It is possible that a developer tests with SQLite locally when generating the code and performing initial tests, but intends to ultimately connect to Postgres.\n   Driver Name Driver Location     SAP Hana Database Driver github.com/SAP/go-hdb/driver   MSSQL Database Driver github.com/denisenkom/go-mssqldb   MySQL Database Driver github.com/go-sql-driver/mysql   PostgreSQL Database Driver github.com/lib/pq   SQLite3 Database Driver github.com/mattn/go-sqlite3    The database drivers can be pulled down from their respective repositories via the go get command. The latest version of each should be fine.\ngo get -u github.com/lib/pq  Sqac ORM Jiffy also requires the sqac ORM. This should be pulled down automatically during the Jiffy installation process, but can also be manually installed using go get as shown below.\ngo get -u github.com/1414C/sqac  See the sqac ORM README.md file for verification and testing instructions.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/overview/ov-content-a/",
	"title": "What is Jiffy?",
	"tags": [],
	"description": "",
	"content": " What does Jiffy do? Jiffy is a model-based RESTful application services generator written in go. Think of Jiffy as an accelerator: Jiffy generates a complete backend services application, and that generated application is what will be run in production.\nJiffy allows a developer to generate a robust go-based application that treats the data persistence layer in a generic manner. This allows the generated application to connect to number of different database systems (outlined below), without any code changes. Generated applications can be targeted at SAP Hana; Postgres, MySQL, MSSQL or SQLite simply by updating one configuration file.\nWhy write in Go?  Go has a good standard library, thereby keeping dependencies on public packages to a minimum Go offers concurrency via lightweight threads known as go-routines  no blocking in the i/o layer during compute intensive tasks no lost callbacks or broken promises go-routines will use all available cores to handle incoming requests  Go offers type-safety Go is a small language Go projects compile to a static single binary which simplifies deployments Go cross-compiles to virtually any platform and architecture; write and test on a Chromebook - deploy to amd64/ppc64/arm64/s390  What does a Jiffy application provide? Jiffy consumes simple JSON model-files and uses them to generate a working, secure and extensible application server codebase. Generated applications need no additional coding to run, although in most situations custom checks should be added via extension-points present in the generated codebase.\nJiffy applications provide the following features:\n generated applications can be connected to Postgres, MSSQL, SAP Hana, SQLite or MariaDB no database specific code is compiled into the binary; an app can be pointed from SQLite to SAP Hana with no code changes login / authorization management via JWT built-in support for the creation of signing-keys for JWT (RS256, RS384, RS512, ES256, ES384, ES521) supports JWT\u0026rsquo;s created by other IDP\u0026rsquo;s (RS256, RS384, RS512, ES256, ES384, ES521) bcrypt salt/pepper based authentication scheme where passwords are never stored in the db JSON configuration (model) file(s) for Entity, Index, Foreign-Key and Relationship definitions models support persistent and non-persistent fields generated apps create and alter database artifacts based on the model file (tables, indices, sequences etc.) supports single and composite index declarations via the model file built-in support for https built-in normalization and validation in the model-layer each entity\u0026rsquo;s corresponding service can be enabled and disabled on a per-app-server (process) basis based on config generates a working set of CRUD-type RESTful services for each entity in the model file get-set type end-points support /$count, $limit=n, $offset=n, $orderby=field_name ($asc|$desc) supports and generates working end-points for hasOne, hasMany and belongsTo entity relationships generates static query end-points end-points are secured by way of scope inspection (JWT claims) in the route handler middleware end-point security is generated by default via a auths -\u0026gt; auth-groups -\u0026gt; user arrangement generates a comprehensive set of working tests (go test) generated code is easily extended either via direct editing, or through an extension-point concept in the model and controller-layers a leader-election-based group-membership service exists between running instances of the application to facilitate internal caching of user information  How does Jiffy interface to the underlying database? Jiffy sits on top of a thin ORM that was written to talk to the SAP Hana in-memory db and then extended to the other supported DBMS systems. The ORM code is very simple and can easily be extended to accommodate databases that have not been mentioned here. Bear in mind that the generated queries are designed to accommodate the lowest-common-denominator-type CRUD access. It is expected that a serious deployment will involve extending the generated codebase to optimize access in certain scenarios.\nORM\u0026rsquo;s sound like a bad idea to a lot of people. In practice however, as soon as you want to support more than one type of backend DBMS, a level of abstraction (like a thin ORM) starts to look a bit more appealing. However\u0026hellip;\nIf you look at the generated code and don\u0026rsquo;t like what you see, the ORM handle exposes the standard go/sql and the awesome jmoiron/sqlx libraries to you directly. This will effectively allow you to make use of the generated application while coding the SQL by hand.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/accesscontrol/ac-content-a/",
	"title": "Access Control Overview",
	"tags": [],
	"description": "",
	"content": " Overview Access to application resources (entities) is controlled in four ways:\n Configuration based service activation Secure user authentication Authorization checks via JWT token claim inspection embedded as middleware in the protected route declarations (end-points) Usr/Auth/Group/GroupAuth caches are maintained on each group-member and updated via an internal API and dissemination protocol in the group-membership service  Configuration Based Service Activation An internal service is created for each of the the application\u0026rsquo;s entities. Services can be marked as active or inactive in the service configuration, thereby allowing a single application to be generated, while at the same time allowing selective service deployment. For example, there may be cases where it is desirable to route certain services to a particular application instance and another set of services to the rest of the pool. In such a case, a reverse-proxy could be configured to route the end-points appropriately, and the deployed service configurations would be adjusted accordingly. Service activations are controlled via entries in the \u0026lsquo;service_activations\u0026rsquo; block of each application instance\u0026rsquo;s configuration file.\nThe following configuration file excerpt shows that the selected instance of the application is servicing \u0026lsquo;Person\u0026rsquo; entity requests, but is not presently servicing \u0026lsquo;Car\u0026rsquo; entity requests. However, if a relationship exists between \u0026lsquo;Person\u0026rsquo; and \u0026lsquo;Car\u0026rsquo;, requests rooted on the \u0026lsquo;Person\u0026rsquo; entity but involving the \u0026lsquo;Car\u0026rsquo; entity will be accepted. For example, the selected instance would not honor a GET request for ../car/1234, but would accept and process a request for ../person/1234/toCar. In practice, the reverse-proxy/load-balancer should be configured to route requests to the correct end-point.\n... ..., \u0026quot;service_activations\u0026quot;: [ { \u0026quot;service_name\u0026quot;: \u0026quot;Person\u0026quot;, \u0026quot;service_active\u0026quot;: true }, { \u0026quot;service_name\u0026quot;: \u0026quot;Car\u0026quot;, \u0026quot;service_active\u0026quot;: false } ] }  Secure User Authentication User authentication is conducted using bcrypt in such a manner that passwords are never stored in the application database. When a user is created, their user-id is stored in the database along with the salt/peppered bcrypt hash of their password. This ensures that in the event of a breach no plain-text passwords can be obtained.\nBcrypt was chosen for the following reasons:\n bcrypt hashes are salt/peppered to mitigate rainbow table attacks bcrypt is slow by design, making brute force reversal a time-consuming and expensive proposition as increased computing power becomes available, the bcrypt cost parameter can be increased (current = 14) the password hash itself is not used for authentication; it is the by-product of successful authentication  When a user logs into the application the following steps occur:\n a lookup of the user-name and stored bcrypt hash is executed against the database the user provided password is hashed in memory using the Go standard lib bcrypt functions and the protected salt/pepper values the computed bcrypt hash is compared to the stored hash value for the user if the hash values match, a JWT (token) is created and signed using ECDSA-256 (adjustable to ECDSA-384, ECDSA-521, RSA-256, RSA-384, RSA-512) the JWT is passed back to the caller and must henceforth be included in the http header of all requests using the Authorization field the user\u0026rsquo;s access credentials are updated in the servicing group-member\u0026rsquo;s cache the user\u0026rsquo;s access credentials are passed via the cache subsystem to all other group-members  In addition to fulfilling the authorization requirements, the JWT is also used as a CSRF equivalent. By default the generated JWT has a validity of one-hour, but this may be adjusted via the application configuration file. See the Authorization and End-Point Security section for more details regarding the content and use of the JWT content/claims.\nAuthorizations \u0026amp; End-Point Security In addition to password authentication, generated applications provide the ability to manage access to their end-points via an authorization scheme. At a high-level:\n An Authorization is generated and linked to each end-point Authorizations are assigned to User Groups User Groups are allocated to Users via a Groups field in the Usr master  -\u0026gt; User | --\u0026gt; Group 1 | | | --\u0026gt; Auth_EndPoint_A | --\u0026gt; Auth_EndPoint_B | --\u0026gt; Auth_EndPoint_C | --\u0026gt; Group 2 | --\u0026gt; Auth_EndPoint_K --\u0026gt; Auth_EndPoint_M  Authorizations Application access can be restricted at the end-point level. Each generated end-point is given a name based on its entity, http method and purpose. The gorilla mux provides an easy way to assign names to end-points in a route declaration, and these names are defined in the generated application as Authorizations or Auths.\nAuthorizations are created per end-point and are therefore known to the router, which in turn allows the route middleware of the generated application to determine which Authorization is needed in order to permit the request to proceed. Recall that an authenticated user is sent a signed base64-encoded JWT token that must be passed in the http header Authorization field of each request. The generated router middleware validates the signature, decodes the token, and then examines its Claims in order to determine whether the request should be allowed to proceed. This level of checking can be thought of as the Authentication verification; does the requesting party have a valid access token for the system in general?\nAssuming that the requesting user has a valid access token, the next step is to determine whether the user has permission to access the requested end-point. Each User is assigned to one or more User Groups and these are included as a Groups Claim in the JWT token when the User logs into the application. As a result, the route middleware is able to examine the content of the Groups Claim in order to determine whether the User is permitted to access the requested end-point. The route authorization check unfolds as follows:\n Verify the requesting user has a valid access token (JWT); can the signature be verified? Is the JWT still valid? Read the Groups Claim from the JWT token Determine the \u0026lsquo;Name\u0026rsquo; (Authorization) of the current route Examine the authorization cache for each Group the User has been assigned to If the required Authorization is found in any of the User Groups that the User has been assigned to, the request is allowed to proceed  The last bullet point is interesting, as it means that end-point access of protected routes is denied by default. Unless access is specifically granted via Authorization -\u0026gt; User Group -\u0026gt; User assignment, the protected end-point is not accessible.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/usage/us-content-a/",
	"title": "Application Configuration Overview",
	"tags": [],
	"description": "",
	"content": " Overview The generated application code can be run unchanged for testing purposes, but some external setup is required.\n Edit the generated .prd.config.json file to define your production configuration. Edit the generated .dev.config.json file to define your development / testing configuration. When using SSL to test locally, SSL certs will be needed. See the SSL setup section below for instructions regarding the generation of certificates suitable for local testing via go test.  Configuration File Overview Sample Development Configuration File { \u0026quot;external_address\u0026quot;: \u0026quot;192.168.1.66:8080\u0026quot;, \u0026quot;internal_address\u0026quot;: \u0026quot;192.168.1.66:4444\u0026quot;, \u0026quot;env\u0026quot;: \u0026quot;dev\u0026quot;, \u0026quot;ping_cycle\u0026quot;: 1, \u0026quot;failure_threshold\u0026quot;: 5, \u0026quot;pepper\u0026quot;: \u0026quot;secret-pepper-key\u0026quot;, \u0026quot;hmac_Key\u0026quot;: \u0026quot;secret-hmac-key\u0026quot;, \u0026quot;database\u0026quot;: { \u0026quot;db_dialect\u0026quot;: \u0026quot;postgres\u0026quot;, \u0026quot;host\u0026quot;: \u0026quot;localhost\u0026quot;, \u0026quot;port\u0026quot;: 5432, \u0026quot;usr\u0026quot;: \u0026quot;godev\u0026quot;, \u0026quot;password\u0026quot;: \u0026quot;gogogo123\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;glrestgen\u0026quot; }, \u0026quot;cert_file\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;key_file\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;rsa256_priv_key_file\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;rsa256_pub_key_file\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;rsa384_priv_key_file\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;rsa384_pub_key_file\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;rsa512_priv_key_file\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;rsa512_pub_key_file\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;ecdsa256_priv_key_file\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;ecdsa256_pub_key_file\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;ecdsa384_priv_key_file\u0026quot;: \u0026quot;jwtkeys/ecdsa384/ec384.priv.pem\u0026quot;, \u0026quot;ecdsa384_pub_key_file\u0026quot;: \u0026quot;jwtkeys/ecdsa384/ec384.pub.pem\u0026quot;, \u0026quot;ecdsa521_priv_key_file\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;ecdsa521_pub_key_file\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;jwt_sign_method\u0026quot;: \u0026quot;ES384\u0026quot;, \u0026quot;jwt_lifetime\u0026quot;: 120, \u0026quot;service_activations\u0026quot;: [ { \u0026quot;service_name\u0026quot;: \u0026quot;Person\u0026quot;, \u0026quot;service_active\u0026quot;: true }, { \u0026quot;service_name\u0026quot;: \u0026quot;Car\u0026quot;, \u0026quot;service_active\u0026quot;: true } ] }  \nConfiguration File Fields    Field Name Optional Description     \u0026ldquo;external_address\u0026rdquo; mandatory \u0026lsquo;external_address\u0026rsquo; is used to instruct the service instance which tcp address:port to publish the service end-points on. Example: \u0026ldquo;external_address\u0026rdquo;: \u0026ldquo;192.168.1.66:8080\u0026rdquo;   \u0026ldquo;internal_address\u0026rdquo; mandatory \u0026lsquo;internal_address\u0026rsquo; is used to instruct the service instance which address:port to use when accepting inter-group-member web-sockets requests. This address:port should ideally be hosted on a separate interface, as the web-sockets communication is conducted without authentication or encryption. Example: \u0026ldquo;internal_address\u0026rdquo;: \u0026ldquo;192.168.1.66:4444\u0026rdquo;   \u0026ldquo;env\u0026rdquo; mandatory \u0026lsquo;env\u0026rsquo; is used to inform the generated server which mode to run in. The material difference between \u0026ldquo;dev\u0026rdquo;, \u0026ldquo;def\u0026rdquo; and \u0026ldquo;prod\u0026rdquo; is slight; the \u0026ldquo;dev\u0026rdquo; and \u0026ldquo;def\u0026rdquo; modes run the ORM in debugging mode, thereby causing the generated SQL statements to be written as a log to stdout.  Valid values: \u0026ldquo;dev\u0026rdquo; or \u0026ldquo;def\u0026rdquo; or \u0026ldquo;prod\u0026rdquo; Example: \u0026ldquo;env\u0026rdquo;: \u0026ldquo;dev\u0026rdquo;   \u0026ldquo;ping_cycle\u0026rdquo; mandatory \u0026lsquo;ping_cycle\u0026rsquo; is used to determine the frequency with which the group-members execute a round of pinging. The value must be a whole number \u0026gt; 0. See the Group Membership section of this file for details regarding the execution of a ping-cycle. Example: \u0026ldquo;ping_cycle\u0026rdquo;: 1   \u0026ldquo;failure_threshold\u0026rdquo; mandatory \u0026lsquo;failure_threshold\u0026rsquo; is used to set the limit for recorded ping failures against any process in the group. At the moment this number is used verbatim, but in the future the number of ping failures required to move a process-status from SUSPECT to FAILED will be dependent on the number of processes in the group. See the Group Membership section of this file for greater detail regarding the ALIVE -\u0026gt; SUSPECT -\u0026gt; FAILED chain of process statuses. Example: \u0026ldquo;failure_threshold\u0026rdquo;: 5   \u0026ldquo;pepper\u0026rdquo; mandatory \u0026lsquo;pepper\u0026rsquo; is used as a pepper seed to the bcrypt password hash. The generated server handles user login authentication via bcrypt hashing of the password the user entered, then comparing the resulting hash to the stored bcrypt password hash that was created when the user set their initial password. Passwords are not kept anywhere in the system. Example:\u0026ldquo;pepper\u0026rdquo;: \u0026ldquo;secret-pepper-key\u0026rdquo;   \u0026ldquo;hmac_key\u0026rdquo; N/A \u0026lsquo;hmac_key\u0026rsquo; is a legacy configuration option left over from the old CSRF implementation. This field has been deprecated. Example: \u0026ldquo;hmac_key\u0026rdquo;: \u0026ldquo;some_easily_shoulder_surfable_value\u0026rdquo;   \u0026ldquo;database\u0026rdquo; mandatory is a JSON block holding the access information for the database system. Fill in what is needed for the type of database you are connecting to. SQLite for example, does not have any user-access control etc.   \u0026ldquo;db_dialect\u0026rdquo; mandatory \u0026lsquo;dialect\u0026rsquo; belongs to the \u0026lsquo;database\u0026rsquo; structure and refers to the database dialect to use to connect to the backend DBMS. Example: \u0026ldquo;db_dialect\u0026rdquo;: \u0026ldquo;postgres\u0026rdquo; The following values are permitted: {\u0026ldquo;postgres\u0026rdquo;, \u0026ldquo;mssql\u0026rdquo;, \u0026ldquo;hdb\u0026rdquo;, \u0026ldquo;sqlite3\u0026rdquo;, \u0026ldquo;mysql\u0026rdquo;}   \u0026ldquo;host\u0026rdquo; mandatory \u0026lsquo;host\u0026rsquo; belongs to the \u0026lsquo;database\u0026rsquo; structure and refers to the ip-address or canonical name of the system hosting the database. Example: \u0026ldquo;host\u0026rdquo;: \u0026ldquo;localhost\u0026rdquo;   \u0026ldquo;port\u0026rdquo; mandatory \u0026lsquo;port\u0026rsquo; belongs to the \u0026lsquo;database\u0026rsquo; structure and refers to the port that the database accepts client connections with. Example: \u0026ldquo;port\u0026rdquo;: 5432   \u0026ldquo;user\u0026rdquo; mandatory \u0026lsquo;user\u0026rsquo; belongs to the \u0026lsquo;database\u0026rsquo; structure and refers to the username used by the application to login to the database. Example: \u0026ldquo;user\u0026rdquo;: \u0026ldquo;godev\u0026rdquo;   \u0026ldquo;password\u0026rdquo; mandatory \u0026lsquo;password\u0026rsquo; belongs to the \u0026lsquo;database\u0026rsquo; structure and refers to the password required for the application to login to the database. Example: \u0026ldquo;password\u0026rdquo;: \u0026ldquo;gogogo123\u0026rdquo;   \u0026ldquo;name\u0026rdquo; mandatory \u0026lsquo;name\u0026rsquo; belongs to the \u0026lsquo;database\u0026rsquo; structure and refers to the name of the database that the application client should connect to. Example: \u0026ldquo;name\u0026rdquo;: \u0026ldquo;testdb\u0026rdquo;   \u0026ldquo;cert_file\u0026rdquo; optional \u0026lsquo;cert_file\u0026rsquo; should point to the location of a self-signed or purchased certificate file and is used to support https. Maintaining a \u0026lsquo;cert_file\u0026rsquo; and \u0026lsquo;key_file\u0026rsquo; in the configuration informs the generated server to publish via https. Example: \u0026ldquo;cert_file\u0026rdquo;: \u0026ldquo;myCert.cer\u0026rdquo;   \u0026ldquo;key_file\u0026rdquo; optional \u0026lsquo;key_file\u0026rsquo; should point to the location of the key-file for the self-signed or purchased certificate file referenced in the \u0026lsquo;key_file\u0026rsquo; configuration key. Maintaining a \u0026lsquo;cert_file\u0026rsquo; and \u0026lsquo;key_file\u0026rsquo; in the configuration informs the generated server to publish via https. Example: \u0026ldquo;key_file\u0026rdquo;: \u0026ldquo;myKeyFile.key\u0026rdquo;   \u0026ldquo;rsa256_priv_key_file\u0026rdquo; optional Private key file for rsa256 JWT verification. Application access is handled via claims embedded in JWT tokens. The JWT header and payload contain the claims and are encoded as base64. In order to ensure the JWT content has not been tampered with, a verification signature based on the JWT content and a set of public-private keys is included in the JWT. Jiffy generates a set of public-private keys for each supported signing algorithm, but only populates the key configuration files with the set corresponding the value set in the \u0026lsquo;jwt_sign_method\u0026rsquo;. Look in the /jwtkeys folder to see the public-private keys generated by Jiffy.If you have an external system that signs JWT\u0026rsquo;s with RSA256, it is possible to provide the Jiffy-generated application with the public-private key-pair by setting their locations and names in the \u0026lsquo;rsa256_priv_key_file\u0026rsquo; and \u0026lsquo;rsa256_pub_key_file\u0026rsquo;. This would allow the external authentication system to create access tokens for the Jiffy-generated application, provided that the correct claims were embedded in the JWT header and payload. This effectively enables a very simple single-sign-on facsimile. The following pub/priv keys can be used for this purpose.   \u0026ldquo;rsa256_pub_key_file\u0026rdquo; optional Public key file for rsa256 JWT verification.   \u0026ldquo;rsa384_priv_key_file\u0026rdquo; optional Private key file for rsa384 JWT verification.   \u0026ldquo;rsa384_pub_key_file\u0026rdquo; optional Public key file for rsa384 JWT verification.   \u0026ldquo;rsa512_priv_key_file\u0026rdquo; optional Private key file for rsa512 JWT verification.   \u0026ldquo;rsa512_pub_key_file\u0026rdquo; optional Public key file for rsa512 JWT verification.   \u0026ldquo;ecdsa256_priv_key_file\u0026rdquo; optional Private key file for ecdsa256 JWT verification.   \u0026ldquo;ecdsa256_pub_key_file\u0026rdquo; optional Public key file for ecdsa256 JWT verification.   \u0026ldquo;ecdsa384_priv_key_file\u0026rdquo; optional Private key file for ecdsa384 JWT verification.   \u0026ldquo;ecdsa384_pub_key_file\u0026rdquo; optional Public key file for ecdsa384 JWT verification.   \u0026ldquo;ecdsa521_priv_key_file\u0026rdquo; optional Private key file for ecdsa521 JWT verification.   \u0026ldquo;ecdsa521_pub_key_file\u0026rdquo; optional Public key file for ecdsa521 JWT verification.   \u0026ldquo;jwt_sign_method\u0026rdquo; mandatory \u0026lsquo;jwt_sign_method\u0026rsquo; informs the application which algorithm should be used to sign the JWT created during the login process. In this example, the ecdsa384_pub_key_file \u0026amp; ecdsa384_priv_key_file key files will be used to sign the JWT. Note that this only applies to JWTs that are created via a direct login into the application via the https://appurl:port/login end-point. It is possible that a user will access the application using a JWT generated somewhere with a set of keys that are also known to the application. Example: \u0026ldquo;jwt_sign_method\u0026rdquo;: \u0026ldquo;ES384\u0026rdquo;   \u0026ldquo;jwt_lifetime\u0026rdquo; mandatory \u0026lsquo;jwt_lifetime\u0026rsquo; informs the application how long generated JWT\u0026rsquo;s are valid for in minutes. The \u0026lsquo;jwt_lifetime\u0026rsquo; value is used to determine the value of the JWT\u0026rsquo;s \u0026lsquo;exp\u0026rsquo; claim. Example:\u0026ldquo;jwt_lifetime\u0026rdquo;: 120   \u0026ldquo;service_activations\u0026rdquo; mandatory When an application is generated based on the model file(s), all service aspects of the complete set of entities will be created. There may be scenarios where it is appropriate to limit the set of activated services on a running instance of an application server. This can be achieved by maintaining the activation status of each modeled entity in the service_activations list.  \u0026lsquo;service_activations is an array containing sets of \u0026lsquo;service_name and \u0026lsquo;service_activation\u0026rsquo;.   \u0026ldquo;service_name\u0026rdquo; mandatory Service name is simply the entity name in CamelCase matching that of the entity\u0026rsquo;s definition in its respective model file.   \u0026ldquo;service_activation\u0026rdquo; mandatory A boolean value (true\\false) describing whether the entity\u0026rsquo;s services are active on the application server. Care must be taken with service activations, as relationships between entities must be considered. Disabling an entity that has a \u0026lsquo;belongsTo\u0026rsquo; relation with an active entity can lead to problems. In such a case, the expectation is that another instance of the application server is running with the required services active. While the generated application server does not handle the rerouting or request forwarding in such a case, it should be possible to direct requests to the correct server based on NGinx config (for example).    Database Dialects Currently, the following db_dialects are supported by the sqac ORM runtime:\n   Database JSON Value for db_dialect field     Postgres \u0026ldquo;db_dialect\u0026rdquo;: \u0026ldquo;postgres\u0026rdquo;   MSSQL (2008+) \u0026ldquo;db_dialect\u0026rdquo;: \u0026ldquo;mssql\u0026rdquo;   SAP Hana \u0026ldquo;db_dialect\u0026rdquo;: \u0026ldquo;hdb\u0026rdquo;   SQLite3 \u0026ldquo;db_dialect\u0026rdquo;: \u0026ldquo;sqlite3\u0026rdquo;   MySQL / MariaDB \u0026ldquo;db_dialect\u0026rdquo;: \u0026ldquo;mysql\u0026rdquo;    "
},
{
	"uri": "https://1414c.github.io/jiffy/interprocess/ip-content-a/",
	"title": "Group Membership Overview",
	"tags": [],
	"description": "",
	"content": " Overview  Jiffy-generated applications can be deployed as single or multiple instances. When running multiple instances of a Jiffy-generated application, a group-membership service establishes connectivity between all running instances. An application instance always runs a group-membership service, even when running as a single instance. Each application instance running the group-membership service can be thought of as a process. At any point in time, the group has an elected leader.\n The group-leader information must be made available via an external persistent store, except in the case of single-instance operation. An interface is provided (gmcom.GMLeaderSetterGetter) in order to support the passing of implementation-specific persistent store accessors to a starting process. This allows the implementer to persist the current group-leader information in any accessible medium (ie. redis, db, flat-file etc.) Jiffy ships with a sample implementation of gmcom.GMLeaderSetterGetter that facilitates the use of a simple web-sockets-based key-store application (https://github.com/1414C/sluggo). Each process has a uint id (PID) that is assigned by the group-leader upon joining the group. Processes join the group by querying the well-known persistent store to obtain the current group-leader information. Once the group-leader is known, the joining instance contacts the leader\u0026rsquo;s address:port and sends a JOIN message. The leader will allocate a new PID for the joining process and send an ACK message in response. The joining process set it\u0026rsquo;s PID based on the PID contained in the ACK message. Processes can join and drop out of the group without any changes to the configuration. Group-membership is managed dynamically via inter-process messaging between group-members. Each process knows the PID of and maintains a local status of every other process in the group. Each process maintains a status-count for every other process in the group.  "
},
{
	"uri": "https://1414c.github.io/jiffy/usage/",
	"title": "Testing and Deployment",
	"tags": [],
	"description": "",
	"content": " Testing and Deployment Jiffy "
},
{
	"uri": "https://1414c.github.io/jiffy/tutorials/",
	"title": "Jiffy Tutorials",
	"tags": [],
	"description": "",
	"content": " Tutorials Jiffy "
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/gs-content-c/",
	"title": "Let&#39;s Build Something",
	"tags": [],
	"description": "",
	"content": "Now that Jiffy is installed, we will build a simple service to test it out.\nJiffy\u0026rsquo;s source tree comes with a number of sample model files that you can be used to get the hang of things. We are going to use a simple model file that contains an entity named \u0026lsquo;Person\u0026rsquo;. The model file can be found in the Jiffy source tree, or pulled directly from the Jiffy github repository.\n $GOPATH/src/github.com/1414C/jiffy/support/testing_models/simpleSingleEntityModel.json jiffy repository model: simpleSingleEntityModel.json  For now we are not going to worry about the content of the model file, but we will look at the structure of our new \u0026lsquo;Person\u0026rsquo; entity briefly.\n// Person structure type Person struct { ID uint64 `json:\u0026quot;id\u0026quot; sqac:\u0026quot;primary_key:inc;start:10000000\u0026quot;` Href string `json:\u0026quot;href\u0026quot; sqac:\u0026quot;-\u0026quot;` Name *string `json:\u0026quot;name,omitempty\u0026quot; sqac:\u0026quot;nullable:true;index:non-unique\u0026quot;` Age *uint `json:\u0026quot;age,omitempty\u0026quot; sqac:\u0026quot;nullable:true\u0026quot;` Weight *float64 `json:\u0026quot;weight,omitempty\u0026quot; sqac:\u0026quot;nullable:true\u0026quot;` ValidLicense *bool `json:\u0026quot;valid_license,omitempty\u0026quot; sqac:\u0026quot;nullable:true;index:non-unique\u0026quot;` }  We can see that Jiffy will create a \u0026lsquo;Person\u0026rsquo; model with a small set of fields, each with a number of attributes. For the moment, we will concern ourselves only with the field names and types, as we will need to use this information to construct some test data for the new service.\n\u0026lsquo;sqac\u0026rsquo; tags are used to pass information to Jiffy\u0026rsquo;s ORM layer.\n \nCreate a new target directory for the project under $GOPATH/src.\n$ cd $GOPATH/src $ mkdir jiffy_tests  \nExecute the jiffy binary, specifying the model file to use, as well as the target directory/project name.\n$ jiffy -m $GOPATH/src/github.com/1414C/jiffy/support/testing_models/simpleSingleEntityModel.json -p /jiffy_tests/first_app  -m tells jiffy which model file should be used to construct the new service.\n-p tells jiffy where to write the generated application code.\nNote that the location of the folder specified by the -p flag is deemed to be relative to $GOPATH/src.\n \nIf everything has gone according to plan, a new application has been generated and should be ready to run. Let\u0026rsquo;s take a look at what jiffy generated for us!\n$ cd $GOPATH/src/jiffy_tests/first_app $ ls -l  This should result in a list of the files and folders comprising our new application.\ndrwxr-xr-x 12 stevem staff 384 5 Feb 21:44 . drwxr-xr-x 10 stevem staff 320 5 Feb 21:44 .. -rwxr-xr-x 1 stevem staff 588 5 Feb 21:44 .dev.config.json -rwxr-xr-x 1 stevem staff 611 5 Feb 21:44 .prd.config.json drwxr-xr-x 4 stevem staff 128 5 Feb 21:44 appobj drwxr-xr-x 10 stevem staff 320 5 Feb 21:44 controllers drwxr-xr-x 4 stevem staff 128 5 Feb 21:44 jwtkeys -rwxr-xr-x 1 stevem staff 839 5 Feb 21:44 main.go -rwxr-xr-x 1 stevem staff 18421 5 Feb 21:44 main_test.go drwxr-xr-x 3 stevem staff 96 5 Feb 21:44 middleware drwxr-xr-x 12 stevem staff 384 5 Feb 21:44 models drwxr-xr-x 3 stevem staff 96 5 Feb 21:44 util $  Jiffy generates two sample configuration files each time it is executed. We are going to run our application with development environment settings, so lets take a quick look at .dev.config.json to make sure there are no horrible surprises.\n{ \u0026quot;port\u0026quot;: 8080, \u0026quot;env\u0026quot;: \u0026quot;dev\u0026quot;, \u0026quot;pepper\u0026quot;: \u0026quot;secret-pepper-key\u0026quot;, \u0026quot;database\u0026quot;: { \u0026quot;db_dialect\u0026quot;: \u0026quot;sqlite\u0026quot;, \u0026quot;host\u0026quot;: \u0026quot;127.0.0.1\u0026quot;, \u0026quot;port\u0026quot;: 0, \u0026quot;usr\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;password\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;testdb.sqlite\u0026quot; }, \u0026quot;cert_file\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;key_file\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;jwt_priv_key_file\u0026quot;: \u0026quot;jwtkeys/private.pem\u0026quot;, \u0026quot;jwt_pub_key_file\u0026quot;: \u0026quot;jwtkeys/public.pem\u0026quot;, \u0026quot;service_activations\u0026quot;: [ { \u0026quot;service_name\u0026quot;: \u0026quot;Person\u0026quot;, \u0026quot;service_active\u0026quot;: true } ] }  Jiffy decides by default to run against a sqlite database and generates what should be a suitable configuration file for most systems. Again, we are not going to worry too much about what is in the configuration file at this point, but know that database file \u0026lsquo;testdb.sqlite\u0026rsquo; will be created in the generated application\u0026rsquo;s root folder.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/extensionpoints/ep-content-b/",
	"title": "Controller Extension Points",
	"tags": [],
	"description": "",
	"content": " Overview Controller extension-points exist for the Create, Update and Get CRUD operations. Each operation has a related extension-point interface, for which an empty implementation may be created when the application is generated. If the generator sees that the extension-point implementation file for an entity has already been created, it will not over-write or create a new version.\nFile ./myapp/controllers/ext/extc_interfaces.go contains the generated entity controller extension-point interface declarations. Each interface and interface method is documented in this file.\nFile ./myapp/controllers/ext/\u0026lt;entity_name\u0026gt;c_ext.go is generated for each entity with empty extension-point interface implementations. This file may be edited by the application developer to add custom application logic.\nController Extension-Point Interfaces  Interface ControllerCreateExt   BeforeFirst(w http.ResponseWriter, r *http.Request) error BeforeFirst is a controller extension-point that can be implemented in order to examine and potentially reject a Create entity request. This extension-point is the first code executed in the controller's Create method. Authentication and Authorization checks should be performed upstream in the route middleware-layer and detailed checks of a request.Body should be carried out by the validator in the model-layer.    AfterBodyDecode(ent interface{}) error AfterBodyDecode is a controller extension-point that can be implemented to perform preliminary checks and changes to the unmarshalled content of the request.Body. Detailed checks of the unmarshalled data from the request.Body should be carried out by the validator in the model-layer. This extension-point should only be used to carry out deal-breaker checks and perhaps to default data in the entity struct prior to calling the validator/normalization methods in the model-layer.    BeforeResponse(ent interface{}) error BeforeResponse is an extension-point that can be implemented to perform checks following the return of the call to the model-layer. At this point, changes to the db will have been made, so failing the call should take this into consideration.     Interface ControllerUpdateExt   BeforeFirst(w http.ResponseWriter, r *http.Request) error BeforeFirst is a controller extension-point that can be implemented in order to examine and potentially reject an Update entity request. This extension-point is the first code executed in the controller's Update method. Authentication and Authorization checks should be performed upstream in the route middleware-layer and detailed checks of a request.Body should be carried out by the validator in the model-layer.    AfterBodyDecode(ent interface{}) error AfterBodyDecode is a controller extension-point that can be implemented to perform preliminary checks and changes to the unmarshalled content of the request.Body. Detailed checks of the unmarshalled data from the request.Body should be carried out by the validator in the model-layer. This extension-point should only be used to carry out deal-breaker checks and perhaps to default data in the entity struct prior to calling the validator/normalization methods in the model-layer.    BeforeResponse(ent interface{}) error BeforeResponse is a controller extension-point that can be implemented to perform checks following the return of the call to the model-layer. At this point, changes to the db will have been made, so failing the call should take this into consideration.     Interface ControllerGetExt   BeforeFirst(w http.ResponseWriter, r *http.Request) error BeforeFirst is a controller extension-point that can be implemented in order to examine and potentially reject a Get entity request. This extension-point is the first code executed in the controller's Create method. Authentication and Authorization checks should be performed upstream in the route middleware-layer.    BeforeModelCall(ent interface{}) error BeforeModelCall is a controller extension-point that can be implemented in order to make changes to the content of the entity structure prior to calling the model-layer. By default the controller's Get method will populate the ID field of the entity structure using the :id value provided in the request URL. The use of this extension-point would be seemingly rare and any values added to the struct would be over-written in the model-layer when the call to the DBMS is made. The added values would however be available for use in the validation/normalization and DBMS access methods prior to the call to the ORM.    BeforeResponse(ent interface{}) error BeforeResponse is a controller extension-point that can be implemented to perform checks / changes following the return of the call to the model-layer. At this point, the db has been read and the populated entity structure is about to be marshaled into JSON and passed back to the router/mux.    "
},
{
	"uri": "https://1414c.github.io/jiffy/generation/gn-content-b/",
	"title": "Generated &#39;application&#39; Folder",
	"tags": [],
	"description": "",
	"content": "Following the execution of the application generator, a folder containing the generated app\u0026rsquo;s files is created as shown. The application folder follows the name provided via the -p Jiffy execution flag. In this case, the name of the application folder is \u0026lsquo;FirstApp\u0026rsquo;.\nFirstApp ├── appobj │ ├── appconf.go │ └── appobj.go ├── controllers │ ├── ... │ ├── ... . . . ├── .dev.config.json ├── .prd.config.json ├── main_test.go └── main.go  "
},
{
	"uri": "https://1414c.github.io/jiffy/models/mo-content-b/",
	"title": "Simple Two Entity Model",
	"tags": [],
	"description": "",
	"content": " Two Entity Model The following JSON illustrates the definition of a simple two-entity model file. In this case, model entities \u0026lsquo;Person\u0026rsquo; and \u0026lsquo;Country\u0026rsquo; will be created in the generated application, along with corresponding database tables \u0026lsquo;person\u0026rsquo; and \u0026lsquo;country\u0026rsquo;. No relationships have been defined between the two entities; this example simply illustrates how to add multiple entity definitions to a model file.\n{ \u0026quot;entities\u0026quot;: [ { \u0026quot;typeName\u0026quot;: \u0026quot;Person\u0026quot;, \u0026quot;properties\u0026quot;: { \u0026quot;name\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: false, \u0026quot;unique\u0026quot;: false, \u0026quot;index\u0026quot;: \u0026quot;nonUnique\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,like\u0026quot; }, \u0026quot;age\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;uint\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: false, \u0026quot;unique\u0026quot;: false, \u0026quot;index\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,lt,gt\u0026quot; }, \u0026quot;weight\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;float64\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: false, \u0026quot;unique\u0026quot;: false, \u0026quot;index\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,lt,le,gt,ge\u0026quot; }, \u0026quot;validLicense\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;bool\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: false, \u0026quot;unique\u0026quot;: false, \u0026quot;index\u0026quot;: \u0026quot;nonUnique\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,ne\u0026quot; } }, \u0026quot;ext_points\u0026quot;: { \u0026quot;gen_controller\u0026quot;: true, \u0026quot;gen_model\u0026quot;: true } }, { \u0026quot;typeName\u0026quot;: \u0026quot;Country\u0026quot;, \u0026quot;properties\u0026quot;: { \u0026quot;name\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: false, \u0026quot;unique\u0026quot;: false, \u0026quot;index\u0026quot;: \u0026quot;nonUnique\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,like\u0026quot; }, \u0026quot;isoCode\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;uint\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: false, \u0026quot;unique\u0026quot;: false, \u0026quot;index\u0026quot;: \u0026quot;unique\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,lt,gt\u0026quot; } }, \u0026quot;ext_points\u0026quot;: { \u0026quot;gen_controller\u0026quot;: true, \u0026quot;gen_model\u0026quot;: true } } ] }  The sample model file can be downloaded from the following location: simpleTwoEntityModel.json.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/tutorials/tt-content-b/",
	"title": "Dealing with mixed/multipart",
	"tags": [],
	"description": "",
	"content": " Supporting mixed/multipart "
},
{
	"uri": "https://1414c.github.io/jiffy/execution/ex-content-b/",
	"title": "Jiffy Execution Flags",
	"tags": [],
	"description": "",
	"content": " Generation Flags Flags are kept to a minimum, but there are a few flags that can be appended to the execution command:\n go run main.go -m ./my_model.json  By default, the application will attempt to use ./support/testing_models/models.json as the model source, but inclusion of the -m flag permits the use of a more useful model file. The path of model file in the application base directory must be prefaced with ./ . If the model file is not located in the base directory of the application, the full path must be specified when using the -m flag.   go run main.go -m \u0026quot;./my_model.json\u0026quot;   go run main.go -mf ./model_folder  By default, the application will attempt to use ./support/testing_models/models.json as the model source, but inclusion of the -mf flag instructs the generator to read and process all model files contained in the specified folder. The path of models folder in the application base directory must be prefaced with ./ . If the models folder is not located in the base directory of the application, the full path must be specified when using the -mf flag.   go run main.go -mf \u0026quot;./models_folder\u0026quot;   go run main.go -p /target_dir  The -p switch is used to specify the target directory for generated application source-code relative to $GOPATH/src.   $ go run main.go -m \u0026quot;./my_model.json\u0026quot; -p \u0026quot;/github.com/footle.com/mynewsvcs\u0026quot;  Typical Use Typically you will want to provide your own model file and direct Jiffy to write the source code for the new application to a non-default destination.\ngo run main.go -m \u0026quot;./my_model.json\u0026quot; -p \u0026quot;/github.com/footle.com/mynewsvcs\u0026quot;  In the case where you have created more than one model file for your application, the -mf flag is used to instruct Jiffy to read all the models in specified location.\ngo run main.go -mf \u0026quot;./models_folder\u0026quot; -p \u0026quot;/github.com/footle.com/mynewsvcs\u0026quot;  "
},
{
	"uri": "https://1414c.github.io/jiffy/installation/in-content-b/",
	"title": "Jiffy Installation",
	"tags": [],
	"description": "",
	"content": " Installation Steps The easiest way to install Jiffy is to use go get on the command-line to pull the latest version from github, as shown below:\n$ go get -u github.com/1414C/jiffy  The \u0026lsquo;go get -u\u0026rsquo; command will pull the jiffy github repository into your $GOPATH/src/github.com folder, as well as any dependencies referenced by the Jiffy source code. The -u flag is included to instruct go get to check for and pull updates to jiffy packages and their dependencies. This is the least sophisticated way of managing dependencies in go. As of this writing \u0026lsquo;vgo\u0026rsquo; is not officially a part fo the golang toolchain.\nOnce the Jiffy source code and dependencies have been installed into your $GOPATH, you can use go build to compile a binary from the Jiffy sources. The easiest way to do this is to open a terminal window, switch to $GOPATH/src/github.com/1414C/jiffy and run go build as shown below.\n$ go build -v  This will result in the creation of a binary file called \u0026lsquo;jiffy\u0026rsquo;. You may move the \u0026lsquo;jiffy\u0026rsquo; binary anywhere in your $PATH, but convention would have it installed in /usr/local/bin. Once you have moved the \u0026lsquo;jiffy\u0026rsquo; binary to its new home, open a new terminal window and use the which command to ensure that the binary is in the $PATH.\n$ which jiffy -a  If which cannot find the jiffy binary (or finds the wrong one!), ensure that the $PATH is set correctly. It is also possible to run Jiffy from its source-code via the \u0026lsquo;go run main.go \u0026hellip; \u0026hellip;\u0026rsquo; command.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/overview/ov-content-b/",
	"title": "Jiffy Application Overview",
	"tags": [],
	"description": "",
	"content": " What does a generated Jiffy application look like? Generated Jiffy applications can be pointed at the DBMS of your choice without the need to recompile the binary (architecture differences not withstanding). This means that a developer can build a model, fully test it locally using SQLite and then redirect the application to a formal testing environment running SAP Hana, or any of the other supported database systems.\nApplications are generated based on model files which are encoded as simple JSON. The concepts of entity and resource-id form the cornerstones upon which the model, application and RESTful end-points are built.\nEntities can be thought of anything that needs to be modeled; Order, Customer, Invoice, Truck, \u0026hellip;, \u0026hellip; Each entity is mandated to have an ID field, which is analogous to a primary-key or row-id in the backend database. ID is used as the primary resource identifier for an entity, and is setup by default as an auto-incrementing column in the database. ID is implemented as go-type uint64 and is inserted into the model entity definition during application generation.\nSimple CRUD Access Accessing an entity via the generated CRUD interface is very simple. For example, a customer entity could be defined in the model and then accessed via the application as follows:\n Create a customer entity:\n https://servername:port/customer + {JSON body} + POST  Update a customer entity:\n https://servername:port/customer/:id + {JSON body} + PUT  Read a customer entity:\n https://servername:port/customer/:id + GET  Delete a customer entity:\n https://servername:port/customer/:id + DELETE  Read all customer entities:\n https://servername:port/customers + GET   Filters and Relationships Additional routes can also be generated based on the model file, including custom filters for GET operations, static end-points for common GET operations, HasOne, HasMany and BelongsTo relationships:\n Use a filter to Get customers where the last name is \u0026lsquo;Smith\u0026rsquo;:\n https://servername:port/customers/?last_name=Smith + GET  Use a generated static end-point to Get customers where credit score is less than 4:\n https://servername:port/customers/credit_score(LT 4) + GET  Use a generated relationship to retrieve all orders for a specific customer (10023):\n https://servername:port/customer/10023/orders + GET  Use a generated relationship to retrieve a specific order (99000022) for the specified customer (10023):\n https://servername:port/customer/10023/order/99000022 + GET  Use a generated belongsTo relationship to retrieve the customer for a specific order (990000222):\n https://servername:port/order/99000022/customer + GET   Commands A set of commands can be appended to an operation\u0026rsquo;s URL to perform some common activities. The commands can be appended to the URL in any order.\n Get a count of all customer entities:\n https://servername:port/customer/$count + GET  Limit the number of returned customer entities to 3. The default ordering for this example would be ascending based on the entity ID field.\n https://servername:port/customer/$limit=3 + GET  Offset the database selection by 2 records, top-down, using the default order; (ascending based on the entity ID field):\n https://servername:port/customer/$offset=2 + GET  Select records in descending order based on the entity ID field:\n https://servername:port/customer/$desc + GET  Select records in descending order using the customer name field as the order-by criteria:\n https://servername:port/customer/$orderby=name$desc + GET  Limit the number of selected records to 3 and select in descending order based on the entity ID field:\n https://servername:port/customer/$limit=3/$desc + GET  Limit the number of selected records to 3 and select in ascending order using the customer name field as the order-by criteria:\n https://servername:port/customer/$limit=3;$orderby=name$asc + GET  Limit the number of selected records to 3 with an offset of 2 and select the records in ascending order using the customer name field as the sort criteria:\n https://servername:port/customer/$limit=3$offset=2$orderby=name$asc + GET  Limit the return of a static filter end-point to 3 records:\n https://servername:port/customers/credit_score(LT4)/$limit=3 + GET   More details regarding application modeling are contained in later sections of this documentation.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/accesscontrol/ac-content-b/",
	"title": "Authorizations",
	"tags": [],
	"description": "",
	"content": " Standard CRUD Authorizations As discussed in the Access Control Overview, each of the generated services end-points is assigned a name which is used as an Authorization object by the router middleware.\nStandard CRUD end-points for entity Library are generated as follows:\n// ====================== Library protected routes for standard CRUD access ====================== a.router.HandleFunc(\u0026quot;/librarys\u0026quot;, requireUserMw.ApplyFn(a.libraryC.GetLibrarys)).Methods(\u0026quot;GET\u0026quot;).Name(\u0026quot;library.GET_SET\u0026quot;) a.router.HandleFunc(\u0026quot;/library\u0026quot;, requireUserMw.ApplyFn(a.libraryC.Create)).Methods(\u0026quot;POST\u0026quot;).Name(\u0026quot;library.CREATE\u0026quot;) a.router.HandleFunc(\u0026quot;/library/{id:[0-9]+}\u0026quot;, requireUserMw.ApplyFn(a.libraryC.Get)).Methods(\u0026quot;GET\u0026quot;).Name(\u0026quot;library.GET_ID\u0026quot;) a.router.HandleFunc(\u0026quot;/library/{id:[0-9]+}\u0026quot;, requireUserMw.ApplyFn(a.libraryC.Update)).Methods(\u0026quot;PUT\u0026quot;).Name(\u0026quot;library.UPDATE\u0026quot;) a.router.HandleFunc(\u0026quot;/library/{id:[0-9]+}\u0026quot;, requireUserMw.ApplyFn(a.libraryC.Delete)).Methods(\u0026quot;DELETE\u0026quot;).Name(\u0026quot;library.DELETE\u0026quot;)  Notice that each end-point handler is assigned a name via the gorilla.mux.Route.Name(\u0026ldquo;string\u0026rdquo;) method. The generated end-point names follow the standard shown here, but in practice it is safe to change them to whatever works best for your implementation. Duplicate names in the same router will cause the existing name-route combination to be overwritten by the latest name-route addition as per the gorilla API docs. Avoid the use of duplicate names. The set of generated Authorizations for the Library entities CRUD end-points are:\n library.GET_SET library.CREATE library.GET_ID library.UPDATE library.DELETE  Static Filter Authorizations Static Filter end-points for entity Library follow the same rules as mentioned above and are generated as follows:\n//=================================== Library Static Filters =================================== // http://127.0.0.1:\u0026lt;port\u0026gt;/librarys/name(EQ '\u0026lt;sel_string\u0026gt;') a.router.HandleFunc(\u0026quot;/librarys/name{name:[(]+(?:EQ|eq|LIKE|like)+[ ']+[a-zA-Z0-9_]+[')]+}\u0026quot;, requireUserMw.ApplyFn(a.libraryC.GetLibrarysByName)).Methods(\u0026quot;GET\u0026quot;).Name(\u0026quot;library.STATICFLTR_ByName\u0026quot;) // http://127.0.0.1:\u0026lt;port\u0026gt;/librarys/city(EQ '\u0026lt;sel_string\u0026gt;') a.router.HandleFunc(\u0026quot;/librarys/city{city:[(]+(?:EQ|eq)+[ ']+[a-zA-Z0-9_]+[')]+}\u0026quot;, requireUserMw.ApplyFn(a.libraryC.GetLibrarysByCity)).Methods(\u0026quot;GET\u0026quot;).Name(\u0026quot;library.STATICFLTR_ByCity\u0026quot;)  The set of generated Authorizations for the Library entity\u0026rsquo;s static filter end-points are:\n library.STATICFLTR_ByName library.STATICFLTR_ByCity  Relation Authorizations Relation end-points for entity Library follow the same rules as mentioned above and are generated as follows:\n//====================================== Library Relations ====================================== // hasMany relation ToBooks for Library a.router.HandleFunc(\u0026quot;/library/{library_id:[0-9]+}/tobooks\u0026quot;, requireUserMw.ApplyFn(a.libraryC.GetLibraryToBooks)).Methods(\u0026quot;GET\u0026quot;).Name(\u0026quot;library.REL_tobooks\u0026quot;) a.router.HandleFunc(\u0026quot;/library/{library_id:[0-9]+}/tobooks/{book_id:[0-9]+}\u0026quot;, requireUserMw.ApplyFn(a.libraryC.GetLibraryToBooks)).Methods(\u0026quot;GET\u0026quot;).Name(\u0026quot;library.REL_tobooks_id\u0026quot;)  The set of generated Authorizations for the Library entity\u0026rsquo;s relation end-points are:\n library.REL_tobooks library.REL_tobooks_id  Authorization Generation Authorizations are assigned to end-points in the route declarations as described in the preceding sections. They are also added to a table (auth) in the backing database, as are the User Groups (table usrgroup) and the assignment of Authorizations to the same (via table groupauth).\nAt application start-up, a walk of the router is performed in order to obtain a complete list of Authorizations. This is necessary, as changes may have been made to the application since the last time it was run. For example, a new entity may have been added; the Authorizations for the corresponding end-points need to be made available via the creation of new entries in the auth table. The creation of the new Authorizations in the auth table does not add them to any User Groups, but simply makes them available for use.\nAuthorization Maintenance The end-points related to Authorization, User Group and User maintenance are protected by default. This means that in order to perform any activities (such as create Users) in the generated application, an initial User belonging to a User Group with sufficient Authorizations is required. To this end, a User called \u0026lsquo;admin\u0026rsquo; and a User Group called \u0026lsquo;Super\u0026rsquo; are created by default the first time the application is run. This unfolds as follows:\n A complete list of the route Authorizations is obtained by walking the router as described above in the Authorization Generation section. Table usrgroup is checked for the existence of the \u0026lsquo;Super\u0026rsquo; group. If the \u0026lsquo;Super\u0026rsquo; User Group is not found, it is created. All existing Authorization allocations to the \u0026lsquo;Super\u0026rsquo; User Group are deleted. The list of route Authorizations is then used to allocate Authorization for each end-point to the \u0026lsquo;Super\u0026rsquo; User Group. A check for the existence of the \u0026lsquo;admin\u0026rsquo; user is executed against the usr table. If the \u0026lsquo;admin\u0026rsquo; user does not exist, it is created as a member of the \u0026lsquo;Super\u0026rsquo; User Group, with an initial password of \u0026lsquo;initpass\u0026rsquo;. As the User Group Authorizations are cached on all application instances in the pool, the cache is re-initialized locally and then distributed to the other pool members so that the \u0026lsquo;Super\u0026rsquo; group is generally available.  It is possible to force a rebuild of the \u0026lsquo;Super\u0026rsquo; User Group\u0026rsquo;s Authorization allocations by starting the generated application with the -rs (rebuild super) flag. This will force the application to run through the preceding list of steps, resulting in a \u0026lsquo;Super\u0026rsquo; User Group that contains a complete list of the Authorizations needed to access all end-points, as well as removing any end-point Authorizations that may no longer exist. Only the \u0026lsquo;Super\u0026rsquo; User Group may be updated in this manner. Changes to existing User Groups must be carried out manually by an authorized user via the end-points related to User, User Group and Authorization maintenance.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/usage/us-content-b/",
	"title": "Default Configuration",
	"tags": [],
	"description": "",
	"content": " Default Config The following command strings may be used to run the program using a set of default configuration that has been hard-coded into the source files. The default configuration may be edited in the generated appobj/appconf.go file to suit local requirements. The default application settings are shown in the server configuration file format. The default configuration publishes the end-points on port 3000 over http due to the absence of the ‘cert_file’ and ‘key_file’ values.\n$ go run main.go  or\n$ go run main.go -def  Default Configuration Settings The default configuration settings are shown below:\n{ \u0026quot;external_address\u0026quot;: \u0026quot;127.0.0.1:3000\u0026quot;, \u0026quot;internal_address\u0026quot;: \u0026quot;127.0.0.1:4444\u0026quot;, \u0026quot;env\u0026quot;: \u0026quot;def\u0026quot;, \u0026quot;ping_cycle\u0026quot;: 1, \u0026quot;failure_threshold\u0026quot;: 5, \u0026quot;pepper\u0026quot;: \u0026quot;secret-pepper-key\u0026quot;, \u0026quot;hmac_Key\u0026quot;: \u0026quot;secret-hmac-key\u0026quot;, \u0026quot;database\u0026quot;: { \u0026quot;db_dialect\u0026quot;: \u0026quot;postgres\u0026quot;, \u0026quot;host\u0026quot;: \u0026quot;localhost\u0026quot;, \u0026quot;port\u0026quot;: 5432, \u0026quot;user\u0026quot;: \u0026quot;godev\u0026quot;, \u0026quot;password\u0026quot;: \u0026quot;gogogo123\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;glrestgen\u0026quot; }, \u0026quot;cert_file\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;key_file\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;rsa256_priv_key_file\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;rsa256_pub_key_file\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;rsa384_priv_key_file\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;rsa384_pub_key_file\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;rsa512_priv_key_file\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;rsa512_pub_key_file\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;ecdsa256_priv_key_file\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;ecdsa256_pub_key_file\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;ecdsa384_priv_key_file\u0026quot;: \u0026quot;jwtkeys/ecdsa384/ec384.priv.pem\u0026quot;, \u0026quot;ecdsa384_pub_key_file\u0026quot;: \u0026quot;jwtkeys/ecdsa384/ec384.pub.pem\u0026quot;, \u0026quot;ecdsa521_priv_key_file\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;ecdsa521_pub_key_file\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;jwt_sign_method\u0026quot;: \u0026quot;ES384\u0026quot;, \u0026quot;jwt_lifetime\u0026quot;: 120, \u0026quot;service_activations\u0026quot;: [ { \u0026quot;service_name\u0026quot;: \u0026quot;Library\u0026quot;, \u0026quot;service_active\u0026quot;: true }, { \u0026quot;service_name\u0026quot;: \u0026quot;Book\u0026quot;, \u0026quot;service_active\u0026quot;: true } ] }  "
},
{
	"uri": "https://1414c.github.io/jiffy/interprocess/ip-content-b/",
	"title": "Failure Detector",
	"tags": [],
	"description": "",
	"content": " Group Membership Failure Detector  When discussing deployment of a Jiffy-generated application, each instance of the application is referred to as a process or application instance. Processes may fail. Processes exist with one of three publicly disseminated and well-known statuses: {ACTIVE; SUSPECT; FAILED} Processes exist with a publicly (within the group) disseminated incarnation number. Process viability is checked at selectable intervals (ping-cycle time) via a ping-ack mechanism. Each process pings all other processes in the group in random order once per ping-cycle. Each process is guaranteed to ping every other process in the group in (2n-1) pings, where n is the number of non-failed processes in the process-list. Processes failing a ping-ack exchange are not immediately failed but are moved into the SUSPECT state. The failure-threshold outlining the number of permissible ping-ack failures for a SUSPECT process is configurable via the \u0026lsquo;failure_threshold\u0026rsquo; key in the application configuration file. At the moment, the configuration value is used directly, but in large groups or groups where the number of active members varies greatly it would make sense to use the configuration value in combination with the number of active processes in the group to determine an appropriate SUSPECT to FAILURE threshold value. The local status-count of the SUSPECT process is incremented once for each failed ping or notification of a failed Ping from another process in the group. Process status is disseminated across all processes by way of a gossip-based infection-style piggybacking of process information on top of a process\u0026rsquo;s outgoing Ping messages. Pinging process (Pi) sends a Ping containing it\u0026rsquo;s local group-membership list to a target process (Pj). Process Pj receives the Ping, takes note of the included group-membership list from Pi, updates its own group-membership list with SUSPECT/FAILED information, then sends an Ack message back to Pi. Ping status scenarios are broken out in a subsequent section. Once a SUSPECT process (Pj) reaches the failure-threshold in any pinging process (Pi), process Pi moves process Pj from the SUSPECT to the FAILED state in its local group-membership list. A FAILED status is immutable, and the failed process will be removed from the group. If a process (Pi) receives a Ping message from another process (Pj) indicating that Pi is in a SUSPECT state, process Pi increments it\u0026rsquo;s incarnation number and continues to participate in the ping-cycle. Processes receiving pings from process Pi take note of Pi\u0026rsquo;s new incarnation number and set their internal record of Pi back to an ACTIVE status. However, if any process in the group has already set Pi\u0026rsquo;s status to FAILED this will override Pi\u0026rsquo;s incarnation number-based signal of liveness and all members will set their Pi status to FAILED. It may be desirable to enhance the application slightly in this area to cause process-failures to trigger some sort of notification.  Typically the implementer should not have to worry about the failure detector beyond establishing reasonable limits for SUSPECT status Ping failures and setting a reasonable ping-cycle time.\nProcess Status Scenarios Consider a group-membership of {P1; P2; P3} where failure-threshold == 3:\nP1 Ping-Cycle\n (P1-Ping) -\u0026gt; (P2) (P2-Ack) -\u0026gt; (P1) (P1-Ping) -\u0026gt; (P3) (P3-Ack) -\u0026gt; (P1) (P1-Ping) -\u0026gt; (P1) (P1-Ack) -\u0026gt; (P1)  P2 Ping-Cycle\n (P2-Ping) -\u0026gt; (P1\u0026gt; (P1-Ack) -\u0026gt; (P2) (P2-Ping) -\u0026gt; (P3) (P3-Ack) -\u0026gt; (P2) (P2-Ping) -\u0026gt; (P2) (P2-Ack) -\u0026gt; (P2)  P3 Ping-Cycle\n (P3-Ping) -\u0026gt; (P1) (P1-Ack) -\u0026gt; (P3) (P3-Ping) -\u0026gt; (P2) (P2-Ack) -\u0026gt; (P3) (P3-Ping) -\u0026gt; (P3) (P3-Ack) -\u0026gt; (P3)  Example 1 (P1-Ping-1) -\u0026gt; (P2)\n(P2-NoAck)\nP1 moves P2\u0026rsquo;s status to SUSPECT in the local P1 group-membership list and sets the P2 status-count back to 1.\n\u0026hellip; ping-cycle completes\n(P1-Ping-2) -\u0026gt; (P2)\n(P2-NoAck)\nP1 leaves P2\u0026rsquo;s status as SUSPECT in the local P1 group-membership list and increments the P2 status-count by 1 (==2).\n\u0026hellip; ping-cycle completes\n(P1-Ping-3) -\u0026gt; (P2)\n(P2-NoAck)\nP1 moves P2\u0026rsquo;s status to FAILED in the local P1 group-membership list and increments the P2 status-count by 1 (==3).\n\u0026hellip; ping-cycle completes\nAs P1\u0026rsquo;s group-membership list is being updated with the P2 ping failures, P1 is disseminating that information to the other processes in the group. It is likely that other processes in the group have also noticed that P2 is not responding, so these processes are also disseminating the P2 SUSPECT status to all other processes in the group - including P1. As a result, failing processes will accrue SUSPECT status counts rapidly in each process\u0026rsquo;s group-membership list; the failure threshold value should be computed as a product of the number of running processes in the group (TODO).\nExample 2 (P1-Ping-1) -\u0026gt; (P2)\n(P2-NoAck)\nP1 moves P2\u0026rsquo;s status to SUSPECT in the local P1 group-membership list and sets the P2 status-count back to 1.\n\u0026hellip; ping -cycle completes\n(P1-Ping-2) -\u0026gt; (P2)\n(P2-NoAck)\nP1 leaves P2\u0026rsquo;s status as SUSPECT in the local P1 group-membership list and increments the P2 status-count by 1 (==2).\n\u0026hellip; ping-cycle completes\n(P1-Ping-3) -\u0026gt; (P2)\n(P2-Ack) -\u0026gt; (P1)\nP1 may set P2\u0026rsquo;s status back to ALIVE in the local P1 group-membership list and reset the P2 status-count back to 1).\n\u0026hellip; ping-cycle completes\nWhy would P1 not guarantee the reset of P2\u0026rsquo;s status to the ALIVE state after receiving an Ack for last Ping message?\nAs the ping-cycles run, the possibility exists that if P2 were to come back online it may receive a Ping message containing a group-membership list where it (P2) is in a SUSPECT state. If P2 sees that it is SUSPECT, it reacts by incrementing it\u0026rsquo;s incarnation-number which is then relayed to the group-members via P2\u0026rsquo;s ping messages. When a process (let\u0026rsquo;s say P1), sees that SUSPECT process P2 has sent a Ping, it checks the embedded incarnation-number to see if it is greater than the P2 incarnation-number presently stored in P1\u0026rsquo;s local group-membership list. If the incarnation-number contained in the Ping is greater, P1 updates it\u0026rsquo;s group-membership list to indicate that P2 is ALIVE with a new incarnation number. If the incarnation-number in the (P2-Ping) is lower or the same as that of the P2 record in the local P1 group-membership list, the Ping is discarded.\nP2 can still send the Ack\u0026rsquo;s in response to Pings coming from other processes, and due to the concurrent nature of the service, it may well send a Ping to the other group-members (P1 for example) in time to prevent itself from being failed, but this is an unavoidable edge-case. When a SUSPECT process recovers to the extent that it is reachable again, and one or more group-members are very close to reaching the failure-threshold for the process in question, there is a chance that the recovered process will be failed anyway.\nThere is a lot more to write here in order to completely describe the mechanics of how the failure detector works. Additionally, the failure detector operates using a bully-type algorithm that has been abridged slightly to favor the highest known process as the new leader is a current-leader failure scenario. Highest known process is determined locally through introspection of each application instance\u0026rsquo;s group-membership map. This is in contract to the typical bully implementation where ELECT-OK messages are used alongside local introspection. The codebase contains a full bully algorithm implementation, but the ELECT-OK message pair have been commented out for now. There is a tentative plan to do one or both of the following:\n Reimplement the failure detector using the Raft algorithm. Retool the jiffy application to create applications tightly integrated into the Kubernetes / CoreOS ecosystems.  "
},
{
	"uri": "https://1414c.github.io/jiffy/overview/ov-content-c/",
	"title": "Jiffy Application Structure",
	"tags": [],
	"description": "",
	"content": " Jiffy Application File Structure iffy generates the following structure when provided with a model-file describing a simple \u0026lsquo;Person\u0026rsquo; entity. Explanations of each folder and its content are discussed throughout the documentation.\nFirstApp ├── appobj │ ├── appconf.go │ └── appobj.go ├── controllers │ ├── authc.go │ ├── controllerfuncs.go │ ├── groupauthc.go │ ├── person_relationsc.go │ ├── personc.go │ ├── usrc.go │ ├── usr_groupc.go │ └── ext │ ├── extc_interfaces.go │ └── personc_ext.go ├── group │ ├── gmcl │ │ ├── gmclient.go │ ├── gmcom │ │ ├── gmcache.go │ │ ├── gmclsrv.go │ │ ├── gmerrors.go │ │ └── gmomap.go │ └── gmsrv │ ├── gmprocessors.go │ ├── gmprotocol_senders.go │ ├── gmserver.go │ └── gmtxrx.go ├── jwtkeys │ ├── ecdsa256 │ │ ├── ecdsa.priv.pem │ │ └── ecdsa.pub.pem │ ├── ecdsa384 │ │ ├── ecdsa384.prive.pem │ │ └── ecdsa384.pub.pem │ ├── ecdsa521 │ │ ├── ecdsa521.priv.pem │ │ └── ecdsa521.pub.pem │ ├── rsa256 │ │ ├── rsa.priv.pem │ │ └── rsa.pub.pem │ ├── rsa384 │ │ ├── rsa384.prive.pem │ │ └── rsa384.pub.pem │ └── rsa512 │ ├── rsa512.priv.pem │ └── rsa512.pub.pem ├── middleware │ └── requireuser.go ├── models │ ├── authm.go │ ├── errors.go │ ├── group_authm.go │ ├── modelfuncs.go │ ├── personm_ext.go │ ├── personm.go │ ├── servicesm.go │ ├── usr_groupm.go │ ├── usrm.go │ └── ext │ └── model_ext_interfaces.go ├── util │ └── strings.go ├── .dev.config.json ├── .prd.config.json ├── main_test.go └── main.go  Jiffy Application Services Jiffy approaches the API from a services perspective. Each entity has a corresponding service that can be started when the application initializes. The Usr, UsrGroup, Auth and GroupAuth services are always generated and enabled by default when creating a Jiffy application. Additional services are generated based on the model files created based on the business scenario.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/gs-content-d/",
	"title": "Let&#39;s Run Something",
	"tags": [],
	"description": "",
	"content": "Let\u0026rsquo;s execute our first application!\n$ cd $GOPATH/src/jiffy_tests/first_app $ go run main.go -dev -rs  Executing with the -dev and -rs flags instructs our new application to initialize itself using the development configuration file, and forces a rebuild of the \u0026lsquo;Super\u0026rsquo; authorization-group. Consequently, some warning and info messages will scroll up the screen which is expected.\n2018/02/05 22:29:26 package sqac init is running 2018/02/05 22:29:26 successfully loaded the config file... 2018/02/05 22:29:26 JWTPrivKeyFile: jwtkeys/private.pem 2018/02/05 22:29:26 JWTPubKeyFile: jwtkeys/public.pem 2018/02/05 22:29:26 warning: auth usr.GET_SET not found in the db Auth master data 2018/02/05 22:29:26 warning: auth usr.CREATE not found in the db Auth master data 2018/02/05 22:29:26 warning: auth usr.GET_ID not found in the db Auth master data ... ... 2018/02/05 22:29:26 info: creating auth usr.GET_SET in the db Auth master data 2018/02/05 22:29:26 warning: new auth usr.GET_SET must be added to at least one group 2018/02/05 22:29:26 info: creating auth usr.CREATE in the db Auth master data 2018/02/05 22:29:26 warning: new auth usr.CREATE must be added to at least one group ... ... 2018/02/05 22:29:26 warning: new auth person.STATICFLTR_ByValidLicense must be added to at least one group 2018/02/05 22:29:26 info: creating auth person.STATICFLTR_CMD_ByValidLicense in the db Auth master data 2018/02/05 22:29:26 warning: new auth person.STATICFLTR_CMD_ByValidLicense must be added to at least one group 2018/02/05 22:29:26 The Super UsrGroup has been initialized with 42 Auth objects. 2018/02/05 22:29:26 re-initializing local middleware to accomodate Super group changes. 2018/02/05 22:29:27 admin user created with ID: 1 and initial password of initpass Development settings selected... Starting http server on port... 8080  If all goes well, a message indicating that the application is running will be displayed. During the startup, the application executed a number of steps:\n Loaded the development configuration file. Initialized a handle to the underlying sqac ORM. Checked for and loaded the public and private keys for JWT support. Checked for and created the user, auth, and usrgroup tables in the database. Checked for and created the person table in the database based on the \u0026lsquo;Person\u0026rsquo; model. Checked for and created authorizations in the database for each service end-point. Checked for and created the Super user-group in the database. Assigned all authorizations to the Super user-group. Created the \u0026lsquo;admin\u0026rsquo; user and assigned it to the \u0026lsquo;Super\u0026rsquo; user-group. Initialized the authorization, user, user-group and auth-groups caches in the router. Started the router. Looked at the leader-persistence store to determine the group-leader (and failed). Became the defacto group-leader, set own process-id (usually to 1 in this case). Updated the leader-persistence store with the new group-leader information. Started the inter-process failure-detector.  Congratulations! Your first application is now open for business at http://127.0.0.1:8080\n"
},
{
	"uri": "https://1414c.github.io/jiffy/extensionpoints/ep-content-c/",
	"title": "Model Extension Points",
	"tags": [],
	"description": "",
	"content": " Overview Model extension-points exist for the Create, Update and Get CRUD operations. Each operation has a related extension-point interface, for which an empty implementation is created when the application is generated. If the generator sees that the extension-point implementation file for an entity has already been created, it will not over-write or create a new version.\nFile ./myapp/models/ext/extm_interfaces.go contains the generated entity model extension-point interface declarations. Each interface and interface method is documented in this file.\nFile ./myapp/controllers/m_ext.go is generated for each entity with empty extension-point interface implementations. This file may be edited by the application developer to add custom application logic.\nModel Extension-Point Interfaces  Interface ModelCreateExt   BeforeDB(ent interface{}) error BeforeDB is a model extension-point that can be implemented in order to examine and potentially make changes to the values in the entity structure immediately before the insertion request is made to the ORM. This extension-point is the first code executed in the model's Create method. Authentication and Authorization checks should be performed upstream in the route middleware-layer and detailed checks of an entity's data should be carried out in the validator-layer.    AfterDB(ent interface{}) error CreateAfterDB is a model extension-point that can be implemented in order to examine and potentially make changes to the values in the entity structure immediately following the return of the ORM insertion request. This extension-point is the last code executed in the model's Create method. As the insertion will have already occurred at this point, care should be taken when deciding whether to issue an error in this extension-point. Augmentation of the of the Create result may be carried out in this method in order to calculate non-persistent entity values for example.     Interface ModelUpdateExt   BeforeDB(ent interface{}) error BeforeDB is a model extension-point that can be implemented in order to examine and potentially make changes to the values in the entity structure immediately before the update request is made to the ORM. This extension-point is the first code executed in the model's Update method. Authentication and Authorization checks should be performed upstream in the route middleware-layer and detailed checks and normalization of the entity's data should be carried out in the validator-layer.    AfterDB(ent interface{}) error AfterDB is a model extension-point that can be implemented in order to examine and potentially make changes to the values in the entity structure immediately following the return of the ORM update request. This extension-point is the last code executed in the model's Update method. As the update will have already occurred at this point, care should be taken when deciding whether to issue an error in this extension-point. Augmentation of the of the Update result may be carried out in this method in order to calculate non-persistent entity values for example.     Interface ModelGetExt   BeforeDB(ent interface{}) error BeforeDB is a model extension-point that can be implemented in order to examine and potentially make changes to the values in the entity structure immediately before the read-entity request is made to the ORM. This extension-point is the first code executed in the model's Get method. Authentication and Authorization checks should be performed upstream in the route middleware-layer and detailed checks of an entity's data should be carried out in the validator-layer.    AfterDB(ent interface{}) error AfterDB is a model extension-point that can be implemented in order to examine and potentially make changes to the values in the entity structure immediately following the return of the ORM read-entity request. This extension-point is the last code executed in the model's Get method. As the read will have already occurred at this point, care should be taken when deciding whether to issue an error in this extension-point. Augmentation of the of the Get result may be carried out in this method in order to calculate non-persistent entity values for example. Note that the AfterDB(ent interface{}) method is called after the single and set Get CRUD operations for an entity.    "
},
{
	"uri": "https://1414c.github.io/jiffy/generation/gn-content-c/",
	"title": "Generated &#39;appobj&#39; Folder",
	"tags": [],
	"description": "",
	"content": " The \u0026lsquo;appobj\u0026rsquo; Folder  The appobj folder contains the generated application\u0026rsquo;s configuration loader and the main application object. \nFirstApp ├── appobj │ ├── appconf.go │ └── appobj.go ├── controllers │ ├── ... │ ├── ... . . . ├── .dev.config.json ├── .prd.config.json ├── main_test.go └── main.go  appobj.go The entry point for go applications is always the main() function, but we seldom write the so-called \u0026lsquo;main\u0026rsquo; part of the application in this monolithic function. To that end, an AppObj struct is declared and the main thread of the application runs against it. The content of main.go simply creates an instance of an AppObj struct, parses the flags and then calls the AppObj.Run() method.\nWhen the generated application is started, AppObj.Run() is responsible for:\n loading the specified configuration file creating the runtime services performing auto-migration of database artifacts initializing (loading) the keys for JWT/ECDSA support instantiating controllers initializing routes starting the mux reading the group-leader information from the group persistent store joining (or creating) the group starting the inter-process group-membership failure detector  The creation of the runtime services bears closer inspection before moving on. Generated applications contain an internal \u0026lsquo;service\u0026rsquo; for each entity declared in the source model files. The AppObj is responsible for the instantiation of these services when the application is started via the AppObj.createServices() method.\nA Services object containing each of the entity runtime services is created on the one-and-only instance of the AppObj. A runtime service is first created to support access to the backend DBMS via the sqac ORM, then a service is started for each entity. Entity services contain a reference to the ORM access handle, as well as an instance of the entity\u0026rsquo;s validator class which is contained in the model-layer.\nappconf.go The code in appconf.go contains the functions used to load application configuration files, as well as functions containing so-called \u0026lsquo;default\u0026rsquo; configuration. It is possible to edit the DefaultConfig() function so that it holds values specific to the local test/development environment. This prevents the need for maintaining a set of configuration files that the development staff need to keep in sync.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/models/mo-content-c/",
	"title": "Model with Composite Index",
	"tags": [],
	"description": "",
	"content": " Two Entity Model with Composite Index The following JSON illustrates the addition of a composite-index to an entity definition. An index composed of the \u0026lsquo;name\u0026rsquo; and \u0026lsquo;province\u0026rsquo; fields has been declared in the \u0026lsquo;Owner\u0026rsquo; entity. This declaration will result in the creation of a non-unique btree index for columns \u0026lsquo;name\u0026rsquo; and \u0026lsquo;province\u0026rsquo; in the database. Any number of composite indices may be declared for an entity. No relationships have been defined between the two entities; this example simply illustrates how to declare a composite-index for an entity.\n{ \u0026quot;entities\u0026quot;: [ { \u0026quot;typeName\u0026quot;: \u0026quot;Owner\u0026quot;, \u0026quot;properties\u0026quot;: { \u0026quot;Name\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: false, \u0026quot;unique\u0026quot;: false, \u0026quot;index\u0026quot;: \u0026quot;nonUnique\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,like\u0026quot; }, \u0026quot;LicenseNumber\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;uint\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: false, \u0026quot;unique\u0026quot;: true, \u0026quot;index\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,lt,gt\u0026quot; }, \u0026quot;Province\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: false, \u0026quot;unique\u0026quot;: false, \u0026quot;index\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,lt,gt\u0026quot; } }, \u0026quot;ext_points\u0026quot;: { \u0026quot;gen_controller\u0026quot;: true, \u0026quot;gen_model\u0026quot;: true }, \u0026quot;compositeIndexes\u0026quot;: [ {\u0026quot;index\u0026quot;: \u0026quot;name, province\u0026quot;} ] }, { \u0026quot;typeName\u0026quot;: \u0026quot;Car\u0026quot;, \u0026quot;properties\u0026quot;: { \u0026quot;Model\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: true, \u0026quot;index\u0026quot;: \u0026quot;nonUnique\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,like\u0026quot; }, \u0026quot;Make\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: true, \u0026quot;index\u0026quot;: \u0026quot;nonUnique\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,like\u0026quot; } }, \u0026quot;ext_points\u0026quot;: { \u0026quot;gen_controller\u0026quot;: true, \u0026quot;gen_model\u0026quot;: true } } ] }  The sample model file can be downloaded from the following location: twoEntityWithCompositeIndex.json.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/accesscontrol/ac-content-c/",
	"title": "Access Revocation and Renewal",
	"tags": [],
	"description": "",
	"content": " JWT Tokens and Access Revocation Jiffy applications do not direct support the revocation or automatic renewal of JWT tokens. Instead, a cross-process cache of User information is maintained via a group-membership service. The service ensures that changes to User information (create/update/delete) are disseminated to all running instances of the Jiffy generated application. Consequently, in Jiffy-based applications it makes sense to discuss User access revocation from the perspective of an administrator making a call to the user-API to perform general User deletion or deactivation. Such changes are affected in the backend database, and then updated in the application server caches by way of the web-sockets-based group-membership service.\nUser Access Revocation Example Conditions\n User \u0026lsquo;tester@test.com\u0026rsquo; has access to a number of services in a Jiffy-generated application. We now wish to remove access from this user. JWT lifetime in our test system is set to 12 hours. tester@test.com has a current and valid JWT that will expire in 8 hours.  Revocation Steps\n A user with administrative privileges in the Jiffy-generated application makes a call to the Usr service of the Jiffy-generated application to deactivate the \u0026lsquo;tester@test.com\u0026rsquo; account. This call can be made to any running instance of the application. Once the Usr record has been updated in the backend the id in question will not be able to login to the application. On confirmation of the successful update to the Usr record, the Usr controller will disseminate the new status of the Usr record to the other group-members. Each group-member will update their Usr cache with the new information.  Revocation Results\n If the user attempts to login to any of the application instances, the middleware will see that the Usr has been deactivated when it checks the Usr cache and the login will be rejected. If the user has a valid JWT, but has their access revoked as described in the previous steps, all attempts to access application services will be denied.\n The JWT remains valid. The JWT contains the user\u0026rsquo;s ID. The route middleware examines the JWT Claims for every call made to the application services. The UID claim in the JWT is used by the middleware to read the Usr cache. In this example, the middleware cache will indicate that the user is no longer active. This approach allows us to focus on the maintenance and buffering of the persistent object (Usr) rather than trying to maintain/cache the transient JWT.   JWT Token Expiration JWT\u0026rsquo;s contain a standard set of registered claims as outlined in RFC7519 https://tools.ietf.org/html/rfc7519#section-4.1. Login to a jiffy generated application results in the creation of a new JWT where the standard \u0026lsquo;exp\u0026rsquo; claim is set based on the value of the \u0026lsquo;jwt_lifetime\u0026rsquo; key in the application\u0026rsquo;s configuration file. When the current (server) date-time exceeds the value contained in a JWT\u0026rsquo;s \u0026lsquo;exp\u0026rsquo; claim, the token is no longer accepted by the application. After JWT expiration, the used is forced to login again.\nJWT Token Renewal It would be possible to alter the Jiffy application to create self-renewing JWT\u0026rsquo;s. Doing so would mandate that the client developer compare the Authorization field in the response header to the one that was sent in the request. For now, the strategy is to have the application configuration set a JWT validity of ~12 hours, and then force the user to login again once the time limit expires.\nOn one hand, this approach to (not supporting) JWT renewal means that the client/consumer of the RESTful services need not worry about checking the JWT content at the end of each exchange. On the other hand, the current strategy may be a concern in system-to-system interfaces especially where it is not acceptable to set a very long JWT expiry limit in the configuration.\nUsing External Identity Providers It is possible to use an external Identity Provider to supply JWT tokens capable of accessing jiffy-applications. In order for an external IDP to provide usable JWT\u0026rsquo;s to jiffy the following criteria have to be met:\n The IDP must sign the JWT\u0026rsquo;s with an algorithm that jiffy supports The IDP must provide the jiffy application with a public-key for signature verification A valid user-id must exist in the jiffy application The IDP must contain a mapping of user IDP ID\u0026rsquo;s to jiffy-application internal user id\u0026rsquo;s The IDP must contain a record of the Authorization-Groups that the user should have access to The IDP must include the jiffy-specific claims in the JWT payload The IDP must supply the \u0026lsquo;alg\u0026rsquo; and \u0026lsquo;typ\u0026rsquo; elements in the JWT header  Sample JWT for Jiffy Application Access  A user with an existing jiffy-application userID has been configured in an external IDP.\n The user\u0026rsquo;s internal jiffy-application ID is 12, and the user has been granted access to end-points encompassed by Authorization-Groups \u0026lsquo;GroupA\u0026rsquo; and \u0026lsquo;GroupC\u0026rsquo;.\n The IDP is signing JWT\u0026rsquo;s with ECDSA-SHA384.  The user logs into the IDP, then attempts to access a jiffy-application resource through some means by which a jiffy-compliant JWT generated by the IDP is included in the http request-header \u0026lsquo;Authorization\u0026rsquo; field:\nBase64 Encoded JWT in the Authorization (compliments of jwt.io) \n\nDecoded JWT Header (Red Section) { \u0026quot;alg\u0026quot;: \u0026quot;ES384\u0026quot;, \u0026quot;typ\u0026quot;: \u0026quot;JWT\u0026quot; }  \nDecoded JWT Payload (Purple Section) { \u0026quot;Groups\u0026quot;: \u0026quot;GroupA; GroupC\u0026quot;, \u0026quot;email\u0026quot;: \u0026quot;billthecat@1414c.io\u0026quot;, \u0026quot;exp\u0026quot;: 1528500904, \u0026quot;iat\u0026quot;: 1528493704, \u0026quot;id\u0026quot;: 12, \u0026quot;uid\u0026quot;: 12 }  When this JWT is included in the http header of a jiffy-application request, the jiffy-application will decode the JWT header to determine the algorithm used to sign the token. Next, the application will use the appropriate public-key to verify the JWT\u0026rdquo;s signature (blue section). If the application is not able to verify the signature, the request will be rejected.\nOnce the JWT integrity has been verified, the middleware performs the following checks before allowing the request to proceed to the entity controller method:\n Verify that the JWT has not expired by examining the unix epoch timestamp in \u0026lsquo;exp\u0026rsquo; claim. If the system time exceeds the value contained in the \u0026lsquo;exp\u0026rsquo; claim, the request will be rejected.\n Ensure that the user-id contained in the custom \u0026lsquo;uid\u0026rsquo; claim is valid by performing a lookup in the application server cache. If the user is not valid, or is not found in the cache the request is rejected. Each authorization-group in the custom \u0026lsquo;Groups\u0026rsquo; claim is then checked to see if it contains authorization for the requested end-point. The middleware performs this check by examining the cached values of the Group-Authorizations for each Group in the \u0026lsquo;Groups\u0026rsquo; claim.\n  "
},
{
	"uri": "https://1414c.github.io/jiffy/usage/us-content-c/",
	"title": "Development Configuration",
	"tags": [],
	"description": "",
	"content": " Development Config The following command string may be used to run the program using the values defined in the ./.dev.config.json file.\n$ go run main.go -dev  The generated sample dev configuration file should be edited to match the local environment. Jiffy will generate a sample .dev.config.json file similar to the one shown below:\n{ \u0026quot;external_address\u0026quot;: \u0026quot;127.0.0.1:3000\u0026quot;, \u0026quot;internal_address\u0026quot;: \u0026quot;127.0.0.1:4444\u0026quot;, \u0026quot;env\u0026quot;: \u0026quot;dev\u0026quot;, \u0026quot;ping_cycle\u0026quot;: 1, \u0026quot;failure_threshold\u0026quot;: 5, \u0026quot;pepper\u0026quot;: \u0026quot;secret-pepper-key\u0026quot;, \u0026quot;hmac_Key\u0026quot;: \u0026quot;secret-hmac-key\u0026quot;, \u0026quot;database\u0026quot;: { \u0026quot;db_dialect\u0026quot;: \u0026quot;postgres\u0026quot;, \u0026quot;host\u0026quot;: \u0026quot;localhost\u0026quot;, \u0026quot;port\u0026quot;: 5432, \u0026quot;user\u0026quot;: \u0026quot;godev\u0026quot;, \u0026quot;password\u0026quot;: \u0026quot;gogogo123\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;glrestgen\u0026quot; }, \u0026quot;cert_file\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;key_file\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;rsa256_priv_key_file\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;rsa256_pub_key_file\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;rsa384_priv_key_file\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;rsa384_pub_key_file\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;rsa512_priv_key_file\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;rsa512_pub_key_file\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;ecdsa256_priv_key_file\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;ecdsa256_pub_key_file\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;ecdsa384_priv_key_file\u0026quot;: \u0026quot;jwtkeys/ecdsa384/ec384.priv.pem\u0026quot;, \u0026quot;ecdsa384_pub_key_file\u0026quot;: \u0026quot;jwtkeys/ecdsa384/ec384.pub.pem\u0026quot;, \u0026quot;ecdsa521_priv_key_file\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;ecdsa521_pub_key_file\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;jwt_sign_method\u0026quot;: \u0026quot;ES384\u0026quot;, \u0026quot;jwt_lifetime\u0026quot;: 120, \u0026quot;service_activations\u0026quot;: [ { \u0026quot;service_name\u0026quot;: \u0026quot;Library\u0026quot;, \u0026quot;service_active\u0026quot;: true }, { \u0026quot;service_name\u0026quot;: \u0026quot;Book\u0026quot;, \u0026quot;service_active\u0026quot;: true } ] }  "
},
{
	"uri": "https://1414c.github.io/jiffy/interprocess/ip-content-c/",
	"title": "Process Startup / Join",
	"tags": [],
	"description": "",
	"content": " Process Startup When an application instance (process) starts, the group-membership subsystem is started as a go-routine within the application.\nMember Communication The group-membership service communicates between processes via web-sockets connections. Each process accepts group-membership messages on the address:port specified by the \u0026lsquo;internal_address\u0026rsquo; key in the application configuration file. This port is not secured, and the group-membership messages are not encrypted in any way. It is advisable that the address:port used here is not accessible to the outside world.\nDue to the round-robin every-process-pings-every-other-process model used by the failure detector, the group-membership service can be rather busy. Group Leadership Overview Election Overview In order to participate in a group, each starting process needs to know who the current group-leader is. Group-leadership is determined internally via the failure-detector and a bully-type leader-election. Each process knows who the current group-leader is at any given time. If a failure of the group-leader is detected, an election is held whereby the process with the highest process-id (PID) assumes leadership of the group.\nAssertion of leadership is disseminated to all group-members by the new leader via the COORDINATOR message. This takes care of the current group-members, but processes wishing to join the group must have a way to determine who the current group-leader is.\nJoining Overview Joining processes must access a well-known persistent store that holds the current group-leader information. This means that each joining process must know the location of and the manner in which the persistent store can be queried. The persistent store exists outside of the group-membership and is typically some sort of name-value key-store like redis or memcached.\nTo this end, a general interface is provided by Jiffy to allow the implementing developer to access the persistent store of their choice. The rationale here is that many implementers will have a preference in terms of the key-value store they use, and may already have a suitable KVS in their productive landscape. The interface provided by Jiffy for this purpose is gmcom.GMLeaderSetterGetter and it must be implemented in the application\u0026rsquo;s main.go file and passed into the AppObj.Run() method during application startup. \nInterface gmcom.GMGetterSetter Interface gmcom.GMGetterSetter contains methods to facilitate read/write access to the one-and-only persisted leader record in any key-value-store. Applications implementing the interface may choose to store the persisted current leader in a number of mediums; flat-file, db table record, redis, memcached etc.\n Interface gmcom.GMGetterSetter  \nGetDBLeader() (*GMLeader, error) GetDBLeader is provided in order to allow the implementer to retrieve the current group-leader information from the persistent store. The implementation of this method is intended to be self-contained. For example, if the implementation calls for the current leader information to be persisted in redis, the implementer should code a self-contained method to connect to redis, retrieve the leader information and return it in the GMLeader pointer. Failure to read a current leader from the persistent store should result in the return of a nil in place of the *GMLeader pointer and a non-nil error value.    SetDBLeader(l GMLeader) error SetDBLeader is provided in order to allow the implementer to persist a newly elected leader\u0026rsquo;s information in the persistent store. The implementation of this method is intended to be self-contained. For example, if the implementation calls for the current leader information to be persisted in redis, the implementer should code a self-contained method to connect to redis and store the leader information provided by input parameter l. Failure to persist the provided leader information should result in the implementer returning a non-nil value in the error return parameter.    Interface gmcom.GMSetterGetter Sample Implementation // LeadSetGet provides a sample implementation of the GMLeaderSetterGetter // interface in order to support persistence of the current group-leader // information. re-implement these methods as you see fit to facilitate // storage and retrieval of the leader information to and from the persistent // storage. This example uses a quick and dirty web-socket-based cache to // handle the persistence. It works well enough for testing, but you should // use something more robust like a database, redis etc. The methods in the // GMLeaderSetterGetter interface are called when a new process is attempting // to join the group and also when a new leader is selected via the coordinator // process. // // To test with the delivered interface implementation, install and run sluggo: // go get -u github.com/1414C/sluggo // // Execute sluggo from the command-line as follows: // go run main.go -a \u0026lt;ipaddress:port\u0026gt; // For example: // $ go run main.go -a 192.168.1.40:7070 // type LeadSetGet struct { gmcom.GMLeaderSetterGetter } // GetDBLeader retrieves the current leader information from // the persistence layer. func (sg *LeadSetGet) GetDBLeader() (*gmcom.GMLeader, error) { // access the database here to read the current leader l := \u0026amp;gmcom.GMLeader{} wscl.GetCacheEntry(\u0026quot;LEADER\u0026quot;, l, \u0026quot;192.168.1.40:7070\u0026quot;) return l, nil } // SetDBLeader stores the current leader information in the // persistence layer. func (sg *LeadSetGet) SetDBLeader(l gmcom.GMLeader) error { // access the database here to set a new current leader wscl.AddUpdCacheEntry(\u0026quot;LEADER\u0026quot;, \u0026amp;l, \u0026quot;192.168.1.40:7070\u0026quot;) return nil }  Startup \u0026amp; Group Leader Identification When the application starts in group-membership mode, the process must determine who the group-leader is as described in the preceding sections. The process tries to join an existing group four times before giving up, and within each join attempt the process tries to read the current leader PID from the persistent store three times.\nGroup Leader Identification When the starting process is able to read the PID and IP Address:port of the current group-leader from the persistent store, it proceeds to the next step where an attempt to contact the leader is made.\nIf the starting process is unable to read the leader information from the persistent store, the process waits for a randomized period of between 1 and 1000 ms. Once the wait is over, the process tries to read the current leader from the persistent store again. This loop will be repeated up to four times before the process gives up and attempts to assume the role of group-leader itself.\nA distinction is not currently made between being unable to contact the persistent store and not finding a current leader after reading the persistent store.\nGroup Leader is Found Once a starting process has obtained a set of group-leader information from the persistent store that looks valid, it uses the information to send a Join message to the group-leader. There are a few possible outcomes to the sending of the Join message:\n The group-leader accepts the Join message. When the group-leader accepts the Join message from the starting process it checks for problems as outlined below. If all goes well, the group-leader will return an Ack message containing a PID for use by the starting process. At this point, the starting process will initialize it\u0026rsquo;s failure detector loop and start participating in the group.\n The group-leader could not be contacted. In this case, the starting process waits for a randomized period of time between 1 and 1000ms, then loops back to read the group-leader information from the persistent store again in hope that it has been updated. This can occur up to four times, after which the starting process will attempt to become the group-leader.\n The group-leader information read from the persistent store was not correct. It is possible that the leader information in the persistent store is stale during a cold-startup. In this case, although a process was reachable at the group-leader\u0026rsquo;s ip-address:port, the so-called group-leader process was not in fact the leader. The starting process will wait for a randomized period of time between 1 and 1000ms, then loop back to read the group-leader information from the persistent store again in hope that it has been updated. This can occur up to four times, after which the starting process will report an error and gracefully exit.\n A group-leader was found but has the current PID\u0026rsquo;s ip-address. It is possible that the starting PID\u0026rsquo;s address matches that of the group-leader that was read from the persistent store. This can happen in scenarios where the group-leader is the last process standing and then terminates without warning.\nThe persistent store retains the last group-leader information (Pi) resulting in a successful leader-ping if the first process to restart in the group happens to hold the same ip-address as that of the old group-leader. A successful ping (Pi-\u0026gt;Pi) looks like there is a functioning group-leader.\nIf the joining process sees it\u0026rsquo;s own ip-address in the group-leader slot within the persistent store, it is best to act like there is no current group-leader and wipe the read (leader) information clean. This will repeat four times as described above, then the current PID will attempt to assert itself as group-leader. The randomized time is used to offset potentially simultaneous multiple group-leadership assertions in mass cold-start situations.\nIt is important to remember/know that a starting process does not start participating in the group failure-detector until it has either joined an existing group, or has become the leader thereby starting a new group.\n The leader reports that the ip-address:port of the starting process is already in use within the group.\nThis can occur due to a misconfigured failure threshold value (too high), or when a process is killed and restarted immediately. In this case, the starting process waits 5 seconds and then loops back to read the group-leader information and make another attempt to join the group. This can occur up to four times, after which the starting process will report an error and gracefully exit.\n An unknown error occurs. This is a catch-all for failed join attempts. In this case, the starting process waits 5 seconds and then loops back to read the group-leader information and make another attempt to join the group. This can occur up to four times, after which the starting process will report an error and gracefully exit.\n  A group-leader is not found If a valid group-leader has not been found after four attempts, the starting process attempts to become the group-leader. The starting process will:\n Set it\u0026rsquo;s PID to 1. Add itself to the local process member map. Call gm.SendSetDBLeader to set itself as group-leader in the persistent store. Start it\u0026rsquo;s failure-detector loop in a go-routine.  "
},
{
	"uri": "https://1414c.github.io/jiffy/overview/ov-content-d/",
	"title": "Jiffy Application Architecture",
	"tags": [],
	"description": "",
	"content": " Jiffy Application Architecture Jiffy approaches the API from a services perspective. Each entity has a corresponding service that can be started when the application initializes. The Usr, UsrGroup, Auth and GroupAuth services are always generated by default when creating a Jiffy application. Additional services are generated based on the content of your project\u0026rsquo;s model files.\nGenerated application services can be broken down into five high-level areas: \ngraph TD; subgraph A(End-Points)--B(Middleware) B--C(Controllers) C--D(Models) D--E(Database) end  \n End-Points expose the service APIs to the consumer, such as a web-app or another server. End-points may be customized by way of the application model files. Middleware provides user authentication / authorization services and is tightly-coupled to the end-point definitions. The middleware offers comprehensive services such as authorization via JWT claim inspection, as well as some caching of user and group authorization details. This is an area of active development. Controllers are the entry point into the application proper, and are called after a request has been granted access to the end-point by the middleware. It is here that the body of the request is unmarshalled and mapped into the correct go model structure. Extension-points conforming to standard Jiffy interfaces are provided in the controllers for post-generation enhancements. Models are where the entity data from the request is checked, normalized and prepared for submission to the database. Extension-points conforming to standard Jiffy interfaces are provided in the models for post-generation enhancements. Database refers to the backend DBMS that is used to house the entity data. Jiffy generated applications can connect to PostgreSQL, MariaDB/MySQL, MSSQL, SAP HanaDB or SQLite. It is easy to extend the database support to other relational platforms provided that there is an existing go sql driver for the database in question. It is possible to override the generated Jiffy call to the database and \u0026lsquo;roll-your-own\u0026rsquo; should the need arise.  "
},
{
	"uri": "https://1414c.github.io/jiffy/generation/gn-content-d/",
	"title": "Generated &#39;controllers&#39; Folder",
	"tags": [],
	"description": "",
	"content": " The \u0026lsquo;controllers\u0026rsquo; Folder FirstApp ├── appobj │ ├── appconf.go │ └── appobj.go ├── controllers │ ├── authc.go │ ├── controllerfuncs.go │ ├── groupauthc.go │ ├── person_relationsc.go │ ├── personc.go │ ├── usrc.go │ ├── usr_groupc.go │ └── ext │ ├── extc_interfaces.go │ └── personc_ext.go ├── group │ ├── ... │ │ ├── ... . . . . . ├── .dev.config.json ├── .prd.config.json ├── main_test.go └── main.go  A controller is created for each entity that has been declared in the model files, as well as a number of static controllers that are used to handle the application\u0026rsquo;s users and authorization objects.\nControllers act as a bridge between an entity\u0026rsquo;s routes and its model layer. Each entity mux route is assigned a method in their respective controller based on the intent of that route. For example, to create a new new \u0026lsquo;Library\u0026rsquo; entity the following POST could be made:\nhttps://servername:port/library {JSON body} + POST  The route for this call is defined in appobj.go as follows, where \u0026lsquo;a\u0026rsquo; is the one-and-only instance of the AppObj:\na.router.HandleFunc(\u0026quot;/library\u0026quot;, requireUserMw.ApplyFn(a.libraryC.Create)).Methods(\u0026quot;POST\u0026quot;)  The \u0026lsquo;/library\u0026rsquo;-POST route is assigned a HandleFunc belonging to the instance of the LibraryController that has been created on the appobj. Controller method a.libraryC.Create is called for the \u0026lsquo;library\u0026rsquo; route when the http method equals \u0026lsquo;POST\u0026rsquo;. The route contains some additional code related to authentication and authorization of the requester but this can be ignored for now. The handler function for a mux.route must conform to the standard go http.Handler interface:\ntype Handler interface { ServeHTTP(ResponseWriter, *Request) }  This interface facilitates the passing of the incoming request header and body to the controller method, as well as the passing of the formatted response back to the router. With this out of out the way, let\u0026rsquo;s look at generated Controller method LibraryController.Create:\n// Create facilitates the creation of a new Library. This method is bound // to the gorilla.mux router in main.go. // // POST /library func (lc *LibraryController) Create(w http.ResponseWriter, r *http.Request) { var l models.Library decoder := json.NewDecoder(r.Body) if err := decoder.Decode(\u0026amp;l); err != nil { log.Println(\u0026quot;Library Create:\u0026quot;, err) respondWithError(w, http.StatusBadRequest, \u0026quot;libraryc: Invalid request payload\u0026quot;) return } defer r.Body.Close() // fill the model library := models.Library{ Name: l.Name, City: l.City, } // build a base urlString for the JSON Body self-referencing Href tag urlString := buildHrefStringFromCRUDReq(r, true) // call the Create method on the library model err := lc.ls.Create(\u0026amp;library) if err != nil { log.Println(\u0026quot;Library Create:\u0026quot;, err) respondWithError(w, http.StatusBadRequest, err.Error()) return } library.Href = urlString + strconv.FormatUint(uint64(library.ID), 10) respondWithJSON(w, http.StatusCreated, library) }  The complete Library.Create(http.Handler) controller method is shown exactly as it has been generated.\nEach section of the method is broken down in the following subsets of commented code:\n// declare a local variable of struct type models.Library to hold the decoded // JSON body provided in the request.Body. var l models.Library // create a new JSON decoder passing in the request.Body decoder := json.NewDecoder(r.Body) // call the Decoder.Decode(interface{}) method passing a reference to the locally // declared models.Library struct 'l'. if the decoder is able to decode the JSON // contained in the request.Body, the member fields of 'l' will be populated. if // the decoder fails to parse and map the incoming JSON to the models.Library // struct, it will return an error. The problem will be logged to stdout (for now) // on the server-instance, and a response conforming to the http.Handler interface // will be constructed and passed back to the router. if the JSON was parsed // closed upon exit of the method. if err := decoder.Decode(\u0026amp;l); err != nil { log.Println(\u0026quot;Library Create:\u0026quot;, err) respondWithError(w, http.StatusBadRequest, \u0026quot;libraryc: Invalid request payload\u0026quot;) return } defer r.Body.Close() // fill the model with the parsed content of the JSON body. this step looks // redundant, but can be thought of as a way to separate the incoming data // from the response. going forward from this point, 'l' is ignored and // all data transformation occurs on the 'library' variable. library := models.Library{ Name: l.Name, City: l.City, } // build a base urlString for the JSON Body self-referencing Href tag urlString := buildHrefStringFromCRUDReq(r, true) // call the Create method on the library model. each controller contains an // instance of the Service for it's respective entity. the Create method on // the service is called, passing a reference to the 'library' data structure. // recall that the Service for an entity provides the link to that entity's // model-layer by way of the entity's validator. lc.ls.Create(\u0026amp;library) will // result in a call the model Validator Create() method for the Library // entity, and in-turn, call to the enitity's model.Create() method where // the data will be passed to the ORM-layer. if the Create() call returns // an error, the problem will be logged to stdout (for now) on the server- // instance, and a response conforming to the http.Handler interface will be // constructed and passed back to the router. err := lc.ls.Create(\u0026amp;library) if err != nil { log.Println(\u0026quot;Library Create:\u0026quot;, err) respondWithError(w, http.StatusBadRequest, err.Error()) return } // if the call to the model-layer was successful, it indicates that a new // Library entity was created in the DBMS. the 'library' reference passsed // to the Create() method(s) in the model-layer will now contiain the new // Library's information. first, the ID for the new Library will be added // to the urlString and assigned to the library struct's Href member field. // Href is another injected field in the entity and fullfills the purpose // of providing a direct URI for the returned entity. finally the populated // 'library' struct is formatted as a JSON response and passed back to the // router along with an http status-code indicating success. library.Href = urlString + strconv.FormatUint(uint64(library.ID), 10) respondWithJSON(w, http.StatusCreated, library) }  The controllers folder also contains an \u0026lsquo;ext\u0026rsquo; sub-directory which is used to hold the interface definitions for controller extension-points as well as the associated empty implementation for each entity. See the Controller Extension Points section of this document for more details.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/models/mo-content-d/",
	"title": "Entity Relations",
	"tags": [],
	"description": "",
	"content": " Modeling Entity Relationships Relationships between entities can be declared in the application model file via the addition of a \u0026lsquo;relations\u0026rsquo; block inside an entity\u0026rsquo;s declaration. Relationships are based on resource id\u0026rsquo;s by default, although it is possible to specify non-default key fields in the configuration, or implement complex joins directly by maintaining the entity\u0026rsquo;s controller and model. \u0026lsquo;relations\u0026rsquo; blocks look as follows:\n\u0026quot;relations\u0026quot;: [ { \u0026quot;relName\u0026quot;: \u0026quot;ToOwner\u0026quot;, \u0026quot;properties\u0026quot;: { \u0026quot;relType\u0026quot;: \u0026quot;hasOne\u0026quot;, \u0026quot;toEntity\u0026quot;: \u0026quot;Owner\u0026quot; } } ]  The sample relations block illustrates the declaration of a \u0026lsquo;hasOne\u0026rsquo; relationship between \u0026lsquo;Car\u0026rsquo; and \u0026lsquo;Owner\u0026rsquo; making use of default-keys.\nhasOne Relationship \u0026lsquo;hasOne\u0026rsquo; relationships establish a one-to-one relationship between two modeled entities. As an example, let\u0026rsquo;s posit that a car can have one owner. If the car and owner were modeled as entities, we could declare a \u0026lsquo;hasOne\u0026rsquo; (1:1) relationship between them. The relation would be added to the \u0026lsquo;relations\u0026rsquo; block inside the \u0026lsquo;Car\u0026rsquo; entity definition (as shown above).\nA break-down of the relations block fields is as follows:\n{ \u0026quot;relations\u0026quot;: [ The 'entities' block contains an array of relations belonging to the containing entity definition. Each relation is defined from the perspective of the containing entity having a relationship of the specified type (in this case hasOne), with the entity referenced in the declaration. A 'Car' has one 'Owner' - in our example at least. { \u0026quot;relName\u0026quot;: \u0026quot;Owner\u0026quot; Field 'relName' refers to the name the relationship will be known by inside the application and in the mux route end-point definition. It must be capitalized and written in CamelCase. Any name may be chosen for this field, but keep in mind the name will be exposed to the service consumer via the URI, so something respecting the relationship enities and cardinality is best. For the example, we have chosen a relName of 'ToOwner' to demonstrate the difference between the toEntity and relName fields. 'relName' is a mandatory field in a relations declaration. \u0026quot;properties\u0026quot;: { The 'properties' block contains the details of the relationship. \u0026quot;relType\u0026quot;: Field 'relType' is used to indicate what sort of relationship is being declared between the containing (from) entity and the toEntity. Valid values are {hasOne, hasMany and belongsTo}. This is a mandatory field. \u0026quot;toEntity\u0026quot;: Field 'toEntity' is used to specify the target entity in the relationship. The toEnity must be capitalized and provided in CamelCase that matches that used in the toEntity's declaration. The toEntity need not appear prior to the containing entity in the model file or files. This is a mandatory field. } } ] }  { \u0026quot;entities\u0026quot;: [ { \u0026quot;typeName\u0026quot;: \u0026quot;Owner\u0026quot;, \u0026quot;properties\u0026quot;: { \u0026quot;Name\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: false, \u0026quot;unique\u0026quot;: false, \u0026quot;index\u0026quot;: \u0026quot;nonUnique\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,like\u0026quot; }, \u0026quot;RegistrationNumber\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;uint\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: false, \u0026quot;unique\u0026quot;: true, \u0026quot;index\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,lt,gt\u0026quot; }, \u0026quot;City\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: false, \u0026quot;unique\u0026quot;: false, \u0026quot;index\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,lt,gt\u0026quot; } }, \u0026quot;compositeIndexes\u0026quot;: [ {\u0026quot;index\u0026quot;: \u0026quot;name, city\u0026quot;} ], \u0026quot;relations\u0026quot;: [ { \u0026quot;relName\u0026quot;: \u0026quot;ToCar\u0026quot;, \u0026quot;properties\u0026quot;: { \u0026quot;relType\u0026quot;: \u0026quot;hasOne\u0026quot;, \u0026quot;toEntity\u0026quot;: \u0026quot;Car\u0026quot; } } ], \u0026quot;ext_points\u0026quot;: { \u0026quot;gen_controller\u0026quot;: true, \u0026quot;gen_model\u0026quot;: true } }, { \u0026quot;typeName\u0026quot;: \u0026quot;Car\u0026quot;, \u0026quot;properties\u0026quot;: { \u0026quot;Model\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: true, \u0026quot;index\u0026quot;: \u0026quot;nonUnique\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,like\u0026quot; }, \u0026quot;Make\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: true, \u0026quot;index\u0026quot;: \u0026quot;nonUnique\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,like\u0026quot; }, \u0026quot;OwnerID\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;uint64\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: false, \u0026quot;unique\u0026quot;: false, \u0026quot;index\u0026quot;: \u0026quot;nonUnique\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,lt,gt\u0026quot; } }, \u0026quot;ext_points\u0026quot;: { \u0026quot;gen_controller\u0026quot;: true, \u0026quot;gen_model\u0026quot;: true } } ] }  The sample model file can be downloaded from the following location: hasOne.json.\nhasMany Relationship \u0026lsquo;hasMany\u0026rsquo; relationships establish a one-to-many relationship between two modeled entities. As an example, let\u0026rsquo;s posit that a library can have many books. If library and book were modeled as entities, we could declare a \u0026lsquo;hasMany\u0026rsquo; (1:N) relationship between them. The relation would be added to the \u0026lsquo;relations\u0026rsquo; block inside the \u0026lsquo;Library\u0026rsquo; entity definition:\n{ \u0026quot;entities\u0026quot;: [ { \u0026quot;typeName\u0026quot;: \u0026quot;Library\u0026quot;, \u0026quot;properties\u0026quot;: { \u0026quot;Name\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: true, \u0026quot;unique\u0026quot;: false, \u0026quot;index\u0026quot;: \u0026quot;nonUnique\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,like\u0026quot; }, \u0026quot;City\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: true, \u0026quot;unique\u0026quot;: false, \u0026quot;index\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,lt,gt\u0026quot; } }, \u0026quot;ext_points\u0026quot;: { \u0026quot;gen_controller\u0026quot;: true, \u0026quot;gen_model\u0026quot;: true }, \u0026quot;compositeIndexes\u0026quot;: [ {\u0026quot;index\u0026quot;: \u0026quot;name, city\u0026quot;} ], \u0026quot;relations\u0026quot;: [ { \u0026quot;relName\u0026quot;: \u0026quot;Books\u0026quot;, \u0026quot;properties\u0026quot;: { \u0026quot;relType\u0026quot;: \u0026quot;hasMany\u0026quot;, \u0026quot;toEntity\u0026quot;: \u0026quot;Book\u0026quot; } } ] }, { \u0026quot;typeName\u0026quot;: \u0026quot;Book\u0026quot;, \u0026quot;properties\u0026quot;: { \u0026quot;Title\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: true, \u0026quot;index\u0026quot;: \u0026quot;nonUnique\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,like\u0026quot; }, \u0026quot;Hardcover\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;bool\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: true, \u0026quot;index\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,ne\u0026quot; }, \u0026quot;Copies\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;uint64\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: true, \u0026quot;index\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,lt,gt\u0026quot; }, \u0026quot;LibraryID\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;uint64\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: true, \u0026quot;index\u0026quot;: \u0026quot;nonUnique\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,like\u0026quot; } }, \u0026quot;ext_points\u0026quot;: { \u0026quot;gen_controller\u0026quot;: true, \u0026quot;gen_model\u0026quot;: true } } ] }  The sample model file can be downloaded from the following location: hasManyDefaultKeys.json.\nbelongsTo Relationship \u0026lsquo;belongsTo\u0026rsquo; relationships are used to form the inverse of the \u0026lsquo;hasOne\u0026rsquo; and \u0026lsquo;hasMany\u0026rsquo; relations. Consider the library \u0026lsquo;hasMany\u0026rsquo; books example; A library has many books, but we can also posit that \u0026lsquo;a book belongs to a library\u0026rsquo;; this is an example of a \u0026lsquo;belongsTo\u0026rsquo; relationship. The JSON below extends the \u0026lsquo;Library\u0026rsquo; -\u0026gt; \u0026lsquo;Book\u0026rsquo; example by adding the \u0026lsquo;belongsTo\u0026rsquo; relationship to the \u0026lsquo;Book\u0026rsquo; entity definition:\n{ \u0026quot;entities\u0026quot;: [ { \u0026quot;typeName\u0026quot;: \u0026quot;PetOwner\u0026quot;, \u0026quot;properties\u0026quot;: { \u0026quot;Name\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: false, \u0026quot;unique\u0026quot;: false, \u0026quot;index\u0026quot;: \u0026quot;nonUnique\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,like\u0026quot; }, \u0026quot;City\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: false, \u0026quot;unique\u0026quot;: false, \u0026quot;index\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,lt,gt\u0026quot; } }, \u0026quot;ext_points\u0026quot;: { \u0026quot;gen_controller\u0026quot;: true, \u0026quot;gen_model\u0026quot;: true }, \u0026quot;compositeIndexes\u0026quot;: [ {\u0026quot;index\u0026quot;: \u0026quot;name, city\u0026quot;} ], \u0026quot;relations\u0026quot;: [ { \u0026quot;relName\u0026quot;: \u0026quot;ToDogs\u0026quot;, \u0026quot;properties\u0026quot;: { \u0026quot;relType\u0026quot;: \u0026quot;hasMany\u0026quot;, \u0026quot;toEntity\u0026quot;: \u0026quot;Dog\u0026quot; } } ] }, { \u0026quot;typeName\u0026quot;: \u0026quot;Dog\u0026quot;, \u0026quot;properties\u0026quot;: { \u0026quot;Name\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: true, \u0026quot;index\u0026quot;: \u0026quot;nonUnique\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,like\u0026quot; }, \u0026quot;Breed\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: true, \u0026quot;index\u0026quot;: \u0026quot;nonUnique\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,like\u0026quot; }, \u0026quot;PetOwnerID\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;uint64\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;required\u0026quot;: true, \u0026quot;index\u0026quot;: \u0026quot;nonUnique\u0026quot;, \u0026quot;selectable\u0026quot;: \u0026quot;eq,like\u0026quot; } }, \u0026quot;ext_points\u0026quot;: { \u0026quot;gen_controller\u0026quot;: true, \u0026quot;gen_model\u0026quot;: true }, \u0026quot;relations\u0026quot;: [ { \u0026quot;relName\u0026quot;: \u0026quot;ToPetOwner\u0026quot;, \u0026quot;properties\u0026quot;: { \u0026quot;relType\u0026quot;: \u0026quot;belongsTo\u0026quot;, \u0026quot;toEntity\u0026quot;: \u0026quot;PetOwner\u0026quot; } } ] } ] }  The sample model file can be downloaded from the following location: hasManyBelongsTo.json.\nBy relying on the default key determinations for the \u0026lsquo;belongsTo\u0026rsquo; relationship, the generator determines that the Book.LibraryID field should be matched against field Library.ID. If alternate keys are desired, they can be specified in the \u0026lsquo;refKey\u0026rsquo; and \u0026lsquo;foreignKey\u0026rsquo; property fields in the \u0026lsquo;belongsTo\u0026rsquo; relation declaration.\nWhat if more complex relationships are required? At the moment the generator only supports \u0026lsquo;hasOne\u0026rsquo;, \u0026lsquo;hasMany\u0026rsquo; and \u0026lsquo;belongsTo\u0026rsquo; relations, as in practice these tend to be the most widely used. The generated code can be extended to accommodate additional relationships and joins if need be. There is a tentative plan to support more complex relations in the generator in the future. Most of the supporting code is in place, but the controller_rel templates would need to be enhanced to support it. In the meantime, a combination of foreign-keys and static filters or hand-coded SQL can be employed as an alternative to formally defined relationships in cases where the entity-id model is not sufficient. See the Custom Join Tutorial for an example of coding a custom-join between two entities.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/usage/us-content-d/",
	"title": "Production Configuration",
	"tags": [],
	"description": "",
	"content": " Production Config The following command string may be used to run the program using the values defined in the ./.prd.config.json file.\n$ go run main.go -prod  The generated sample dev configuration file should be edited to match the local environment. Jiffy will generate a sample .prod.config.json file similar to the one shown below:\n{ \u0026quot;external_address\u0026quot;: \u0026quot;127.0.0.1:8080\u0026quot;, \u0026quot;internal_address\u0026quot;: \u0026quot;127.0.0.1:4444\u0026quot;, \u0026quot;env\u0026quot;: \u0026quot;prod\u0026quot;, \u0026quot;ping_cycle\u0026quot;: 1, \u0026quot;failure_threshold\u0026quot;: 5, \u0026quot;pepper\u0026quot;: \u0026quot;secret-pepper-key\u0026quot;, \u0026quot;hmac_Key\u0026quot;: \u0026quot;secret-hmac-key\u0026quot;, \u0026quot;database\u0026quot;: { \u0026quot;db_dialect\u0026quot;: \u0026quot;postgres\u0026quot;, \u0026quot;host\u0026quot;: \u0026quot;localhost\u0026quot;, \u0026quot;port\u0026quot;: 5432, \u0026quot;user\u0026quot;: \u0026quot;godev\u0026quot;, \u0026quot;password\u0026quot;: \u0026quot;gogogo123\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;glrestgen\u0026quot; }, \u0026quot;cert_file\u0026quot;: \u0026quot;srvcert.cer\u0026quot;, \u0026quot;key_file\u0026quot;: \u0026quot;srvcert.key\u0026quot;, \u0026quot;rsa256_priv_key_file\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;rsa256_pub_key_file\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;rsa384_priv_key_file\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;rsa384_pub_key_file\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;rsa512_priv_key_file\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;rsa512_pub_key_file\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;ecdsa256_priv_key_file\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;ecdsa256_pub_key_file\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;ecdsa384_priv_key_file\u0026quot;: \u0026quot;jwtkeys/ecdsa384/ec384.priv.pem\u0026quot;, \u0026quot;ecdsa384_pub_key_file\u0026quot;: \u0026quot;jwtkeys/ecdsa384/ec384.pub.pem\u0026quot;, \u0026quot;ecdsa521_priv_key_file\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;ecdsa521_pub_key_file\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;jwt_sign_method\u0026quot;: \u0026quot;ES384\u0026quot;, \u0026quot;jwt_lifetime\u0026quot;: 120, \u0026quot;service_activations\u0026quot;: [ { \u0026quot;service_name\u0026quot;: \u0026quot;Library\u0026quot;, \u0026quot;service_active\u0026quot;: true }, { \u0026quot;service_name\u0026quot;: \u0026quot;Book\u0026quot;, \u0026quot;service_active\u0026quot;: true } ] }  "
},
{
	"uri": "https://1414c.github.io/jiffy/accesscontrol/ac-content-d/",
	"title": "Using External Identity Providers",
	"tags": [],
	"description": "",
	"content": " Using External Identity Providers It is possible to use an external Identity Provider to supply JWT tokens capable of accessing jiffy-applications. In order for an external IDP to provide usable JWT\u0026rsquo;s to jiffy the following criteria have to be met:\n The IDP must sign the JWT\u0026rsquo;s with an algorithm that jiffy supports The IDP must provide the jiffy application with a public-key for signature verification A valid user-id must exist in the jiffy application The IDP must contain a mapping of user IDP ID\u0026rsquo;s to jiffy-application internal user id\u0026rsquo;s The IDP must contain a record of the Authorization-Groups that the user should have access to The IDP must include the jiffy-specific claims in the JWT payload The IDP must supply the \u0026lsquo;alg\u0026rsquo; and \u0026lsquo;typ\u0026rsquo; elements in the JWT header  Sample JWT for Jiffy Application Access  A user with an existing jiffy-application userID has been configured in an external IDP.\n The user\u0026rsquo;s internal jiffy-application ID is 12, and the user has been granted access to end-points encompassed by Authorization-Groups \u0026lsquo;GroupA\u0026rsquo; and \u0026lsquo;GroupC\u0026rsquo;.\n The IDP is signing JWT\u0026rsquo;s with ECDSA-SHA384.  The user logs into the IDP, then attempts to access a jiffy-application resource through some means by which a jiffy-compliant JWT generated by the IDP is included in the http request-header \u0026lsquo;Authorization\u0026rsquo; field:\nBase64 Encoded JWT in the Authorization (compliments of jwt.io) \n\nDecoded JWT Header (Red Section) { \u0026quot;alg\u0026quot;: \u0026quot;ES384\u0026quot;, \u0026quot;typ\u0026quot;: \u0026quot;JWT\u0026quot; }  \nDecoded JWT Payload (Purple Section) { \u0026quot;Groups\u0026quot;: \u0026quot;GroupA; GroupC\u0026quot;, \u0026quot;email\u0026quot;: \u0026quot;billthecat@1414c.io\u0026quot;, \u0026quot;exp\u0026quot;: 1528500904, \u0026quot;iat\u0026quot;: 1528493704, \u0026quot;id\u0026quot;: 12, \u0026quot;uid\u0026quot;: 12 }  When this JWT is included in the http header of a jiffy-application request, the jiffy-application will decode the JWT header to determine the algorithm used to sign the token. Next, the application will use the appropriate public-key to verify the JWT\u0026rsquo;s signature (blue section). If the application is not able to verify the signature, the request will be rejected.\nOnce the JWT integrity has been verified, the middleware performs the following checks before allowing the request to proceed to the entity controller method:\n Verify that the JWT has not expired by examining the unix epoch timestamp in the \u0026lsquo;exp\u0026rsquo; claim. If the system time exceeds the value contained in the \u0026lsquo;exp\u0026rsquo; claim, the request will be rejected.\n Ensure that the user-id contained in the custom \u0026lsquo;uid\u0026rsquo; claim is valid by performing a lookup in the application server cache. If the user is not valid, or is not found in the cache the request is rejected. A custom claim is used here rather than the standard \u0026lsquo;id\u0026rsquo; claim, as the \u0026lsquo;id\u0026rsquo; claim may be expected to hold a global ID for the user. Each authorization-group in the custom \u0026lsquo;Groups\u0026rsquo; claim is then checked to see if it contains authorization for the requested end-point. The middleware performs this check by examining the cached values of the Authorizations assigned to each Group in the \u0026lsquo;Groups\u0026rsquo; claim. If a match is found, the user is authorized to proceed and the request is allowed to enter the controller method.  Token Renewal with an External Identity Provider Most renewal schemes employed by an external IDP can be used to renew tokens. The Jiffy application itself is not able to participate in the request for a renewal token, but the consuming application is free to interact with the IDP to renew / acquire a valid JWT when the current token is nearing expiry.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/overview/ov-content-e/",
	"title": "Jiffy Development Steps",
	"tags": [],
	"description": "",
	"content": " Jiffy Pre-Generation Workflow Jiffy is intended to generate a clean, straight-forward and secure application services platform just like the one you would write by hand. Jiffy originally started as a few go templates used to generate boiler-plate code that seemed onerous to type. Generation is a lot nicer than cut-and-paste. There are places in the generated code where things could be more elegant, but the code is intended to be easy to work on even if one is not familiar with it. File and folder names are somewhat subjective; an attempt has been made to be descriptive and organized.\nDesign Steps  You are building a back-end of some sort where you need to reliably read and write data. Before you start building the \u0026lsquo;real\u0026rsquo; Jiffy model of your application, try some of the demo models to get a feel for what Jiffy is and what it isn\u0026rsquo;t. It is a lot easier to design if you know what the platform provides and what it does not.\n Start messing around with entity ideas. What is the best way to represent your data? Transferring your ideas into a few rough diagrams often changes your understanding of what you are modeling.\n Consider the relationships you would like to have between your entities. Does your model still hold up?\n Add some detail to your proposed entities in terms of fields. Remember that Jiffy will insert a primary-key (id), as well as a self-referencing entity href into the model for you. This is important when you are considering relationships, as Jiffy applications have some expectations regarding the name of the referencing field. See the Entity Relations section of this documentation set for details.\n Once you are comfortable with the entities and the fields that they will contain, it is time to create the model in the Jiffy model file format.\n Jiffy model files are simple JSON and at the moment need to be coded up by hand. Taking a copy of one of the sample model-files is the best way to start. Short of creating a graphical model file generator, maintaining the models via direct file maintenance is the most direct and transparent way to edit them. Remember that you do not have to put your entire model in one file. Jiffy is quite happy to accept any number of model files for your project with the entities defined in any order. The generator will sort it all out.\n Check your model files as best as possible before feeding them into Jiffy. If you get an error, don\u0026rsquo;t worry; look at the error message, then check the model-file for problems. If you can\u0026rsquo;t see anything wrong, log an issue along with an example of the model-file that is causing the problem. Usual suspects for errors are missing double-quotes on field-names or string-values, missing closing parentheses on a list, missing brace on struct or sub-struct, putting quotes on a bool value, putting quotes on an int or dec value etc.\n Again, don\u0026rsquo;t worry too much about formal inter-entity rules in the beginning. The idea is to get something up and running quickly so you can try out the services. You can generate your application many times over without touching anything but the model-file / model-files. Generation is fast.\n Generate a version of your application and start it up. Try it out with a tool like Postman. See the Quickstart for an overview of application generation through to application testing, or go to the formal section dealing with each of the application creation steps.\n It is not (typically) necessary to do early development testing via https. If this is not the case for you, see the Testing with TLS section in this document set. Step-by-step instructions are given to create and install self-signed certificates that will permit you to test locally with https.\n As you test your application, you will probably see some fields missing, some fields that you don\u0026rsquo;t care for, and maybe the need for an additional entity. Update your model files and generate the application again. Try it out. Repeat.\n As your model becomes more refined, consider formally adding relationships. Generate, test, repeat.\n Consider foreign-keys. Generate, test, repeat.\n Consider start-values for id. Not everybody is okay to start at 1, particularly if you are planning on migrating existing data into your application. Generate and test.\n Consider static-queries and add the selection options to each field that can be queried. Generate, test, repeat. See the static query section for details.\n Consider indices and add indexes to the model definitions where needed. Generate, test, repeat.\n Access restrictions can be assigned at the end-point-level, and this is built into the generated application. Don\u0026rsquo;t worry about testing authorization and authentication for now.\n  Development  When you are satisfied with your model, generate a version of the application and place it under source-code control.\n Implement extension-points in the controller and model go source as per your requirements. Implemented extension-points will not be over-written should you need to regenerate the application. Test often.\n Implement normalization and validation at the field-level in the generated entity model go source file. This part is slightly contentious, as field normalization and validation is performed directly in the generated code, rather than off to the side in extension-points. We suggest that if you are worried about over-writing your normalization and validation code with an accidental regeneration, you create a model_normalization package for each model and implement field-level normalizations and checks there. Of course, you are free to ignore the provided field-level normalization and validation methods and perform all checks in one of the model extension-points. Its up to you, and it will make more sense once you take a look through one of the generated files.\n When you are happy with the way things are working, think about user access. Sketch out user-groups and assign end-points to them until you have something that you like. Use Postman to create UserGroups and assign Auths to them, then create new users and allocate the relevant UserGroups to their ID. That is all you need to do; the Jiffy middleware will take care of the rest. See the Access Control section for a detailed discussion of how users are authenticated and authorized.\n  Deployment Jiffy generated applications can be deployed in any number of ways. For example:\n On your laptop On a server under your desk On a blade running the os of your choice On a VM (xen etc.) Docker image / Droplet / Cloud Foundry etc. In a Kubernetes cluster Across a collection of the above  At the software level, the Jiffy generated application can be deployed as:\n A single environment hosting the DBMS and application A single application instance talking to a database Multiple application instances talking to a database  Considerations for deployment  SSL certificates Is there a need to support JWT\u0026rsquo;s from JWT-capable Identity Providers in the existing deployment landscape? If so, their public-keys must be added to the production configuration file. JWT expiration policy has been set correctly in the production configuration file? You have tested your user-access revocation? Jiffy makes provisions for the revocation of user-access based on the user master. If a user is deleted or marked as inactive, even a valid JWT for that user will not permit access. Data migration; have you run real test migrations with the key relationships etc. in place? If you disabled certain database features for migration, have you turned them back on again? Looking at you foreign-keys\u0026hellip; User access; users have been assigned to Groups and the create/update/delete end-points have been secured in accordance with the known use-cases? Is a reverse-proxy required and / or is there a need to route traffic based on expected load? Service activations; is there a need to route traffic to specific application instances based on expected load? Is there a documented strategy for scaling horizontally or vertically if required? Backup and recovery strategy is in place and has been tested?  "
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/level-two/",
	"title": "Let&#39;s Test Something",
	"tags": [],
	"description": "",
	"content": "We have a running application, but what can we do with it? Clicking on the http://127.0.0.1:8080 link at the end of the preceding section, did not yield a good looking response\u0026hellip;\nJiffy services are best tested using an API test utility. If you have a tool that works for you, use that to follow along. If you don\u0026rsquo;t have a test utility, Google\u0026rsquo;s Postman is a great choice and that is what we are going to use for the rest of the quick-start.\nLet\u0026rsquo;s make a quick list of things that we are going to do in order to test our new Person service.\n Login Create a new \u0026lsquo;Person\u0026rsquo; entity Create another new \u0026lsquo;Person\u0026rsquo; entity Read each \u0026lsquo;Person\u0026rsquo; by their key Read a list of \u0026lsquo;Person\u0026rsquo; entities Update a \u0026lsquo;Person\u0026rsquo; entity Create yet another new \u0026lsquo;Person\u0026rsquo; entity See what options we can add to an entity request Delete an entity  "
},
{
	"uri": "https://1414c.github.io/jiffy/generation/gn-content-e/",
	"title": "Generated &#39;models&#39; Folder",
	"tags": [],
	"description": "",
	"content": " The \u0026lsquo;models\u0026rsquo; Folder FirstApp ├── appobj │ ├── appconf.go │ └── appobj.go . . . ├── models │ ├── authm.go │ ├── errors.go │ ├── group_authm.go │ ├── modelfuncs.go │ ├── personm_ext.go │ ├── personm.go │ ├── servicesm.go │ ├── usr_groupm.go │ ├── usrm.go │ └── ext │ └── model_ext_interfaces.go ├── util │ └── strings.go ├── .dev.config.json ├── .prd.config.json ├── main_test.go └── main.go  A model is created for each entity that has been modeled in the my_model.json files, as well as well as the static models used to support users and authorizations.\nModels define an entity\u0026rsquo;s structure and member field characteristics such as type, required/not-required, db-type etc. Each model has a corresponding controller that examines the request, parses the incoming JSON data into the model structure, and then calls the appropriate method in the entity-model based on the end-point / http method. The model provides a validator, which can be used to perform detailed checks and normalizations on the entity data prior to making the call to the sqac ORM.\nEmpty model validations are generated for each entity field, and are designed to be extended by the application developer. Validation methods are generated for each entity field and added to the model\u0026rsquo;s entity validator. For example, the model source file for entity \u0026lsquo;Library\u0026rsquo; (./models/librarym.go), contains a \u0026lsquo;libraryValidator\u0026rsquo; type. Validation methods for each of the library entity\u0026rsquo;s fields are attached to this type.\nThe validator type also contains methods matching the public interface (LibraryDB) of the model\u0026rsquo;s service definition. The model\u0026rsquo;s service declaration includes a validator member, and due to the manner of the declaration, it is the validator that is passed back to the caller (controller) when model access is needed.\n// newLibraryValidator returns a new libraryValidator func newLibraryValidator(ldb LibraryDB) *libraryValidator { return \u0026amp;libraryValidator{ LibraryDB: ldb, } } // NewLibraryService declaration func NewLibraryService(handle sqac.PublicDB) LibraryService { ls := \u0026amp;librarySqac{handle} lv := newLibraryValidator(ls) // *db return \u0026amp;libraryService{ LibraryDB: lv, } }  In the NewLibraryService function, see that two members are declared:\n ls contains an implementation of the generated LibraryDB interface which is used to call the ORM layer following successful execution of the model\u0026rsquo;s validations lv contains an implementation of the generated LibraryDB interface, as well as the set of empty generated field validation methods  Using the creation of a new \u0026lsquo;Library\u0026rsquo; entity as an example, the controller will parse the JSON body of the incoming request into a \u0026lsquo;Library\u0026rsquo; entity struct. The controller will then call the entity\u0026rsquo;s model.Create method. The \u0026lsquo;libraryValidator.Create\u0026rsquo; method (on lv) will execute the implemented field validations, then call the service\u0026rsquo;s model.Create() method (on ls)which will in-turn make the required call to the ORM.\n// Create validates and normalizes data used in the library creation. // Create then calls the creation code contained in LibraryService. func (lv *libraryValidator) Create(library *Library) error { // perform normalization and validation -- comment out checks that are not required // note that the check calls are generated as a straight enumeration of the entity // structure. It may be neccessary to adjust the calling order depending on the // relationships between the fields in the entity structure. err := runLibraryValFuncs(library, lv.normvalName, lv.normvalCity, ) if err != nil { return err } // use method-chaining to call the library service Create method return lv.LibraryDB.Create(library) }  The last line of the method is the most interesting, as it demonstrates something known as method-chaining which allows the call to implicitly access the \u0026lsquo;ls\u0026rsquo; methods. Look carefully at the code in this area so you understand what is happening, and perhaps lookup \u0026lsquo;method-chaining\u0026rsquo; as it pertains to golang.\nNote that at the moment, validations are intended to be coded directly in the body of the generated model code. This is in contrast with the extension-point technique implemented in the controller and at the sqacService level in the model file (see Extension Points). The reasons for this are as follows:\n It is expected that no validations will be coded until the model has been stabilized. It is generally desirable to get an application working (or mostly working), then start worrying about validations. Extension points exist as a convenience in the case where data needs pre/post processing. For most entities, some sort of validation will be required on the majority of fields. We treat the validations as first-class citizens in the application rather than extension-points. By treating validations as first-class citizens we do not need to use type assertion and reflection in the validation layer when performing the checks. This is in contrast to the model extension-point interfaces. If there is a concern regarding the over-writing of coded validations due to application regeneration, it is simple for an application developer to implement their own sub-package with methods or functions containing the check code. Jiffy application generation will not overwrite files that it is not responsible for during a regeneration of an application.  By default, a CRUD interface is generated for each entity. Using the \u0026lsquo;Library\u0026rsquo; example, the generated code for the CRUD end-points look as follows:\n// ====================== Library protected routes for standard CRUD access ====================== a.router.HandleFunc(\u0026quot;/librarys\u0026quot;, requireUserMw.ApplyFn(a.libraryC.GetLibrarys)).Methods(\u0026quot;GET\u0026quot;).Name(\u0026quot;library.GET_SET\u0026quot;) a.router.HandleFunc(\u0026quot;/library\u0026quot;, requireUserMw.ApplyFn(a.libraryC.Create)).Methods(\u0026quot;POST\u0026quot;).Name(\u0026quot;library.CREATE\u0026quot;) a.router.HandleFunc(\u0026quot;/library/{id:[0-9]+}\u0026quot;, requireUserMw.ApplyFn(a.libraryC.Get)).Methods(\u0026quot;GET\u0026quot;).Name(\u0026quot;library.GET_ID\u0026quot;) a.router.HandleFunc(\u0026quot;/library/{id:[0-9]+}\u0026quot;, requireUserMw.ApplyFn(a.libraryC.Update)).Methods(\u0026quot;PUT\u0026quot;).Name(\u0026quot;library.UPDATE\u0026quot;) a.router.HandleFunc(\u0026quot;/library/{id:[0-9]+}\u0026quot;, requireUserMw.ApplyFn(a.libraryC.Delete)).Methods(\u0026quot;DELETE\u0026quot;).Name(\u0026quot;library.DELETE\u0026quot;)  The generated go struct for the \u0026lsquo;Library\u0026rsquo; model looks as follows:\n// Library structure type Library struct { ID uint64 `json:\u0026quot;id\u0026quot; db:\u0026quot;id\u0026quot; sqac:\u0026quot;primary_key:inc\u0026quot;` Href string `json:\u0026quot;href\u0026quot; db:\u0026quot;href\u0026quot; sqac:\u0026quot;-\u0026quot;` Name string `json:\u0026quot;name\u0026quot; db:\u0026quot;name\u0026quot; sqac:\u0026quot;nullable:false;index:non-unique;index:idx_library_name_city\u0026quot;` City string `json:\u0026quot;city\u0026quot; db:\u0026quot;city\u0026quot; sqac:\u0026quot;nullable:false;index:idx_library_name_city\u0026quot;` }  The model structure and tags are explained:\n   Field Name Description     ID This is the injected key for the entity. The sqac tag \u0026ldquo;primary_key:inc\u0026rdquo; instructs the ORM that this field is to be created as an auto-incrementing column in the backend DBMS.   Href Each entity has an Href field injected into its structure when the application is generated. The Href value provides a direct link to read, update or delete the represented entity. This can be useful if the entity was returned as part of a list, or via a relation-based request. Changes to entities must be carried out via the direct links rather than through relation-type requests. Enforcement of this precludes the requirement of coding / executing additional checks during updates to make sure that the relationship path is valid. Authorization for end-point access is also simplified via this model. Sqac tag \u0026ldquo;-\u0026rdquo; indicates that this field is not persisted on the database and is not included in the table schema.   Name Name is a field from the model file, and has the following attributes in the backend DBMS based on the sqac tag-values: Not nullable, has a non-unique btree index, is part of a composite (non-unique) index consisting of the \u0026lsquo;name\u0026rsquo; and \u0026lsquo;city\u0026rsquo; table columns.   City City is a field from the model file, and has the following attributes in the backend DBMS based on the sqac tag-values: Not nullable, is part of a composite (non-unique) index consisting of the \u0026lsquo;name\u0026rsquo; and \u0026lsquo;city\u0026rsquo; table columns.    For a more complete explanation of the Sqac ORM tags and operation, see the README.md of the sqac library at: https://github.com/1414C/sqac\nThe models folder also contains an \u0026lsquo;ext\u0026rsquo; sub-directory which is used to hold the interface definitions for model extension-points. See the Extension Points section of this document for more details.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/usage/us-content-e/",
	"title": "Application Server Flags",
	"tags": [],
	"description": "",
	"content": " Application Server Flags Flags are generally not used, as the configuration files (models.json) are easier to deal with. There are however, a few flags that can be used when starting the server:\n -dr  The -dr switch is used to perform a destructive reset of the application\u0026rsquo;s data tables. This flag causes the application tables to be dropped and recreated, but does not affect the user, user-group, or authorization tables.   $ go run main.go -dev -dr   -rs  The -rs switch is used to add new auths detected in the route and add them to the Super user-group. It is a good idea to run with this flag in changing environments.   $ go run main.go -dev -rs   -al  The -al switch is used to instruct the application to write debugging information to stdout. This is not very useful at the moment.   $ go run main.go -dev -al   -dl  The -dl switch is used to instruct the ORM to write SQL DDL/DML statements to stdout. The written statements are in various states of assembly and in many cases are (close) approximations of what was or will be sent to the database.   $ go run main.go -dev -dl  "
},
{
	"uri": "https://1414c.github.io/jiffy/generation/gn-content-f/",
	"title": "Generated &#39;middleware&#39; Folder",
	"tags": [],
	"description": "",
	"content": " The \u0026lsquo;middleware\u0026rsquo; Folder FirstApp ├── appobj │ ├── ... │ └── ... . . . ├── middleware │ └── requireuser.go . . . ├── .dev.config.json ├── .prd.config.json ├── main_test.go └── main.go  The middleware folder contains all of the code related to the Authentication and Authorization concepts discussed in the Access Control Overview and Authorizations sections of this document.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/usage/us-content-f/",
	"title": "Testing with TLS",
	"tags": [],
	"description": "",
	"content": " Generate Self-Signed Certs for https Testing If you wish to perform local https-based testing, it is possible to do so through the use of self-signed certificates. Self-signed certificates can be easily created through the use of the openssl tool on *nix systems. \nVerify the OpenSSL Installation Open a terminal session and verify that openssl is available:\n$ which -a openssl /usr/bin/openssl  If openssl is not shown in the \u0026lsquo;which\u0026rsquo; command output, check your path to ensure you have access to /usr/bin or /usr/local/bin. If you have access to the ./bin directories, but still cannot find the openssl tool, it can be downloaded from https://www.openssl.org/source/ . Follow the directions on the site to correctly download and install the tool. \nGenerate a Private Certificate Authority (CA) Certificate Key Open a terminal session and execute the openssl command as shown:\n$ openssl genrsa -out \u0026quot;myCA.key\u0026quot; \u0026quot;2048\u0026quot; Generating RSA private key, 2048 bit long modulus ...................................+++ ..........................................................................................+++ e is 65537 (0x10001) $  Verify that a file called \u0026ldquo;myCA.key\u0026rdquo; has been created. \nGenerate a Private Certificate Authority (CA) Certificate Open a terminal session and execute the openssl command as shown:\n$ openssl req -x509 -new -days 365 -key \u0026quot;myCA.key\u0026quot; -out \u0026quot;myCA.cer\u0026quot; -subj \u0026quot;/CN=\\\u0026quot;\u0026quot;MyCompanyName\u0026quot;\\\u0026quot;\u0026quot;  There is no output to this command, so verify that a file called \u0026ldquo;myCA.cer\u0026rdquo; has been created. \nGenerate a Private Server Key Open a terminal session and execute the openssl command as shown:\n$ openssl genrsa -out \u0026quot;srvcert.key\u0026quot; \u0026quot;2048\u0026quot; Generating RSA private key, 2048 bit long modulus ..............................................................................................+++ .....+++ e is 65537 (0x10001) $  Verify that a file called \u0026ldquo;srvcert.key\u0026rdquo; has been created. \nCreate a Private Server Certificate Signing Request This generates an intermediate certificate signing request file (.csr) based on the Private Server Key created in the previous step. The creation of the CSR is an interrogative process, but for self-signed testing, most of the inputs can safely be ignored. Follow the prompts as per the example shown below:\n$ openssl req -new -key srvcert.key -out srvcert.csr You are about to be asked to enter information that will be incorporated into your certificate request. What you are about to enter is what is called a Distinguished Name or a DN. There are quite a few fields but you can leave some blank For some fields there will be a default value, If you enter '.', the field will be left blank. ----- Country Name (2 letter code) [AU]:CA State or Province Name (full name) [Some-State]:AB Locality Name (eg, city) []: Organization Name (eg, company) [Internet Widgets Ltd]:MyCompany Organizational Unit Name (eg, section) []: Common Name (e.g. server FQDN or YOUR name) []: Email Address []: Please enter the following 'extra' attributes to be sent with your certificate request A challenge password []: An optional company name []: $  Verify that a file called \u0026ldquo;srvcert.crt\u0026rdquo; has been created. \nCreate a Private Server Certificate This is the final step in getting the required certificate and key files to support local https testing. In this step, the CA certificate and private key files will be used in conjunction with the private server key and private server signing-request to generate a private server certificate. Execute the following command in your terminal session:\n$ openssl x509 -req -in srvcert.csr -out srvcert.cer -CAkey myCA.key -CA myCA.cer -days 365 -CAcreateserial -CAserial 123456 Signature ok subject=/C=CA/ST=AB/O=MyCompany Getting CA Private Key  Verify that a file called \u0026ldquo;srvcert.cer\u0026rdquo; has been created. \nEnsure myCA.cer is Trusted Locally Ensure that myCA.cer is fully-trusted in your local certificate store. The process to do this will differ per operating system, so look online for instructions regarding \u0026lsquo;trusting a self-signed CA certificate\u0026rsquo;. You may also need to adjust the settings in test tools like Postman in order for them to accept self-signed certs.\nAdd Certificates to the Configuration File In order to publish the generated services over https, add the \u0026ldquo;srvcert.cer\u0026rdquo; and \u0026ldquo;svrcert.key\u0026rdquo; files to the \u0026lsquo;cert_file\u0026rsquo; and \u0026lsquo;key_file\u0026rsquo; keys respectively in the appropriate configuration file. Additionally, the myCA.key file must be placed in the same directory as the \u0026ldquo;srvcert.*\u0026rdquo; files in order for go\u0026rsquo;s https (TLS) server to operate correctly.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/generation/gn-content-g/",
	"title": "Generated &#39;jwtkeys&#39; Folder",
	"tags": [],
	"description": "",
	"content": " The \u0026lsquo;jwtkeys\u0026rsquo; Folder FirstApp ├── appobj │ ├── ... │ └── ... . . . ├── jwtkeys │ ├── ecdsa256 │ │ ├── ecdsa.priv.pem │ │ └── ecdsa.pub.pem │ ├── ecdsa384 │ │ ├── ecdsa384.prive.pem │ │ └── ecdsa384.pub.pem │ ├── ecdsa521 │ │ ├── ecdsa521.priv.pem │ │ └── ecdsa521.pub.pem │ ├── rsa256 │ │ ├── rsa.priv.pem │ │ └── rsa.pub.pem │ ├── rsa384 │ │ ├── rsa384.prive.pem │ │ └── rsa384.pub.pem │ └── rsa512 │ ├── rsa512.priv.pem │ └── rsa512.pub.pem . . . ├── .dev.config.json ├── .prd.config.json ├── main_test.go └── main.go  The jwtkeys folder contains the public and private keys that are generated in order to support the use of JWT tokens. Jiffy generates public/private keys for all supported JWT signing algorithms. It would probably be okay to place the keys into a common location, as they are only read once by each application instance during its initialization. JWT\u0026rsquo;s and key usage are discussed in greater detail in the \u0026lsquo;Authorizations \u0026amp; End-Point Security\u0026rsquo; section of this documentation.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/usage/us-content-g/",
	"title": "Automated Application Testing",
	"tags": [],
	"description": "",
	"content": " Automated Testing When jiffy generates the application, a set of automated tests are also generated for the application\u0026rsquo;s end-points. The tests make use of the standard go test tooling. Tests can be conducted using http or https, and run against the address:port that the application is presently serving on. Remember, the application must be running prior to executing the test.\nThe generated CRUD tests check the availability of the end-points and attempt to perform CRUD activities using representative data for the field-types. If customization has occurred in the model normalization and validation enhancement points, the field values used in the generated main_test.go file should be updated accordingly. The generated CRUD tests are provided as a starting point for your own testing.\nThe generated simple selector tests check the availability of the end-points, and attempt to perform a GET for each of the selection operators specified in the Entity-\u0026gt;selectable field in the models.json file. It is not necessary to have values populated in the database in order for the simple selector tests to run.\nAt the moment, relationships are not included in the generated tests, and the test case generator needs to be updated to consider foreign-key relationships. For this reason, it is recommended to perform baseline model testing without foreign-keys in the model-files.\nRun go test With https In order to conduct automated testing via a TLS connection, follow the instructions in the \u0026lsquo;Testing with TLS\u0026rsquo; section of this documentation.\n$ go test -v -https -address \u0026quot;192.168.1.66:8080\u0026quot; 2018/06/05 17:50:17 package sqac init is running using usr: {\u0026quot;email\u0026quot;:\u0026quot;admin\u0026quot;,\u0026quot;password\u0026quot;:\u0026quot;initpass\u0026quot;} === RUN TestCreatePerson --- PASS: TestCreatePerson (0.03s) === RUN TestGetPersons --- PASS: TestGetPersons (0.03s) === RUN TestGetPerson --- PASS: TestGetPerson (0.01s) === RUN TestUpdatePerson --- PASS: TestUpdatePerson (0.04s) === RUN TestDeletePerson --- PASS: TestDeletePerson (0.01s) === RUN TestGetPersonsByName --- PASS: TestGetPersonsByName (0.05s) === RUN TestGetPersonsByAge --- PASS: TestGetPersonsByAge (0.09s) === RUN TestGetPersonsByWeight --- PASS: TestGetPersonsByWeight (0.11s) === RUN TestGetPersonsByValidLicense --- PASS: TestGetPersonsByValidLicense (0.10s) PASS ok exp/csrest4 1.495s $  Run go test Without https $ go test -v -address \u0026quot;192.168.1.66:8080\u0026quot; 2018/06/05 17:50:17 package sqac init is running using usr: {\u0026quot;email\u0026quot;:\u0026quot;admin\u0026quot;,\u0026quot;password\u0026quot;:\u0026quot;initpass\u0026quot;} === RUN TestCreatePerson --- PASS: TestCreatePerson (0.03s) === RUN TestGetPersons --- PASS: TestGetPersons (0.03s) === RUN TestGetPerson --- PASS: TestGetPerson (0.01s) === RUN TestUpdatePerson --- PASS: TestUpdatePerson (0.04s) === RUN TestDeletePerson --- PASS: TestDeletePerson (0.01s) === RUN TestGetPersonsByName --- PASS: TestGetPersonsByName (0.05s) === RUN TestGetPersonsByAge --- PASS: TestGetPersonsByAge (0.09s) === RUN TestGetPersonsByWeight --- PASS: TestGetPersonsByWeight (0.11s) === RUN TestGetPersonsByValidLicense --- PASS: TestGetPersonsByValidLicense (0.10s) PASS ok exp/csrest4 1.495s $  "
},
{
	"uri": "https://1414c.github.io/jiffy/generation/gn-content-h/",
	"title": "Other Generated Folders",
	"tags": [],
	"description": "",
	"content": " The \u0026lsquo;ext\u0026rsquo; Folders \u0026lsquo;ext\u0026rsquo; folders contain Jiffy application interface definitions and empty implementations of the same for controller and model extension-points. See the Extension Points section of this documentation.\nThe group/gmcl Folder The group/gmcl folder contains the source files for the usr, auth, usrgroup and groupauth cache clients. This package is for internal use only. See the Group Membership Overview and Failure Detector sections of this documentation.\nThe group/gmcom Folder The group/gmcom folder contains source files holding artifacts that are needed by the groups/\u0026hellip; packages and those of the generated jiffy application. This package is for internal use only. See the Group Membership Overview and Failure Detector sections of this documentation.\nThe group/gmsrv Folder The group/gmsrv folder contains the source files for the group-membership service, the failure detector and the leader-election mechanism. This package is for internal use only. See the Group Membership Overview and Failure Detector sections of this documentation.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/usage/us-content-h/",
	"title": "Key Value Store Support",
	"tags": [],
	"description": "",
	"content": " Overview A KVS is required in order to persist the current group-leader information in multi-instance jiffy-application deployments. This is discussed in the Joining Overview section of the Interprocess Communication documentation. Although we refer to the persistent store as a KVS, anything that manages access and allows read/write operations can be used. A sample implementation of the gmcom.GetterSetter interface is generated and used by default to communicate with the KVS.\nThe sample / default gmcom.GetterSetter implementation relies on a simple KVS called sluggo that was written as a super-lightweight non-productive testing solution. For now, the docs will refer to sluggo when discussing the KVS, but it recommended to use something more robust for real deployments.\nSluggo may be installed in your environment the following go get command:\n$ go get -u github.com/1414C/sluggo  Interface gmcom.GetterSetter should be implemented in the generated main.go file of the jiffy-application\u0026rsquo;s source code.\nExample gmcom.GetterSetter Implementation Interface gmcom.GMGetterSetter Interface gmcom.GMGetterSetter contains methods to facilitate read/write access to the persisted leader record in any key-value-store. Applications implementing the interface may choose to store the persisted current leader in any number of mediums; flat-file, db table record, redis, memcached etc.\n Interface gmcom.GMGetterSetter  \nGetDBLeader() (*GMLeader, error) GetDBLeader is provided in order to allow the implementer to retrieve the current group-leader information from the persistent store. The implementation of this method is intended to be self-contained. For example, if the implementation calls for the current leader information to be persisted in redis, the implementer should code a self-contained method to connect to redis, retrieve the leader information and return it in the GMLeader pointer. Failure to read a current leader from the persistent store should result in the return of a nil in place of the *GMLeader pointer and a non-nil error value.    SetDBLeader(l GMLeader) error SetDBLeader is provided in order to allow the implementer to persist a newly elected leader\u0026rsquo;s information in the persistent store. The implementation of this method is intended to be self-contained. For example, if the implementation calls for the current leader information to be persisted in redis, the implementer should code a self-contained method to connect to redis and store the leader information provided by input parameter l. Failure to persist the provided leader information should result in the implementer returning a non-nil value in the error return parameter.    Interface gmcom.GMSetterGetter Sample Implementation // LeadSetGet provides a sample implementation of the GMLeaderSetterGetter // interface in order to support persistence of the current group-leader // information. re-implement these methods as you see fit to facilitate // storage and retrieval of the leader information to and from the persistent // storage. This example uses a quick and dirty web-socket-based cache to // handle the persistence. It works well enough for testing, but you should // use something more robust like a database, redis etc. The methods in the // GMLeaderSetterGetter interface are called when a new process is attempting // to join the group and also when a new leader is selected via the coordinator // process. // // To test with the delivered interface implementation, install and run sluggo: // go get -u github.com/1414C/sluggo // // Execute sluggo from the command-line as follows: // go run main.go -a \u0026lt;ipaddress:port\u0026gt; // For example: // $ go run main.go -a 192.168.1.40:7070 // type LeadSetGet struct { gmcom.GMLeaderSetterGetter } // GetDBLeader retrieves the current leader information from // the persistence layer. func (sg *LeadSetGet) GetDBLeader() (*gmcom.GMLeader, error) { // access the database here to read the current leader l := \u0026amp;gmcom.GMLeader{} wscl.GetCacheEntry(\u0026quot;LEADER\u0026quot;, l, \u0026quot;192.168.1.40:7070\u0026quot;) return l, nil } // SetDBLeader stores the current leader information in the // persistence layer. func (sg *LeadSetGet) SetDBLeader(l gmcom.GMLeader) error { // access the database here to set a new current leader wscl.AddUpdCacheEntry(\u0026quot;LEADER\u0026quot;, \u0026amp;l, \u0026quot;192.168.1.40:7070\u0026quot;) return nil }  "
},
{
	"uri": "https://1414c.github.io/jiffy/usage/us-content-i/",
	"title": "Deployment on Bare Metal / VM&#39;s",
	"tags": [],
	"description": "",
	"content": " Deployment Overview Jiffy was written with the idea of generating sidecar-free backend service applications. While this is a nice goal, the current version of Jiffy relies on the presence of some external processes and/or services depending on the target environment.\nDatabase System The generated application will need to connect to a database system from the supported list. We suggest using sqlite3 for initial testing if you do not want to install a full DBMS on your development machine. Connectivity to your database can be checked by running the test suite in the github.com/1414C/sqac repository. The sqac repository will be pulled into your Go environment when the Jiffy source code is installed via go get -u. See the README.md file in the sqac repository for instructions.\nKey Value Store A KVS is required in order to persist the current group-leader information. This is discussed in the Key Value Store Support section of this documentation. Deployment-specific considerations are outlined for each of the following deployment scenarios.\nLoad Balancer Jiffy applications are designed to scale horizontally by starting more application server instances (processes). The applications do not handle load balancing however, and in a bare metal or VM-type deployment it is recommended to use something like NGinx to direct traffic.\nSample Deployment Scenarios The following are a few high-level deployment scenarios for a jiffy-generated application. Infrastructure security is not discussed here in any depth, but if you deploy a Jiffy-application productively the usual precautions apply.\nAll-In-One Deployment In a development or test setting it may make sense to deploy everything in one system. In this context \u0026lsquo;system\u0026rsquo; refers to a laptop, bare-metal server or a VM of some sort. To deploy an all-in-one type setup, the following artifacts are required:\n Database Jiffy application Optional Key-Value-Store  The All-In-One Deployment diagram shows a jiffy-application instance running on a system with an ip-address of 192.168.1.5. The application instance is accepting http client connections on port :8080, using port :7070 to listen for failure-detector \u0026amp; cache synchronization messages. The failure detector \u0026lsquo;bus\u0026rsquo; is used for group-leadership and inter-process cache messages, even when the application is run standalone (single process).\nIt is not necessary to run an external KVS if the jiffy-application will be run as a standalone process. The KVS is used to hold the current group-leader information when jiffy applications are deployed with more than one instance. When running without a KVS it is fine to leave the default gmcom.GetterSetter implementation as it is. The application instance will attempt to contact the default KVS (sluggo) four times, then give up, assign itself a PID of 1 and assert leadership inside it\u0026rsquo;s own process. The short version is: don\u0026rsquo;t worry about the KVS if you want to run a single instance of your jiffy application.\nIf you do choose to run an All-In-One / single application instance with a KVS, using sluggo and making use of the jiffy-application\u0026rsquo;s default gmcom.GetterSetter implementation is the easiest way to get started. You may also choose to create your own implementation of the gmcom.GetterSetter interface in the main.go file to support another KVS.\nThe application communicates with the KVS using whatever protocol/transport is required. Remember that the selection of KVS is arbitrary and an interface is provided to allow the implementer to write their own code to communicate with any KVS.\nThe application is also shown to be accessing the locally installed database over a tcp connection. In this example we show PostgreSQL accepting connections on it\u0026rsquo;s default port (tcp/5432), but any of the supported databases can be used. \nSingle-Instance Deployment Single instance deployments contain one jiffy-application instance, an optional KVS and a database. In this scenario the database is running on a separate system and is available over the local network. Ip-addresses are shown for illustrative purposes only.\n Database running on a separate host Jiffy application Optional Key-Value-Store  The Single-Instance Deployment diagram shows a jiffy-application instance running on a system with an ip-address of 192.168.1.5. The application instance is accepting http client connections on port :8080, using port :7070 to listen for failure-detector \u0026amp; cache synchronization messages. The failure detector \u0026lsquo;bus\u0026rsquo; is used for group-leadership and inter-process cache messages, even when the application is run standalone (single process).\nIt is not necessary to run an external KVS if the jiffy-application will be run as a standalone process. The KVS is used to hold the current group-leader information when jiffy applications are deployed with more than one instance. When running without a KVS it is fine to leave the default gmcom.GetterSetter implementation as it is. The application instance will attempt to contact the default KVS (sluggo) four times, then give up, assign itself a PID of 1 and assert leadership inside it\u0026rsquo;s own process. The short version is: don\u0026rsquo;t worry about the KVS if you want to run a single instance of your jiffy application.\nIf you do choose to run a single application instance with a KVS, using sluggo and making use of the jiffy-application\u0026rsquo;s default gmcom.GetterSetter implementation is the easiest way to get started. You may also choose to create your own implementation of the gmcom.GetterSetter interface in the main.go file to support another KVS.\nThe application communicates with the KVS using whatever protocol/transport is required. Remember that the selection of KVS is arbitrary and an interface is provided to allow the implementer to write their own code to communicate with any KVS.\nThe application is also shown to be accessing a Postgres database via tcp @192.168.1.31:5432. In this example we show PostgreSQL accepting connections on it\u0026rsquo;s default port (tcp/5432), but any of the supported databases can be used. \nMulti-Instance Deployment Multi-instance deployments contain more than one jiffy-application instance, a KVS and a database. In this scenario the database is running on a separate system and is available over the local network and jiffy-application instances are running in parallel on multiple hosts. In this arrangement the KVS is not optional, as the group-leadership sub-system requires it in order to persist the group-leader information.\n Database running on a separate host Jiffy application instances running on separate hosts/VM\u0026rsquo;s Key-Value-Store  The Multi-Instance Deployment diagram shows a number of jiffy-application instances running on individual hosts. Each application instance is accepting http client connections on port :8080, using port :7070 to listen for failure-detector \u0026amp; cache synchronization messages. The failure detector \u0026lsquo;bus\u0026rsquo; is used for group-leadership and inter-process cache messages. Each application instance is shown making a web-socket connection to its peers on ws:7070.\nThe KVS is used to hold the current group-leader information when jiffy applications are deployed with more than one instance. See the Interprocess Communication section for details regarding the use of the KVS with group-membership and group-leader election.\nRunning sluggo and making use of the default gmcom.GetterSetter implementation is the easiest way to get started. You may also choose to create your own implementation of the gmcom.GetterSetter interface in the main.go file to support another KVS.\nThe application communicates with the KVS using whatever protocol/transport is required. Remember that the selection of KVS is arbitrary and an interface is provided to allow the implementer to write their own code to communicate with any KVS.\nApplication instances are shown to be accessing a Postgres database via tcp @192.168.1.31:5432. In this example we show PostgreSQL accepting connections on it\u0026rsquo;s default port (tcp/5432), but any of the supported databases can be used.\nWhen running multiple jiffy-application instances a load-balancer of some sort should be used to route traffic based on end-point, system-load or other locally important criteria.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/level-two/l2-content-a/",
	"title": "Login",
	"tags": [],
	"description": "",
	"content": "Launch Postman and specify a target URL of: http://127.0.0.1:8080/usr/login making sure to select the http POST method. Maintain the request body to provide a user-id and password as shown in the following JSON snippet. Typically the user-id for a Jiffy application is an email address, but we make an exception for the default administration user.\n{ \u0026quot;email\u0026quot;: \u0026quot;admin\u0026quot;, \u0026quot;password\u0026quot;: \u0026quot;initpass\u0026quot; }  \nWhen you have finished and your Postman (or other test utility) looks like the following image, click the \u0026lsquo;Send\u0026rsquo; button to post your login request to the running application.  If all goes well, you will get a http response code of 200 (status ok), and a block of JSON with a single \u0026lsquo;token\u0026rsquo; tag containing a jumble of letters and numbers. This is the JWT that will be used to validate our authorization to access the Person entity\u0026rsquo;s service end-points. If you want to read more about JWT\u0026rsquo;s, jwt.io is a good place to start, or you can refer to the Access Control section of this document set. "
},
{
	"uri": "https://1414c.github.io/jiffy/usage/us-content-j/",
	"title": "Deployment on Kubernetes",
	"tags": [],
	"description": "",
	"content": " Deployment Overview "
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/level-two/l2-content-b/",
	"title": "Create a Person",
	"tags": [],
	"description": "",
	"content": "Now that we have successfully logged into the application and received our first JWT, it is time to create a new \u0026lsquo;Person\u0026rsquo; entity. Start by copying the content of the \u0026lsquo;token\u0026rsquo; tag from the login response body to the clipboard. This JWT must henceforth be included in the http header of every subsequent request.\nCreate a new tab in Postman and specify a target URL of http://127.0.0.1:8080/person with the http POST method. Next, add the following key-value pairs to the http header:\n Content-Type : application\\json Authorization : Bearer *paste-your-JWT-here*  When you have finished maintaining the http header-values, click on \u0026lsquo;Body\u0026rsquo; and maintain it using the \u0026lsquo;raw\u0026rsquo; setting. This will allow you to paste the following JSON code snippet into the request\u0026rsquo;s body:\n{ \u0026quot;name\u0026quot;: \u0026quot;Steve Dallas\u0026quot;, \u0026quot;age\u0026quot;: 46, \u0026quot;weight\u0026quot;: 185, \u0026quot;valid_license\u0026quot;: true, \u0026quot;license_class\u0026quot;: \u0026quot;A\u0026quot; }  \nWhen you have finished, the test session should look as follows and it is time to create our first \u0026lsquo;Person\u0026rsquo; entity. Click \u0026lsquo;Send\u0026rsquo; to post the new entity to the application.\n\nCongratulations! You have created your first \u0026lsquo;Person\u0026rsquo; entity!\nThe router matched the request URL to a route (service end-point), the middleware layer in the matched route examined the JWT, verified it was okay to proceed and then passed the raw JSON from the request body to the \u0026lsquo;Person\u0026rsquo; entity\u0026rsquo;s controller. The controller unmarshalled the JSON into a \u0026lsquo;Person\u0026rsquo; struct and then passed the result to the Create method in the model/validation layer. Validation of the \u0026lsquo;Person\u0026rsquo; struct\u0026rsquo;s content occurred, and then a call was made to the underlying sqac ORM to create the entity on the database.\nThe sqac ORM-layer returned the new entity to the application\u0026rsquo;s model-layer, where it was checked and passed back to the controller layer, whereupon it was marshaled (struct content becomes JSON) and written to the the response-writer.\nThis is a high-level view of what transpired, but the general flow of things is accurate.\nNotice that the entity passed back to us seems to have a couple of extra fields? All entities created via a Jiffy model file are injected with a primary-key of \u0026lsquo;id\u0026rsquo; as well as a non-persistent \u0026lsquo;href\u0026rsquo; field. In this example, our entity\u0026rsquo;s \u0026lsquo;id\u0026rsquo; field was specified to be auto-incrementing with a starting value of 10000000. See the sqac-tag section in the documentation for details regarding key options.\nHref is included in each entity\u0026rsquo;s GET responses, and acts as a self-reference providing the entity\u0026rsquo;s direct access URI to the consumer.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/level-two/l2-content-c/",
	"title": "Create Another Person",
	"tags": [],
	"description": "",
	"content": "Let\u0026rsquo;s change a few things in our request-body and create another \u0026lsquo;Person\u0026rsquo; entity. Edit the JSON body in the request section of your Postman session and click \u0026lsquo;Send\u0026rsquo; when you are ready.\n\nAnother \u0026lsquo;Person\u0026rsquo; entity has been created.\n\nCreate one more \u0026lsquo;Person\u0026rsquo; entity so we have three (or more) in total.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/level-two/l2-content-d/",
	"title": "Get Some Persons",
	"tags": [],
	"description": "",
	"content": "So far we have created a few \u0026lsquo;Person\u0026rsquo; entities. We have observed that upon successful creation of an entity, a JSON representation of that entity is passed back to us via the response-writer. Let\u0026rsquo;s now look at how we can get a list of all of our \u0026lsquo;Person\u0026rsquo; entities.\nCreate a new tab in Postman and specify a target URL of http://127.0.0.1:8080/persons making sure to select the http GET method. Next, add the following key-value pair to the http header:\n Authorization : Bearer *paste-your-JWT-here*  When you have finished, the test session should look as follows and it is time to read some \u0026lsquo;Person\u0026rsquo; entities from the database. Click \u0026lsquo;Send\u0026rsquo; to issue our read request to the application.\n\nWe just read the complete list of \u0026lsquo;Person\u0026rsquo; entities. Adding an \u0026rsquo;s\u0026rsquo; to the entity name and issuing the request with a GET http verb tells a jiffy application to read all of the \u0026lsquo;Person\u0026rsquo; entities. In some cases this looks odd, but it makes it quite easy to consume the services. Notice that the \u0026lsquo;href\u0026rsquo; field of each \u0026lsquo;Person\u0026rsquo; entity provides a direct link to the entity that it is a part of.\n\n"
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/level-two/l2-content-e/",
	"title": "Get a Person",
	"tags": [],
	"description": "",
	"content": "What if we need to read a single \u0026lsquo;Person\u0026rsquo;, or isolate a \u0026lsquo;Person\u0026rsquo; entity from a list of entities? Let\u0026rsquo;s try reading a \u0026lsquo;Person\u0026rsquo; entity using its \u0026lsquo;id\u0026rsquo; key.\nCreate a new tab in Postman and specify a target URL of http://127.0.0.1:8080/person/10000001 making sure to select the http GET method. Next, add the following key-value pair to the http header:\n Authorization : Bearer *paste-your-JWT-here*  When you have finished, the test session should look as follows and it is time to read \u0026lsquo;Person\u0026rsquo; 10000001 from the database. Click \u0026lsquo;Send\u0026rsquo; to issue our read request to the application.\n\nWe just read the \u0026lsquo;Person\u0026rsquo; entity with \u0026lsquo;id\u0026rsquo; key 10000001. While this is not a very human-friendly way to search for a person, it is a simple way to isolate and reference an entity for reading, updating or deletion.\n\n"
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/level-two/l2-content-f/",
	"title": "Update a Person",
	"tags": [],
	"description": "",
	"content": "If you have been following along, we have created \u0026lsquo;Person\u0026rsquo; entities, read \u0026lsquo;Person\u0026rsquo; entities both in bulk and by \u0026lsquo;id\u0026rsquo; key. We are now going to take a look at updating an existing entity.\nRead \u0026lsquo;Person\u0026rsquo; entity 10000001 from the database as shown in the Get a Person example.\nOnce you have successfully read \u0026lsquo;Person\u0026rsquo; entity 10000001 into your Postman session, copy the content of the response body to your clipboard. We are going to reuse our GET Person Postman tab to perform an update, so change the http verb from GET to PUT. Changing the http verb to PUT will allow us to maintain the request-body in our Postman tab. Next, add the following key-value pair to the http header:\n Content-Type : application\\json  Now paste the GET Person response-body into the request-body of our new PUT request, then edit it so that Opus\u0026rsquo;s full name is given. Strictly speaking, you do not need to include the \u0026lsquo;id\u0026rsquo; or \u0026lsquo;href\u0026rsquo; fields in an update, but it does not hurt anything to do so.\n{ \u0026quot;id\u0026quot;: 10000001, \u0026quot;href\u0026quot;: \u0026quot;http://127.0.0.1:8080/person/10000001\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Opus the Penguin\u0026quot;, \u0026quot;age\u0026quot;: 8, \u0026quot;weight\u0026quot;: 385, \u0026quot;valid_license\u0026quot;: false }  \nWhen you have finished, you should have something that looks as follows. Click \u0026lsquo;Send\u0026rsquo; to issue the PUT request to the application.\n\nThe PUT request should update the entity using the \u0026lsquo;id\u0026rsquo; key as its update criteria, and then return a JSON representation of the updated entity. This is a little different than other approaches, where the result of an update is measured simply by the http response code. If you don\u0026rsquo;t like the way this works, it is very easy to update the generated source code to omit the response body following a PUT.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/level-two/l2-content-g/",
	"title": "Get Persons With Restrictions",
	"tags": [],
	"description": "",
	"content": "We have seen how to Create, Get, and Update a \u0026lsquo;Person\u0026rsquo; entity, but before we get around to the Delete operation, let\u0026rsquo;s take a quick look at some other simple things we can do with Get entity lists.\n  Get a count of \u0026#39;Person\u0026#39; entities in the database   http://127.0.0.1:8080/persons/$count .\n    Get all \u0026#39;Person\u0026#39; entities in the database ordered-by age   http://127.0.0.1:8080/persons$orderby=age .\n \n  Get all \u0026#39;Person\u0026#39; entities in the database ordered-by age descending   http://127.0.0.1:8080/persons$orderby=age$desc .\n \n  Get all \u0026#39;Person\u0026#39; entities in the database ordered-by age descending with a selection offset of 1   http://127.0.0.1:8080/persons/$orderby=age$desc$offset=1 .\n \n  Get all \u0026#39;Person\u0026#39; entities in the database ordered-by age descending with a limit of 2   http://127.0.0.1:8080/persons/$orderby=age$desc$limit=2 .\n \n  Get all \u0026#39;Person\u0026#39; entities in the database with name like %qui%   http://127.0.0.1:8080/persons/name(LIKE 'qui') .\n \n  Get all \u0026#39;Person\u0026#39; entities in the database with age equal to 46   http://127.0.0.1:8080/persons/$age(EQ 46) .\n \n"
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/level-two/l2-content-h/",
	"title": "Delete a Person",
	"tags": [],
	"description": "",
	"content": "Next we will delete one of our \u0026lsquo;Person\u0026rsquo; entities. Create a new tab in Postman and specify a target URL of http://127.0.0.1:8080/person/10000000 with the http DELETE method. Next, add the following key-value pairs to the http header:\n Content-Type : application\\json Authorization : Bearer *paste-your-JWT-here*  When you have something that looks as follows, click the \u0026lsquo;Send\u0026rsquo; button to issue the delete request to the application.\nIf the delete request was successful, you will see a http response-code of 202 (Accepted). Try to read the entity by converting your delete request into a get request and verify that \u0026lsquo;Person\u0026rsquo; entity 10000000 has truly been deleted.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/getting-started/level-two/l2-content-i/",
	"title": "Next Steps",
	"tags": [],
	"description": "",
	"content": "That is a quick overview of the sort of things that can be done with an application generated by Jiffy. There is a lot more to see however!\nGood places to start would be in the Jiffy Overview and the Model Maintenance section.\n"
},
{
	"uri": "https://1414c.github.io/jiffy/",
	"title": "",
	"tags": [],
	"description": "",
	"content": " Jiffy RESTful Services Generator Jiffy is a model-based RESTful application services generator written in Go. Jiffy processes model files to generate Go source code for a complete backend services application. It was originally developed as an experiment to offer an alternative avenue when developing native applications for SAP Hana. The Jiffy application allows a developer to treat the data persistence layer as an abstraction, thereby removing the need to make use of CDS and the SAP XS(A) libraries.\nWhile this is not for everybody, it does reduce the mental cost of entry and allows deployment of a web-based application on SAP Hana with virtually no prior Hana knowledge. Jiffy also works nicely with other databases.\nMain Features  generated applications can be connected to Postgres, MSSQL, SAP Hana, SQLite or MariaDB with no source-code changes no database specific code is compiled into the binary bcrypt salt/pepper based authentication scheme session management and end-point authorizations are provided via jwt built-in support for the creation of jwt signing-keys service end-points are secured by way of jwt claims in the route handler middleware service end-point security is generated by default, along with corresponding authorization objects uses JSON model file(s) for Entity, Index, Relationship and Foreign-Key definitions generates a set of CRUD-type RESTful services for each entity in the model file(s) built-in support for https getSet type end-points support /$count, $limit=n, $offset=n, $orderby=field_name ($asc|$desc) generates end-points for hasOne, hasMany and belongsTo entity relationships generates static query end-points each entity\u0026rsquo;s corresponding service can be enabled and disabled on a per process basis generated models support persistent and non-persistent fields generated apps create and alter backend database artifacts based on model definitions baked in normalization and validation in the model-layer generates a comprehensive set of working tests via go test generated code is easily extended either via direct editing, or through an extension-point concept is designed to be deployed across multiple VM\u0026rsquo;s or containers by way of a leader-election and failure detection subsystem utilizes an internally replicated cache for user, user-group and authorization artifacts entity caching can be easily extensible via enhancement-points in the controller or model layers (redis / memcached for example)  "
},
{
	"uri": "https://1414c.github.io/jiffy/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://1414c.github.io/jiffy/credits/",
	"title": "Credits",
	"tags": [],
	"description": "",
	"content": " Contributors Thanks to them  for making Open Source Software a better place !\nPackages and libraries  sqlx jwt-go go-sql-driver/mysql lib/pq go-sqlite3 go-mssqldb go-hdb  Tooling  Hugo Hugo Learn Theme  "
},
{
	"uri": "https://1414c.github.io/jiffy/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]