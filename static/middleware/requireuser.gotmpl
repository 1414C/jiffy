package middleware

import (
	"crypto/ecdsa"
	"fmt"
	"net/http"

	"{{.AppPath}}/models"
	"github.com/dgrijalva/jwt-go"
	"github.com/dgrijalva/jwt-go/request"
)

//=============================================================================================
// start of generated code: please do not modify this section 
// code generated on {{ .GetDateTimeStamp }}
//=============================================================================================

// RequireUsr offers a closure that can be called with the requested page's
// w,r in order to verify that the usr is logged in prior to rendering the
// requested page.
type RequireUsr struct {
	Usr      models.UsrService
	VerifyKey *ecdsa.PublicKey
}

// ApplyFn assumes that Usr middleware has already been run
// otherwise it will not work correctly.
func (mw *RequireUsr) ApplyFn(next http.HandlerFunc) http.HandlerFunc {

	// http.HandlerFunc is casting the type of the closure here
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {

		// verify the JWT content
		token, err := request.ParseFromRequest(r, request.AuthorizationHeaderExtractor,
			func(token *jwt.Token) (interface{}, error) {
				return mw.VerifyKey, nil
			})

		if err == nil {
			if token.Valid {
				next(w, r)
				return
			}
			w.WriteHeader(http.StatusUnauthorized)
			fmt.Fprint(w, "Unauthorized access to this resource")
			return
		}
		w.WriteHeader(http.StatusUnauthorized)
		fmt.Fprint(w, "Unauthorized access to this resource")
		return
	})
}

// Apply assumes that Usr middleware has already been run
// otherwise it will not work correctly.
func (mw *RequireUsr) Apply(next http.Handler) http.HandlerFunc {
	// log.Println("middleware: *RequireUser: Apply:", next)
	return mw.ApplyFn(next.ServeHTTP)
}