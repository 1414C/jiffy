package middleware

import (
	"crypto/ecdsa"
	"fmt"
	"net/http"

	"{{.AppPath}}/models"
	"github.com/dgrijalva/jwt-go"
	"github.com/dgrijalva/jwt-go/request"
)

//=============================================================================================
// start of generated code: please do not modify this section 
// code generated on {{ .GetDateTimeStamp }}
//=============================================================================================

// RequireUsr offers a closure that can be called with the requested page's
// w,r in order to verify that the usr is logged in prior to rendering the
// requested page.
type RequireUsr struct {
	Usr      models.UsrService
	VerifyKey *ecdsa.PublicKey
	mapGA     map[string]map[string]bool // map[groupName]map[auth_name]bool
}

// InitMW is used to initialize the usr authorization middleware
 func InitMW(Usr models.UsrService, VerifyKey *ecdsa.PublicKey, mapGroupAuths map[string]map[string]bool) (requireUser RequireUsr) {
 
 	requireUser.Usr = Usr
 	requireUser.VerifyKey = VerifyKey
 	requireUser.mapGA = mapGroupAuths
 	return requireUser
 }

 // CheckAuth verifies that the AuthName is contained in one of the supplied Groups
 func (mw *RequireUsr) CheckAuth(authName string, groups []string) bool {
 
 	// no group auths setup - disallow all access
 	if len(mw.mapGA) == 0 {
 		return false
 	}
 
 	// iterate over the supplied group names and attempt to find
 	// a matching group-auth combination in mw.mapGA.
 	for _, g := range groups {
 
 		// nil here is odd but plausible
 		mapAuths := mw.mapGA[g]
 		if mapAuths == nil {
 			continue
 		}
 
 		auth := mapAuths[authName]
 		if auth == true {
 			return true
 		}
 	}
 	return false
  }

// ApplyFn assumes that Usr middleware has already been run
// otherwise it will not work correctly.
func (mw *RequireUsr) ApplyFn(next http.HandlerFunc) http.HandlerFunc {

	// http.HandlerFunc is casting the type of the closure here
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {

		// verify the JWT content
		token, err := request.ParseFromRequest(r, request.AuthorizationHeaderExtractor,
			func(token *jwt.Token) (interface{}, error) {
				return mw.VerifyKey, nil
			})

		if err == nil {
			if token.Valid {
				next(w, r)
				return
			}
			w.WriteHeader(http.StatusUnauthorized)
			fmt.Fprint(w, "Unauthorized access to this resource")
			return
		}
		w.WriteHeader(http.StatusUnauthorized)
		fmt.Fprint(w, "Unauthorized access to this resource")
		return
	})
}

// Apply assumes that Usr middleware has already been run
// otherwise it will not work correctly.
func (mw *RequireUsr) Apply(next http.Handler) http.HandlerFunc {
	// log.Println("middleware: *RequireUser: Apply:", next)
	return mw.ApplyFn(next.ServeHTTP)
}