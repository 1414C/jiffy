package controllers

import (
	"crypto/ecdsa"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"strconv"
	"time"
    
	"{{.AppPath}}/models"
	"github.com/dgrijalva/jwt-go"
	"github.com/gorilla/mux"
)

// UsrController - the usr controller type
type UsrController struct {
	us        models.UsrService
	signKey   *ecdsa.PrivateKey
	verifyKey *ecdsa.PublicKey
}

// Token is the jwt return type
type Token struct {
	Token string `json:"token"`
}

// NewUsrController creates a new UsrController
func NewUsrController(us models.UsrService, signKey *ecdsa.PrivateKey, verifyKey *ecdsa.PublicKey) *UsrController {
	return &UsrController{
		us:        us,
		signKey:   signKey,
		verifyKey: verifyKey,
	}
}

// Login - used to verify the provided email address and password
//
// POST /login
func (uc *UsrController) Login(w http.ResponseWriter, r *http.Request) {

	// parse the Usr data in JSON format from the incoming request
	var u models.Usr
	decoder := json.NewDecoder(r.Body)
	if err := decoder.Decode(&u); err != nil {
		respondWithError(w, http.StatusBadRequest, "userc: Invalid request payload")
		return
	}
	defer r.Body.Close()

	// fill the Usr model with the data needed for authentication only
	usr := models.Usr{
		Email:    u.Email,
		Password: u.Password,
	}

	// attempt to authenticate the user.  note that writing to
	// the response-writer in advance of setting the cookie will
	// cause the call to http.SetCookie(&cookie) to silently fail.
	authenticatedUsr, err := uc.us.Authenticate(usr.Email, usr.Password)
	if err != nil {
		switch err {
		case models.ErrNotFound:
			log.Println(err)
			respondWithError(w, http.StatusBadRequest, err.Error())
			return
		default:
			log.Println(err)
			respondWithError(w, http.StatusBadRequest, err.Error())
			return
		}
	}

	// groups
	fmt.Println("Login()->user groups:", *authenticatedUsr.Groups)

	// set standard claims - JWT valid for one hour
	// token := jwt.New(jwt.SigningMethodRS256)
	token := jwt.New(jwt.SigningMethodES384)
	claims := make(jwt.MapClaims)
	claims["email"] = authenticatedUsr.Email
	claims["id"] = authenticatedUsr.ID
	claims["exp"] = time.Now().Add(time.Hour * time.Duration(1)).Unix()
	claims["iat"] = time.Now().Unix()
	
	// set custom claims; auth groups as ; separated string
	claims["Groups"] = *authenticatedUsr.Groups
	token.Claims = claims

	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintln(w, "Error extracting the key")
		fatal(err)
	}

	tokenString, err := token.SignedString(uc.signKey)

	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintln(w, "Error while signing the token")
		fatal(err)
	}

	response := Token{tokenString}
	respondWithJSON(w, http.StatusOK, response)
}

// Create - process the signup when a usr attempts to create a new usr account.
// It is debatable whether Create should be supported as a general usr creation
// mechanism.
//
// POST /signup
func (uc *UsrController) Create(w http.ResponseWriter, r *http.Request) {

	// parse the Usr data in JSON format from the incoming request
	var u models.Usr
	decoder := json.NewDecoder(r.Body)
	if err := decoder.Decode(&u); err != nil {
		respondWithError(w, http.StatusBadRequest, "usrc: Invalid request payload")
		return
	}
	defer r.Body.Close()

	// fill the Usr model
	usr := models.Usr{
		Name:     u.Name,
		Email:    u.Email,
		Password: u.Password,
		Active:   u.Active,
		Groups:   u.Groups,
	}

	// build a base urlString for the JSON Body self-referencing Href tag
	urlString := buildHrefStringFromCRUDReq(r, false)

	// call the create method on the usr model
	err := uc.us.Create(&usr)
	if err != nil {
		log.Println(err)
		respondWithError(w, http.StatusBadRequest, err.Error())
		return
	}
	usr.Password = ""
	usr.PasswordHash = ""
	usr.Href = urlString + "/" + strconv.FormatUint(uint64(usr.ID), 10)
	respondWithJSON(w, http.StatusCreated, usr)
}

// Update facilitates the update of an existing Usr.  This method is bound
// to the gorilla.mux router in main.go.
//
// PUT /usr:id
func (uc *UsrController) Update(w http.ResponseWriter, r *http.Request) {

	// get the parameter(s)
	vars := mux.Vars(r)
	id, err := strconv.ParseUint(vars["id"], 10, 64)
	if err != nil {
		log.Println("Usr Update:", err)
		respondWithError(w, http.StatusBadRequest, "invalid request")
		return
	}

	var u models.Usr
	decoder := json.NewDecoder(r.Body)
	defer r.Body.Close()
	if err := decoder.Decode(&u); err != nil {
		log.Println("Usr Update:", err)
		respondWithError(w, http.StatusBadRequest, "invalid request payload")
		return
	}

	// get the existing Usr record from the db - byID
	staleUsr := models.Usr{
		ID: u.ID,
	}

	err = uc.us.Get(&staleUsr)
	if err != nil {
		log.Println("Usr Update:", err)
		respondWithError(w, http.StatusBadRequest, "invalid request")
	}

	// fill the model
	uTime := time.Now()
	// utcTime := uTime.UTC()
	usr := models.Usr{
		ID:           id,
		Name:         u.Name,
		Email:        u.Email,
		PasswordHash: staleUsr.PasswordHash,
		CreatedOn:    staleUsr.CreatedOn,
		UpdatedOn:    &uTime,
		Active:       u.Active,
		Groups:       u.Groups,
	}

	// build a base urlString for the JSON Body self-referencing Href tag
	urlString := buildHrefStringFromCRUDReq(r, false)

	// call the update method on the model
	err = uc.us.Update(&usr)
	if err != nil {
		log.Println("User Update:", err)
		respondWithError(w, http.StatusBadRequest, err.Error())
		return
	}

	// remove the password info from the response data
	usr.PasswordHash = ""
	usr.PasswordHash = ""
	usr.Href = urlString
	respondWithJSON(w, http.StatusCreated, usr)
}

// Get facilitates the retrieval of an existing Usr.  This method is bound
// to the gorilla.mux router in main.go.
//
// GET /usr/:id
func (uc *UsrController) Get(w http.ResponseWriter, r *http.Request) {

	vars := mux.Vars(r)
	id, err := strconv.ParseUint(vars["id"], 10, 64)
	if err != nil {
		log.Println("Usr Get:", err)
		respondWithError(w, http.StatusBadRequest, "invalid request")
		return
	}

	// build a base urlString for the JSON Body self-referencing Href tag
	
	urlString := buildHrefStringFromCRUDReq(r, false)

	usr := models.Usr{
		ID: id,
	}

	err = uc.us.Get(&usr)
	if err != nil {
		log.Println(err)
		respondWithError(w, http.StatusBadRequest, err.Error())
		return
	}
	usr.PasswordHash = ""
	usr.PasswordHash = ""
	usr.Href = urlString
	respondWithJSON(w, http.StatusCreated, usr)
}

// Delete facilitates the deletion of an existing Usr.  This method is bound
// to the gorilla.mux router in main.go.
//
// DELETE /usr/:id
func (uc *UsrController) Delete(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	id, err := strconv.ParseUint(vars["id"], 10, 64)
	if err != nil {
		respondWithError(w, http.StatusBadRequest, "Invalid User ID")
		return
	}

	usr := models.Usr{
		ID: id,
	}

	err = uc.us.Delete(&usr)
	if err != nil {
		if err != nil {
			respondWithError(w, http.StatusBadRequest, err.Error())
			return
		}
	}
	respondWithHeader(w, http.StatusAccepted)
}

func fatal(err error) {
	if err != nil {
		log.Fatal(err)
	}
}
