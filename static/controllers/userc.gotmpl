package controllers

import (
	"crypto/ecdsa"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"strconv"
	"time"
    
	"{{.AppPath}}/models"
	"github.com/dgrijalva/jwt-go"
	"github.com/gorilla/mux"
)

// UsrController - the usr controller type
type UsrController struct {
	us        models.UsrService
	signKey   *ecdsa.PrivateKey
	verifyKey *ecdsa.PublicKey
}

// Token is the jwt return type
type Token struct {
	Token string `json:"token"`
}

// NewUsrController creates a new UsrController
func NewUsrController(us models.UsrService, signKey *ecdsa.PrivateKey, verifyKey *ecdsa.PublicKey) *UsrController {
	return &UsrController{
		us:        us,
		signKey:   signKey,
		verifyKey: verifyKey,
	}
}

// Login - used to verify the provided email address and password
//
// POST /login
func (uc *UsrController) Login(w http.ResponseWriter, r *http.Request) {

	// parse the Usr data in JSON format from the incoming request
	var u models.Usr
	decoder := json.NewDecoder(r.Body)
	if err := decoder.Decode(&u); err != nil {
		respondWithError(w, http.StatusBadRequest, "userc: Invalid request payload")
		return
	}
	defer r.Body.Close()

	// fill the Usr model with the data needed for authentication only
	usr := models.Usr{
		Email:    u.Email,
		Password: u.Password,
	}

	// attempt to authenticate the user.  note that writing to
	// the response-writer in advance of setting the cookie will
	// cause the call to http.SetCookie(&cookie) to silently fail.
	authenticatedUsr, err := uc.us.Authenticate(usr.Email, usr.Password)
	if err != nil {
		switch err {
		case models.ErrNotFound:
			log.Println(err)
			respondWithError(w, http.StatusBadRequest, err.Error())
			return
		default:
			log.Println(err)
			respondWithError(w, http.StatusBadRequest, err.Error())
			return
		}
	}

	// token := jwt.New(jwt.SigningMethodRS256)
	token := jwt.New(jwt.SigningMethodES384)
	claims := make(jwt.MapClaims)
	claims["email"] = authenticatedUsr.Email
	claims["id"] = authenticatedUsr.ID
	claims["exp"] = time.Now().Add(time.Hour * time.Duration(1)).Unix()
	claims["iat"] = time.Now().Unix()
	token.Claims = claims

	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintln(w, "Error extracting the key")
		fatal(err)
	}

	tokenString, err := token.SignedString(uc.signKey)

	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintln(w, "Error while signing the token")
		fatal(err)
	}

	response := Token{tokenString}
	respondWithJSON(w, http.StatusOK, response)
}

// Create - process the signup when a usr attempts to create a new usr account.
// It is debatable whether Create should be supported as a general usr creation
// mechanism.
//
// POST /signup
func (uc *UsrController) Create(w http.ResponseWriter, r *http.Request) {

	// parse the Usr data in JSON format from the incoming request
	var u models.Usr
	decoder := json.NewDecoder(r.Body)
	if err := decoder.Decode(&u); err != nil {
		respondWithError(w, http.StatusBadRequest, "usrc: Invalid request payload")
		return
	}
	defer r.Body.Close()

	// fill the Usr model
	usr := models.Usr{
		Name:     u.Name,
		Email:    u.Email,
		Password: u.Password,
	}

	// call the create method on the usr model
	err := uc.us.Create(&usr)
	if err != nil {
		log.Println(err)
		respondWithError(w, http.StatusBadRequest, err.Error())
		return
	}
	respondWithJSON(w, http.StatusCreated, usr)
}

// Delete facilitates the deletion of an existing Usr.  This method is bound
// to the gorilla.mux router in main.go.
//
// DELETE /usr/:id
func (uc *UsrController) Delete(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	id, err := strconv.Atoi(vars["id"])
	if err != nil {
		respondWithError(w, http.StatusBadRequest, "Invalid User ID")
		return
	}

	usr := models.Usr{
		ID: id,
	}

	err = uc.us.Delete(&usr)
	if err != nil {
		if err != nil {
			respondWithError(w, http.StatusBadRequest, err.Error())
			return
		}
	}
	respondWithHeader(w, http.StatusAccepted)
}

func fatal(err error) {
	if err != nil {
		log.Fatal(err)
	}
}
